---
title: Pre-总结反思与问题汇总
date: '2025-10-20T14:35:01+08:00'
math: true
categories: 
- 北航计算机组成原理
tags: ["co", "总结"]
---

### T1.推箱子-Logisim

出现了严重的失误，花了两个多小时导致道心破碎，甚至一度想“大不了爆零吧”。主要需要反思以下几点：

1. 平常“真值表生成状态机"的轮椅题做的太多了，往往没有过多的输入输出设计，导致看到题目第一眼是懵的，甚至还在想怎么设计状态转移图和真值表，“难道要三十个状态吗”，对较新颖的题型不熟练导致没有做题的底气，对于$flag$保持一周的创新点也处理的略微慌张；
2. 对**早晚一拍概念不清晰**，是拿$x$比较还是拿$xnext$比较，到考试结束前五分钟甚至都没有意识到这个问题；
3. 看到$flag$要保持一拍，确实很快想到了要用**寄存器**，但心里不踏实的感觉，有点不敢实践，总想“先不管交一交看一看"，后面用寄存器还是没过，我就以为自己想法错了，开始一阵瞎改，把状态机模块的$flag$直接废除不用了，丝毫没有意识到是$out$的问题；
4. 不会**自动化测试**，手动点在考场紧张的环境下，有时候输出错了也没发现，精神高度紧张可能忽略掉一些东西，有空可以学一学有没有更好的测试方式；
5. 值得夸奖的是我的状态转移模块一般就写对了，没有更多的更改，而且我做的很从容淡定有自信，可能是考试刚开始还很冷静。

本题的解题思路:

先设计状态转移模块$fsm$，用$tunnel$表示$x$,$x+dx$,$y$,$y+dy$，判断$x+dx$是否$>5$，$y+dy$是否$>5$，以及$x$，$y$是否同时等于那六个障碍物的$x$，$y$坐标，将这些或起来，便是我们想要的**实时的下一拍的**$flag$。当然，作为组合逻辑，我们本就只能输出实时的，"保持一拍"得在主电路里实现。注意：$dx$，$dy$要进行**零扩展**变成三位，比较器一定要选$Unsigned$。

然后设计主电路，首先两个$3$位寄存器分别存$x$，$y$当下的值，与$dx$，$dy$一同传入$fsm$模块，得到的$flag$在寄存器中**缓一拍**输出，既实现了将$fsm$模块中对$x+dx$，$y+dy$判断导致的“早一拍”问题，又实现了无$reset$信号时保持一拍，有$reset$立马清零的效果。至于$out$就更简单了，使用比较器判断当前$x$，$y$（可以从寄存器$Q$端引出隧道）是否都为0即可，组合逻辑。

[Pre-T1-电路文件](/files/T1.circ)

### T2.Roll-Verilog

暴露了我Verilog已经几近与忘光了的事实。太久没写，没地方可以评测，没有什么有创新点的题目，对一些稍微进阶的语言技巧都记不太清不敢用。总结一下当中遇到的各种问题：

1. $for$循环怎么写都不会了？是在什么模块里面能写？晚些时候一定要查证一下，在我印象中是$tb$文件的$initial$用的多，要提交的文件应该是尽量不要用$initial$，不能综合还是什么？时序逻辑里不能$for$吗？组合逻辑可以？这次只有$assign$我用着放心，得亏是简单的组合逻辑；（查证：**组合逻辑**和**时序逻辑**都可使用可综合的$for$循环，用在$always$块里即可）
2. $wire$的拼接，用大括号，**从高位到低位**，考场上甚至不确定；
3. **数组的定义方式**！不是像$C$语言一样$a[8]$，应该是$a[7:0]$这种？晚点查证一下；（查证后回答：应是$a[0:7]$）
4. 最初居然定义$reg$类型，明显这里都用$wire$就好，顶多循环变量用$reg$，说明基本概念还没有炉火纯青，虽然看到报错能立马意识到；
5. $testbench$中要不要用$initial$，感觉这还是我第一次直接$assign$，两行就写完了。看向巨的反应我应该写的不对。不确定是不是最好的写法。而且实例化的写法有点忘了，结合报错试探了好几下；（查证：实现一次测试完给的两个测试点，要用$initial$，还是用$initial$比较好，组合逻辑的$testbench$**无需$clk$**，但是也要延迟10s）
6. 对于一部分报错信息看不懂，看到反倒懵了，还是得多练。

本题解题思路：

这题很简单，哪怕设$8+8$个变量然后各种复制粘贴$assign$也是能过的。但是本题的目的是让你学如何使用$for$循环，以及"-："的使用。那么首先这是一道组合逻辑，由输入和逻辑运算直接得到输出，具体操作都给你了，按操作翻译一遍就行，当然我们在写循环的过程中，难免遇到一些问题：

**循环变量**用什么？在`always`外面设`integer`

1. $for$放在哪？放在`always @(*)`里面
2. 数组是怎么定义的？`wire [3:0] a[0:7]`
3. 注意$i++$会报错，Verilog没有这种语法，要用$i=i+1$
4. 如果直接`arr[i]=a[(i + 1) * 4 - 1-:i*4]`，会收到报错：$i\ is\ not\ a\ constant$。其实并不是要求中括号内非得都是常数，**只要冒号左右两边不全为变量就行**。于是我们学会使用`[i-:4]`，意思是**往低里取从$i$开始$4$个位**。

最后将`sum[i]`用**大括号拼接**起来，`assign`给$out$就行了。代码及其$testbench$见下：

```verilog
module roll(
    input [31:0] a,
    output [31:0] out
    );
reg [3:0] arr[0:7],sum[0:7],tmp;
integer i,j;
always @(*) begin
	for(i=0;i<8;i=i+1) begin
		arr[i]=a[(i + 1) * 4 - 1-:4];
	end
	sum[0]=arr[0];
	for(i=0;i<7;i=i+1) begin
		sum[i+1]=sum[i]+arr[i+1];
	end
end
assign out={sum[7],sum[6],sum[5],sum[4],sum[3],sum[2],sum[1],sum[0]};
endmodule
```

```verilog
module tbroll(
    );
reg [31:0] a;
wire [31:0] out;
initial begin
	a=32'h11111111;
	#10;
	a=32'h87654321;
	#10;
end
roll r(a,out);
endmodule
```



### T3.Submatrix-MIPS

整体写法和常用指令确实记得，但是很多地方也不熟练或遗忘了。总结问题如下：

1. 不记得宏定义怎么写了，那些找矩阵下标，输入输出，平常复制粘贴惯了，国庆好好记一下；
2. 由于天天复制粘贴宏定义，导致输入输出也不熟练，甚至完全遗忘了字符串是怎么输出的，还好在$help$文档里翻到了一处$la$提醒了我；
3. 助教问答环节回答的不是很理想，要注意记一下各个**寄存器的作用**；
4. 中间错误的想要用乘法，发现不会用，对乘除的$HI$，$LO$**怎么分配**，要再看一看，记一下并实战应用一下；
5. 这次有时间不够的原因，做的很匆忙思路都没成型，导致删删改改很多，之后要整体**构思**好；

本题解题思路:

没有递归和函数调用，所以是一道比较简单的MIPS题，考验你基本的输入输出，宏定义，寻址，循环等内容。可以不用写出C语言代码直接写。首先我们要能熟练的写出那些常用的宏定义，平常的练习中经常直接复制粘贴，可上机考试的时候没有办法投机取巧，只能自己老老实实打，这个时候像我一样忘了怎么输出字符串就很致命了。我们需要给矩阵开至少$4\times 4\times 4$的空间，用`asciiz`定义空格，换行与`"Out of bounds"`。输入循环$16$次，用$beq$跳出。先用`bgt`判断$i+m$和$j+n$是否存在$>4$的情况，有就跳转到`error`，直接输出报错的字符串就行。接着往后写二重循环，外层从$i$到$i+m-1$，内层由$j$到$j+m-1$，注意不要漏掉

1. 每个循环末尾$j$指令
2. $j$指令前将循环变量$+1$
3. 外层循环每次回到开头进入新一轮循环，将内层循环变量**复位**
4. 内层循环每输出一个数输出一个空格
5. 外层循环$j$前输出换行符

至于寄存器的作用：

| 寄存器编号         | 助记符         | 名称           | 用途                                                         | 是否在调用中保持 |
| :----------------- | :------------- | :------------- | :----------------------------------------------------------- | :--------------- |
| **零寄存器**       |                |                |                                                              |                  |
| 0                  | `$zero`        | 常数零         | 其值恒为0，读取它总是返回0，写入它无效。                     | 不适用           |
| **保留寄存器**     |                |                |                                                              |                  |
| 1                  | `$at`          | 汇编临时寄存器 | 被汇编器保留，用于处理大的立即数或地址加载（如 `lui` 指令）。**程序员不应直接使用。** | 否               |
| **返回值寄存器**   |                |                |                                                              |                  |
| 2-3                | `$v0` - `$v1`  | 值寄存器       | 用于存放**函数调用的返回值**。如果返回值大小超过一个寄存器（如64位整数），则使用 `$v0` 和 `$v1` 共同存放。 | 否               |
| **参数寄存器**     |                |                |                                                              |                  |
| 4-7                | `$a0` - `$a3`  | 参数寄存器     | 用于向函数传递**前四个参数**。如果参数多于四个，超出的部分会通过栈来传递。 | 否               |
| **临时寄存器**     |                |                |                                                              |                  |
| 8-15               | `$t0` - `$t7`  | 临时寄存器     | 用于存放**临时变量**。在函数调用中，这些寄存器的值**不保证**被调用者保存。如果调用函数后还需要这些值，调用者必须自己保存。 | 否               |
| **保存寄存器**     |                |                |                                                              |                  |
| 16-23              | `$s0` - `$s7`  | 保存寄存器     | 用于存放**需要跨函数调用保留的局部变量**。如果一个函数使用了这些寄存器，它**必须**在函数开始时保存它们的原始值（通常在栈上），并在函数返回前恢复它们。 | 是               |
| **更多临时寄存器** |                |                |                                                              |                  |
| 24-25              | `$t8` - `$t9`  | 临时寄存器     | 与 `$t0-$t7` 作用相同，是额外的临时寄存器。                  | 否               |
| **内核寄存器**     |                |                |                                                              |                  |
| 26-27              | `$k0` - `$k1`  | 内核保留寄存器 | 专门为**操作系统内核**（如中断和异常处理程序）保留。应用程序**不应使用**这些寄存器。 | 否               |
| **全局指针寄存器** |                |                |                                                              |                  |
| 28                 | `$gp`          | 全局指针       | 指向静态数据区（存储全局变量和静态变量）的中间位置。通过 `$gp` 可以更方便地用单条指令访问64KB范围内的全局数据，而不需要每次都使用 `lui` 和 `ori` 两条指令。 | 是               |
| **栈指针寄存器**   |                |                |                                                              |                  |
| 29                 | `$sp`          | 栈指针         | 指向运行时栈的顶部。栈用于存放函数返回地址、保存的寄存器、局部变量等。`$sp` 必须按字（4字节）对齐。 | 是               |
| **帧指针寄存器**   |                |                |                                                              |                  |
| 30                 | `$fp` 或 `$s8` | 帧指针         | 指向当前函数栈帧的底部。它提供了一个固定的参考点，方便访问栈上的参数和局部变量，尤其是在栈指针 `$sp` 动态变化时。虽然它被列为 `$s8`，但其作用更像一个专用的帧指针。 | 是               |
| **返回地址寄存器** |                |                |                                                              |                  |
| 31                 | `$ra`          | 返回地址       | 当使用 `jal`（跳转并链接）指令调用函数时，下一条指令的地址（返回地址）会自动存入 `$ra`。函数结束时通常通过 `jr $ra` 指令返回到调用点。 | 否               |

完整代码见下，宏定义板子也可自取：

```assembly
.macro end
	li $v0,10
	syscall
.end_macro 

.macro getInt(%des)
	li $v0,5
	syscall 
	move %des,$v0
.end_macro 
	
.macro printInt(%src)
	move $a0,%src
	li $v0,1
	syscall 
.end_macro 

.macro printStr(%src)
	la $a0,%src
	li $v0,4
	syscall 
.end_macro 

.macro push(%src)
	addi $sp,$sp,-4
	sw %src 0($sp)
.end_macro 

.macro getIndex(%src1,%src2,%des)
	sll %des,%src1,2
	add %des,%des,%src2
	sll %des,%des,2
.end_macro 

.data
	a: .space 100
	space: .asciiz " "
	nxtline: .asciiz "\n"
	err: .asciiz "Out of bounds"

.text
li $s0,16
li $t0,0
for_in:
	beq $t0,$s0,for_in_end
	getInt($t1)
	sll $t2,$t0,2
	sw $t1 a($t2)
	addi $t0,$t0,1
	j for_in

for_in_end:
getInt($s1)					#s1=m
getInt($s2)					#s2=n
getInt($s3)					#s3=i
getInt($s4)					#s4=j

add $t4,$s1,$s3
add $t5,$s2,$s4
bgt $t4,4,error
bgt $t5,4,error

move $t0,$s3
for_i:
	beq $t0,$t4,for_i_end
	move $t1,$s4
	for_j:
		beq $t1,$t5,for_j_end
		getIndex($t0,$t1,$t2)
		lw $t3,a($t2)
		printInt($t3)
		printStr(space)
		addi $t1,$t1,1
		j for_j
	for_j_end:
		addi $t0,$t0,1
		printStr(nxtline)
		j for_i
for_i_end:
	end

error:
	printStr(err)
end
														
```

下面附本次上机题目：

（注：本次上机全部做对才算通过）



# T1-推箱子

独小星在玩一个简化版的推箱子游戏，请你设计一个状态机，根据输入来判断箱子是否被推到了目标点并输出。

## 提交要求

### 任务要求

游戏地图建立在一个二维平面直角坐标系中，箱子在游戏开始或每次$reset$后位于$(0,0)$坐标处。推箱子的目标点固定位于$(5,5)$坐标处。

游戏地图大小为：以$(0,0)$为左下角，以$(5,5)$为右上角，边长为$5$的正方形 (共$6\times6=36$个坐标点) 。 位于游戏地图内，当且仅当 。

游戏地图中的坐标点分为墙体和空地。墙体固定为：$(1,1)$ ，$(1,2)$，$(2,1)$，$(4,4)$，$(4,3)$，$(3,4)$ 这 个坐标点。墙体是不可到达区域。

每周期输入一对$(dx,dy)$，表示箱子的移动变化量。若箱子当前坐标为$(x,y)$，则箱子的预期落脚点为$(x+dx,y+dy)$ 。

如果箱子的预期落脚点是合法的 (合法定义见下文) ，则在下一周期更新箱子的坐标为该落脚点。如果箱子的预期落脚点不合法，则将$flag$置为$1$持续一周期，下一周期箱子坐标保持不动。

保证每周期输入的 只会是：$(0,0)$ ，$(1,0)$，$(0,1)$ 这$3$种中的一种。

箱子的预期落脚点是合法的，**当且仅当该落脚点位于游戏地图内，并且该落脚点不是墙体**。

当箱子坐标位于目标点时，输出$out$为$1$ ，否则为$0$。

游戏地图大致如下：

![grid](/images/posts/grid.png)

### 输入输出

| 名称  | 功能                   | 位宽 | 方向 |
| ----- | ---------------------- | ---- | ---- |
| clk   | 时钟信号               | 1    | I    |
| reset | **异步**复位信号       | 1    | I    |
| dx    | 坐标移动变化量         | 1    | I    |
| dy    | 坐标移动变化量         | 1    | I    |
| out   | 箱子是否位于目标点     | 1    | O    |
| flag  | 是否尝试移动到非法坐标 | 1    | O    |

- **输入**：保证每周期输入的$(dx,dy)$只会是：$(0,0)$ ，$(1,0)$，$(0,1)$ 这$3$种中的一种。
- **输出**：$flag$默认为$0$，若当前周期箱子尝试移动到非法坐标，则下一周期$flag$置为$1$( 若有$reset$则立刻复位为$1$)。
- **文件内模块名**: **Sokoban**
- **测试电路图**：

![testcirc](/images/posts/testcirc.png)

- **注意：请保证模块的 appearance 与下图一致，否则有可能造成评测错误。注意输入的上下顺序。**

![fmt](/images/posts/fmt.png)

# T2-翻涌数字

## 1、简介

给出一个位宽为$32$的输入 ，代表$8$个位宽为$4$的数据，分别命名为$a_0$，$a_1$，…… ，$a_7$ 。

其中$a_i$= $a[(i+1)\times 4 -1:i\times 4]$

对每一个$a_i$进行操作，使得$a_i$= $\sum_{j=0}^{i}a_j$

对操作后得到的$a_i$按原顺序进行拼接，并输出拼接后的$a$。

特别的：若$a_i$相加时出现溢出，则保留对 `4'd16` 取余后的结果。

## 2、模块规格

模块名：roll

| 信号名    | 方向 | 描述         |
| --------- | ---- | ------------ |
| a[31:0]   | I    | 用于计算的数 |
| out[31:0] | O    | 计算结果     |

## 3、输入输出样例

![wave](/images/posts/wave.png)

如图，当 为 `32'h11111111` 时， 为 `32'h87654321` 。

当 为 `32'h87654321` 时， 为 `32'h4c5fa631` 。

## 4、提交要求

- 必须严格按照模块的端口名称和方向定义。
- 文件内模块名： roll
- 模块内不要包含任何 `$display` 语句，以防造成误判。

## T3-MIPS_Submatrix

### 功能需求

实现 MIPS 汇编程序：从 $4 × 4$ 的大矩阵 $A$ 中提取出指定位置指定大小的子矩阵。

### 输入格式

第 1 - 16 行依次输入大矩阵 $A$ 的元素 $t$（整数， $0 ≤ t ≤ 100$）：

- 第一行： $A$ 第 0 行第 0 列的元素
- 第二行： $A$ 第 0 行第 1 列的元素
- …… （依此类推）

第 17 行输入一个整数 $m$ ，表示子矩阵的行数（$1 ≤ m ≤ 4$）。

第 18 行输入一个整数 $n$ ，表示子矩阵的列数（$1 ≤ n ≤ 4$）。

第 19 行输入一个整数 $i$ ，表示子矩阵的第 0 行第 0 列元素在大矩阵 $A$ 中的行数（$0 ≤ i ≤ 3$）。

第 20 行输入一个整数 $j$ ，表示子矩阵的第 0 行第 0 列元素在大矩阵 $A$ 中的列数（$0 ≤ j ≤ 3$）。

### 输出格式

1. 若子矩阵完全位于大矩阵内，未超出边界：输出$m*n$子矩阵，共 $m$ 行，每行 $n$ 个元素（空格分隔）。
2. 若超出边界：输出字符串 `Out of bounds`。

### 约定

1. 大矩阵 $A$ 的行索引和列索引从 0 开始编号。
2. 请勿使用 `.globl main`
3. 请使用 `syscall` 结束程序：

```mips
li $v0, 10
syscall
```

### 输入样例 1

```none
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
2
2
1
1
```

### 输出样例 1

```none
6 7
10 11
```

### 输入样例 2

```none
4
3
2
1
8
7
6
5
12
11
10
9
13
14
15
16
3
2
2
2
```

### 输出样例 2

```none
Out of bounds
```