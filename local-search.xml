<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2025-2026概率与数理模型期末试卷参考答案</title>
    <link href="/posts/2025-2026%E6%A6%82%E7%8E%87%E4%B8%8E%E6%95%B0%E7%90%86%E6%A8%A1%E5%9E%8B%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/"/>
    <url>/posts/2025-2026%E6%A6%82%E7%8E%87%E4%B8%8E%E6%95%B0%E7%90%86%E6%A8%A1%E5%9E%8B%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="2025-2026概率与数理模型期末试卷参考答案"><a href="#2025-2026概率与数理模型期末试卷参考答案" class="headerlink" title="2025-2026概率与数理模型期末试卷参考答案"></a>2025-2026概率与数理模型期末试卷参考答案</h1><h3 id="一、选择题（每题2分，共20分）"><a href="#一、选择题（每题2分，共20分）" class="headerlink" title="一、选择题（每题2分，共20分）"></a>一、选择题（每题2分，共20分）</h3><ol><li><p><strong>B</strong></p><ul><li><strong>解析</strong>：<ul><li>A错：$B \subset A \implies A \cup B = A$，故 $P(A \cup B) = P(A)$，除非 $P(A)=P(B)$ 否则不相等。</li><li>B对：$B \subset A \implies AB = B$，故 $P(AB) = P(B)$。</li><li>C错：$P(A|B) = P(AB)/P(B) = P(B)/P(B) = 1$，而 $P(A)$ 不一定为1。</li><li>D错：包含关系不可能是对立事件（除非全是空集或全集，通常不讨论退化情况）。</li></ul></li></ul></li><li><p><strong>C</strong></p><ul><li><strong>解析</strong>：$X$ 与 $-X$ 同分布，说明概率密度关于 $y$ 轴对称（偶函数）。<ul><li>$f(x) = f(-x)$，C正确。</li><li>分布函数性质：$F(x) = 1 - F(-x)$，故 A、B 错误。</li></ul></li></ul></li><li><p><strong>A</strong></p><ul><li><strong>解析</strong>：首先归一化求 $A$。$\int_\lambda^{+\infty} A e^{-x} dx = A e^{-\lambda} = 1 \implies A = e^\lambda$。<ul><li>$f(x) = e^{\lambda - x} (x &gt; \lambda)$。</li><li>$P(\lambda &lt; X &lt; \lambda + a) = \int_\lambda^{\lambda+a} e^{\lambda-x} dx = [-e^{\lambda-x}]_\lambda^{\lambda+a} = 1 - e^{-a}$。</li><li>结果只与 $a$ 有关，且 $a$ 越大，$e^{-a}$ 越小，概率越大。故选 A。</li></ul></li></ul></li><li><p><strong>BC</strong></p><ul><li><strong>解析</strong>：$D(X+Y) = D(X) + D(Y) + 2Cov(X,Y)$。<ul><li>等式成立 $\iff Cov(X,Y) = 0 \iff X, Y$ 不相关。</li><li>不相关不一定独立，独立一定不相关。故选 C。</li></ul></li></ul></li><li><p><strong>B</strong></p><ul><li><strong>解析</strong>：$X \sim P(\lambda)$，则 $E(X) = \lambda, D(X) = \lambda$。<ul><li>$E(X^2) = D(X) + [E(X)]^2 = \lambda + \lambda^2$。</li><li>$E[(X-1)(X-2)] = E[X^2 - 3X + 2] = (\lambda+\lambda^2) - 3\lambda + 2 = \lambda^2 - 2\lambda + 2$。</li><li>令 $\lambda^2 - 2\lambda + 2 = 1 \implies (\lambda-1)^2 = 0 \implies \lambda = 1$。</li></ul></li></ul></li><li><p><strong>A</strong></p><ul><li><strong>解析</strong>：无偏性要求系数和为1。A、B、C均满足，D不满足。<ul><li>有效性看方差最小。</li><li>$D(\hat{\mu}_1) = (4/9 + 1/9)\sigma^2 = 5/9 \sigma^2 \approx 0.56\sigma^2$。</li><li>$D(\hat{\mu}_2) = (9/4 + 1/4)\sigma^2 = 2.5 \sigma^2$。</li><li>$D(\hat{\mu}_3) = (1/16 + 9/16)\sigma^2 = 10/16 \sigma^2 = 0.625\sigma^2$。</li><li>$5/9 &lt; 5/8$，故 A 最有效。</li></ul></li></ul></li><li><p><strong>A</strong></p><ul><li><strong>解析</strong>：单因素方差分析。<ul><li>组数 $r=3$，每组样本 $n_i=5$，总样本 $n=15$。</li><li>自由度：组间 $df_1 = 3-1=2$，组内 $df_2 = 15-3=12$。</li><li>查表：$F_{0.05}(2, 12) = 3.89$。</li><li>甲 $F=4 &gt; 3.89$（拒绝原假设，有显著差异）。</li><li>乙 $F=6 &gt; 3.89$（拒绝原假设，有显著差异）。</li></ul></li></ul></li></ol><hr><h3 id="二、填空题（每题3分，共12分）"><a href="#二、填空题（每题3分，共12分）" class="headerlink" title="二、填空题（每题3分，共12分）"></a>二、填空题（每题3分，共12分）</h3><ol><li><p><strong>$4/7$</strong></p><ul><li><strong>解析</strong>：$P(A \cup B) = P(A) + P(B) - P(AB)$。独立 $\implies P(AB) = P(A)P(B) = 0.3\alpha$。</li><li>$0.7 = \alpha + 0.3 - 0.3\alpha \implies 0.4 = 0.7\alpha \implies \alpha = 4/7$。</li></ul></li><li><p><strong>$a=1, b=1/2$</strong></p><ul><li><strong>解析</strong>：<ul><li>归一性：$\int_0^1 (ax+b)dx = a/2 + b = 1$ ①</li><li>概率条件：$\int_{1/2}^1 (ax+b)dx = [ax^2/2 + bx]_{1/2}^1 = (a/2+b) - (a/8+b/2) = 3a/8 + b/2 = 5/8$ ②</li><li>联立①②解得 $a=1, b=1/2$。</li></ul></li></ul></li><li><p><strong>$\lim_{n \to \infty} P(|\frac{m}{n} - p| &lt; \epsilon) = 1$</strong></p><ul><li><strong>解析</strong>：这是伯努利大数定律的标准定义，描述频率依概率收敛于概率。</li></ul></li><li><p><strong>${\bar{x} \mid 10 - z_{\alpha/2}\frac{\sigma}{5} &lt; \bar{x} &lt; 10 + z_{\alpha/2}\frac{\sigma}{5}}$</strong> （或写区间形式）</p><ul><li><strong>解析</strong>：双侧检验的接受域为统计量绝对值小于临界值。</li><li>$|\frac{\bar{x}-10}{\sigma/\sqrt{25}}| &lt; z_{\alpha/2}$，化简即得。</li></ul></li></ol><hr><h3 id="三、简答题（每题6分，共18分）"><a href="#三、简答题（每题6分，共18分）" class="headerlink" title="三、简答题（每题6分，共18分）"></a>三、简答题（每题6分，共18分）</h3><ol><li><p><strong>解</strong>：<br>设 $R_i$ 表示第 $i$ 次取到红球，$W_i$ 表示第 $i$ 次取到白球。初始：3红2白，总数5。</p><ul><li>$P(R_1) = 3/5$。加入2红，此时罐中有5红2白，总数7。</li><li>$P(R_2|R_1) = 5/7$。加入2红，此时罐中有7红2白，总数9。</li><li>$P(W_3|R_1R_2) = 2/9$。加入2白，此时罐中有7红4白，总数11。</li><li>$P(W_4|R_1R_2W_3) = 4/11$。<br>由乘法公式：<script type="math/tex; mode=display">P = \frac{3}{5} \times \frac{5}{7} \times \frac{2}{9} \times \frac{4}{11} = \frac{3 \times 5 \times 2 \times 4}{5 \times 7 \times 9 \times 11} = \frac{8}{231}</script><strong>答：概率为 $8/231$。</strong></li></ul></li><li><p><strong>解</strong>：<br>设 $X$ 为开机的计算机数量。$X \sim B(n, p)$，其中 $n=2000, p=0.6$。<br>期望 $E(X) = np = 1200$，方差 $D(X) = np(1-p) = 2000 \times 0.6 \times 0.4 = 480$。<br>由于 $n$ 很大，由中心极限定理，$X$ 近似服从 $N(1200, 480)$。<br>设供电量为 $W$ 千瓦，即能支持 $W/a$ 台计算机。令 $k = W/a$为整数。<br>要求 $P(X \le k) \ge 0.9999$。<br>标准化：$P(\frac{X - 1200}{\sqrt{480}} \le \frac{k - 1200}{\sqrt{480}}) \ge 0.9999$。<br>查标准正态分布表（提示值）：$\Phi(3.72) = 0.9999$。<br>故 $\frac{k - 1200}{\sqrt{480}} \ge 3.72$。<br>$k \ge 1200 + 3.72 \times \sqrt{480} \approx 1200 + 3.72 \times 21.91 \approx 1200 + 81.5 = 1281.5$。</p><p>总电力 $W = k \cdot a = 1282a$。<br><strong>答：至少应提供 $1282a$ 千瓦的电力。</strong></p></li><li><p><strong>解</strong>：<br>考察单个样本 $X_i \sim B(n, p)$。<br>计算二阶矩：$E(X_i^2) = D(X_i) + [E(X_i)]^2 = np(1-p) + n^2p^2 = np - np^2 + n^2p^2$。<br>计算组合期望：<br>$E[X_i(X_i - 1)] = E(X_i^2) - E(X_i) = (np - np^2 + n^2p^2) - np \newline = n^2p^2 - np^2 = p^2(n^2 - n) = n(n-1)p^2$<br>对于统计量 $\hat{\theta}$：<br>$E[\hat{\theta}] = c \sum_{i=1}^k E[X_i(X_i-1)] = c \cdot k \cdot n(n-1)p^2$。<br>令其等于 $p^2$（无偏估计定义），得：<br>$c \cdot k \cdot n(n-1) = 1 \implies c = \frac{1}{kn(n-1)}$。<br><strong>答：$c = \frac{1}{kn(n-1)}$。</strong></p></li></ol><hr><h3 id="四、计算题（每题8分，共40分）"><a href="#四、计算题（每题8分，共40分）" class="headerlink" title="四、计算题（每题8分，共40分）"></a>四、计算题（每题8分，共40分）</h3><ol><li><p><strong>解</strong>：<br>利用概率加法公式（容斥原理）：<br>$P(A \cup B) = P(A) + P(B) - P(AB)$。<br>事件 ${\max{X, Y} \ge 0}$ 等价于事件 ${X \ge 0} \cup {Y \ge 0}$。<br>$P(\max{X, Y} \ge 0) = P(X \ge 0) + P(Y \ge 0) - P(X \ge 0, Y \ge 0)$<br>$= \frac{4}{7} + \frac{4}{7} - \frac{3}{7} = \frac{5}{7}$。<br><strong>答案：$5/7$</strong>。</p></li><li><p><strong>解</strong>：<br>区域 $D$ 为顶点在 $(0,0), (2,0), (2,2)$ 的三角形。<br>面积 $S_D = \frac{1}{2} \times 2 \times 2 = 2$。<br>(1) 联合概率密度：<br>$f(x, y) = \begin{cases} \frac{1}{S_D} = \frac{1}{2}, &amp; (x, y) \in D \newline 0, &amp; \text{其他} \end{cases}$<br>区域 $D$ 可表示为 $0 &lt; x &lt; 2, 0 &lt; y &lt; x$。<br>(2) 边缘概率密度 $f_X(x)$：<br>当 $0 &lt; x &lt; 2$ 时，</p><script type="math/tex; mode=display">f_X(x) = \int_{-\infty}^{+\infty} f(x, y) dy = \int_0^x \frac{1}{2} dy = \frac{x}{2}</script><p><strong>答案</strong>：<br>$f(x,y) = 1/2$ (在区域内);<br>$f_X(x) = \begin{cases} x/2, &amp; 0&lt;x&lt;2 \newline 0, &amp; \text{其他} \end{cases}$</p></li><li><p><strong>解</strong>：<br>(1) 由 $\int_{-\infty}^{+\infty} A e^{-|x|} dx = 1$，利用偶函数性质：<br>$2A \int_0^{+\infty} e^{-x} dx = 2A [ -e^{-x} ]_0^{+\infty} = 2A(0 - (-1)) = 2A = 1 \implies A = 1/2$。<br>(2) 当 $x &lt; 0$ 时，$F(x) = \int_{-\infty}^x \frac{1}{2} e^t dt = \frac{1}{2} e^x$。<br>当 $x \ge 0$ 时，$F(x) = \int_{-\infty}^0 \frac{1}{2} e^t dt + \int_0^x \frac{1}{2} e^{-t} dt = \frac{1}{2} + \frac{1}{2}(1 - e^{-x}) = 1 - \frac{1}{2} e^{-x}$。<br>(3) $P(-1 &lt; X &lt; 1) = F(1) - F(-1) = (1 - \frac{1}{2}e^{-1}) - (\frac{1}{2}e^{-1}) = 1 - e^{-1}$。<br><strong>答案</strong>：$A=1/2$；分布函数分段如上；概率为 $1 - 1/e$。</p></li><li><p><strong>解</strong>：<br>设样本中次品个数为 $Y \sim B(n, p)$，样本次品率 $\bar{X} = Y/n$。<br>已知 $p=0.02$，要求 $P(\bar{X} &lt; 0.04) ≥ 0.977$。<br>根据中心极限定理，$\bar{X} \sim N(p, \frac{p(1-p)}{n})$。<br>标准化 $Z = \frac{\bar{X} - p}{\sqrt{p(1-p)/n}}$。<br>$P(\bar{X} &lt; 0.04) = P(Z &lt; \frac{0.04 - 0.02}{\sqrt{0.02 \times 0.98 / n}}) = P(Z &lt; \frac{0.02 \sqrt{n}}{\sqrt{0.0196}}) ≥ 0.977$。<br>已知 $\Phi(2) = 0.977$，故要求：<br>$\frac{0.02 \sqrt{n}}{0.14} ≥ 2 \implies \sqrt{n} ≥ \frac{0.28}{0.02} = 14 \implies n ≥ 196$。<br><strong>答案：至少需要抽取 196 个产品（或者 $n≥196$）。</strong></p></li><li><p><strong>解</strong>：<br>(1) $X \sim Exp(\theta)$，$F_X(x) = 1 - e^{-\theta x} (x&gt;0)$。<br>$Z = \max{X_1, X_2}$。<br>分布函数 $F_Z(z) = P(X_1 \le z) P(X_2 \le z) = (1 - e^{-\theta z})^2, \quad z&gt;0$。<br>密度函数 $f_Z(z) = [F_Z(z)]’ = 2(1 - e^{-\theta z})(\theta e^{-\theta z}) = 2\theta (e^{-\theta z} - e^{-2\theta z}), \quad z&gt;0$。<br>(2) 求 $Z$ 的期望：<br>利用 $E(Z) = \int_0^\infty z f_Z(z) dz = 2\theta [\int_0^\infty z e^{-\theta z} dz - \int_0^\infty z e^{-2\theta z} dz]$。<br>$E(Z) = \int z \cdot 2\theta e^{-\theta z} dz - \int z \cdot 2\theta e^{-2\theta z} dz = 2(1/\theta) - 2\theta \cdot \frac{1}{(2\theta)^2} = \frac{2}{\theta} - \frac{1}{2\theta} = \frac{3}{2\theta}$。<br>令矩估计值等于样本均值：$\bar{Z} = \frac{3}{2\hat{\theta}}$。<br>解得 $\hat{\theta} = \frac{3}{2\bar{Z}}$。<br><strong>答案</strong>：(1) $f_Z(z)=2\theta(e^{-\theta z}-e^{-2\theta z})$; (2) $\hat{\theta} = \frac{3}{2\bar{Z}}$。</p></li></ol><hr><h3 id="五、应用题（10分）"><a href="#五、应用题（10分）" class="headerlink" title="五、应用题（10分）"></a>五、应用题（10分）</h3><p><strong>参考解答：</strong></p><ol><li><p><strong>分析文本的概率统计方法</strong>：</p><ul><li><strong>模型与知识点</strong>：<ul><li><strong>N-gram 语言模型（马尔可夫链）</strong>：利用条件概率 $P(w_i | w_{i-n+1}, \dots, w_{i-1})$ 来分析词语搭配的合理性。朱自清的《荷塘月色》有特定的词汇共现概率（如“曲曲折折”后接“荷塘”的概率极高），可以通过计算这段文本在特定语料库下的<strong>困惑度（Perplexity）</strong>来分析。</li><li><strong>词频分布</strong>：人类语言通常符合长尾分布，而早期或过度优化的AI模型生成的文本在词频分布上可能过于平滑，我们可以检验词频统计量的分布特征。</li><li><strong>信息熵（Entropy）</strong>：人类语言的信息密度和熵值通常具有波动性（Burstiness），而AI生成的文本往往为了追求概率最大化，导致熵值相对稳定。</li></ul></li></ul></li><li><p><strong>检测方案设计</strong>：</p><ul><li><strong>方案名称</strong>：基于贝叶斯分类器的AI文本检测系统。</li><li><strong>步骤</strong>：<ol><li><strong>特征提取</strong>：<ul><li>定义特征向量 $\mathbf{x} = (x_1, x_2, x_3)$。</li><li>$x_1$：文本的平均困惑度（Perplexity）。</li><li>$x_2$：句法结构的多样性方差（利用卡方检验统计量）。</li><li>$x_3$：特定虚词的使用频率（二项分布假设检验）。</li></ul></li><li><strong>训练阶段</strong>：<ul><li>收集大量已知人类文本 ($Y=0$) 和 AI文本 ($Y=1$)。</li><li>统计先验概率 $P(Y=0)$ 和 $P(Y=1)$。</li><li>估计条件概率密度 $f(\mathbf{x} | Y=0)$ 和 $f(\mathbf{x} | Y=1)$（通常假设特征服从高斯分布或使用核密度估计）。</li></ul></li><li><strong>判别阶段（贝叶斯公式）</strong>：<ul><li>对于待检测文本，计算其后验概率：<script type="math/tex; mode=display">P(Y=1 | \mathbf{x}) = \frac{f(\mathbf{x}|Y=1)P(Y=1)}{f(\mathbf{x}|Y=1)P(Y=1) + f(\mathbf{x}|Y=0)P(Y=0)}</script></li><li>若 $P(Y=1 | \mathbf{x}) &gt; 0.5$（或根据误判代价设定的阈值），则判定为AI生成。</li></ul></li></ol></li><li><strong>涉及知识点</strong>：贝叶斯公式、条件概率、随机变量的特征提取、假设检验（用于特征筛选）。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>往年题</category>
      
      <category>往年题解答</category>
      
    </categories>
    
    
    <tags>
      
      <tag>往年题</tag>
      
      <tag>往年题解答</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-2026离散数学2期末试卷参考答案</title>
    <link href="/posts/2025-2026%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/"/>
    <url>/posts/2025-2026%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="2025-2026-离散数学2期末试卷-参考答案"><a href="#2025-2026-离散数学2期末试卷-参考答案" class="headerlink" title="2025-2026 离散数学2期末试卷 参考答案"></a>2025-2026 离散数学2期末试卷 参考答案</h1><p><strong>一、 判断题</strong></p><ol><li>对于集合A,B,C,D，若$A \subset C$，$B \subset D$，则$A\cup B \subset C \cup D$。<ul><li><strong>答案：错误 (False)</strong></li><li><strong>解析：</strong><br>符号 $\subset$ 通常表示<strong>真子集</strong>（即包含但不想等）。<br><strong>反例：</strong><br>设 $C = \{1, 2\}, D = \{1, 2\}$。<br>设 $A = \{1\}$ （满足 $A \subset C$），$B = \{2\}$ （满足 $B \subset D$）。<br>此时 $A \cup B = \{1, 2\}$，而 $C \cup D = \{1, 2\}$。<br>虽然 $A \cup B \subseteq C \cup D$ 成立，但它们相等，不满足真子集 $A \cup B \subset C \cup D$ 的条件。</li></ul></li></ol><hr><p><strong>二、 关系性质与运算</strong></p><p>设集合 $A=\{1,2,3,4\}$。</p><p><strong>1. 关系性质分析</strong></p><ul><li><strong>$R_1 = \{(1,2), (2,3), (3,1), (1,4), (2,4), (3,4)\}$</strong><ul><li><strong>自反性：</strong> 无（缺对角线元素）。</li><li><strong>反自反性：</strong> <strong>有</strong>（无任何 $(x,x)$）。</li><li><strong>对称性：</strong> 无（有 $(1,2)$ 无 $(2,1)$）。</li><li><strong>反对称性：</strong> <strong>有</strong>（互异元素间不同时存在双向边）。</li><li><strong>传递性：</strong> 无（有 $(1,2),(2,3)$ 但无 $(1,3)$）。</li></ul></li><li><strong>$R_2 = \{(1,1), (2,2), (3,3), (4,4), (1,2), (2,1), (2,3), (3,4), (4,1)\}$</strong><ul><li><strong>自反性：</strong> <strong>有</strong>（包含所有对角线元素）。</li><li><strong>反自反性：</strong> 无。</li><li><strong>对称性：</strong> 无（有 $(2,3)$ 无 $(3,2)$）。</li><li><strong>反对称性：</strong> 无（同时存在 $(1,2)$ 和 $(2,1)$）。</li><li><strong>传递性：</strong> 无（有 $(1,2),(2,3)$ 但无 $(1,3)$）。</li></ul></li></ul><p><strong>2. 复合关系 $R_1 \circ R_2$</strong></p><p>$R_1 \circ R_2 = \{(1,1), (1,2), (1,3), (1,4), (2,1), (2,3), (2,4), (3,1), (3,2), (3,4)\}$</p><p><strong>3. $R_2$ 的传递闭包 $t(R_2)$</strong></p><p> $t(R_2) = A \times A$ （全关系，包含16个元素）。</p><hr><p><strong>三、 偏序关系</strong></p><p>集合 $A=\{1,2,3,4,6,9,12,18\}$，关系为整除。</p><ol><li><strong>哈斯图：</strong><ul><li>底层：1</li><li>第二层：2, 3</li><li>第三层：4, 6, 9</li><li>顶层：12, 18</li></ul></li><li><strong>子集 $S=\{2,3,4,6,9\}$：</strong><ul><li><strong>最大元：</strong> 无（4, 6, 9 互不整除）。</li><li><strong>最小元：</strong> 无（2, 3 互不整除）。</li><li><strong>极大元：</strong> 4, 6, 9（S中没有它们的倍数）。</li><li><strong>极小元：</strong> 2, 3（S中没有它们的因子）。</li></ul></li><li><strong>子集 $S=\{3,6,9,18\}$：</strong><ul><li><strong>上界：</strong> 18 （18能被S中所有元素整除，且在A中无更大倍数）。</li><li><strong>最小上界：</strong> 18。</li><li><strong>下界：</strong> 必须整除S中所有数（即整除 gcd(3,6,9,18)=3）。在A中为 1, 3。</li><li><strong>最大下界：</strong> 3。</li></ul></li></ol><hr><p><strong>四、 等价关系证明</strong></p><p><strong>证明：</strong><br>已知 $R, S$ 为等价关系（自反、对称、传递）。</p><ol><li>($\Rightarrow$) 若 $R \circ S$ 是等价关系，则它是对称的。即 $(R \circ S)^{-1} = R \circ S$。<br>展开得 $S^{-1} \circ R^{-1} = R \circ S$。因 $R,S$ 对称，故 $S \circ R = R \circ S$。</li><li>($\Leftarrow$) 若 $S \circ R = R \circ S$。<ul><li>自反：$I \subseteq R, I \subseteq S \Rightarrow I \subseteq R \circ S$。</li><li>对称：$(R \circ S)^{-1} = S^{-1} \circ R^{-1} = S \circ R = R \circ S$。</li><li>传递：$(R \circ S)(R \circ S) = R(S \circ R)S = R(R \circ S)S ⊆ R \circ S$。<br>故 $R \circ S$ 是等价关系。</li></ul></li></ol><hr><p><strong>五、 函数证明</strong></p><p><strong>证明：</strong></p><ol><li><p>若 $f$ 可逆，设逆函数为$g$，显然$g$是$f$的右逆，若$\exists g’$也是$f$的右逆，则                                                                                        $g’=(g\circ f)\circ g’ = g \circ (f \circ g’) = g$。故右逆唯一</p></li><li><p>若 $f$ 存在唯一右逆 $g$ ($f \circ g = I_B$)。</p><ul><li><p>由存在右逆知 $f$ 是满射。</p></li><li><p>若 $f$ 不是单射，则存在 $x_1 \neq x_2$ 使得 $f(x_1)=f(x_2)=y_0$。而$g(y_0)$只能有一个值，不妨$g(y_0)≠x_2$。构造函数$g’:B \rightarrow A$：</p><p>$g’(y) = \begin{cases} g(y), &amp; y≠y_0 \newline x_2, &amp; y=y_0 \end{cases}$</p></li><li><p>显然，$g’$也为$f$的右逆，且与$g$不同。故与$f$有唯一右逆矛盾。故$f$为单射</p></li><li><p>综上，$f$ 双射，故可逆。</p></li></ul></li></ol><hr><p><strong>六、 等势证明</strong></p><p><strong>证明：</strong></p><p>构造 $f: [2,3] \to [0,1]$：$f(x) = \begin{cases} \frac{1}{2}, &amp; x=2 \newline \frac{1}{3}, &amp; x=3  \newline \frac{1}{i+2}, &amp; x=2+\frac{1}{i} \newline x-2, &amp; else \end{cases}$，显然为双射。</p><hr><p><strong>七、 图的连通分量</strong></p><ul><li><strong>强连通分量：</strong> $G[\{v_1,v_2,v_3\}],G[\{v_4\}],G[\{v_5,v_6\}],G[\{v_7\}],G[\{v_8\}],G[\{v_9\}],G[\{v_{10}\}]$</li><li><strong>单向连通分量：</strong> $G[\{v_1,v_2,v_3,v_4,v_5,v_6,v_7,v_8\}],G[\{v_1,v_2,v_3,v_4,v_5,v_6,v_7,v_9\}],G[\{v_{10}\}]$</li><li><strong>弱连通分量：</strong> $G[\{v_1,v_2,v_3,v_4,v_5,v_6,v_7,v_8,v_9\}],G[\{v_{10}\}]$</li></ul><p>注意格式一定要写成$G[\{\}]$的形式！不能只写一个点集！</p><hr><p><strong>八、 哈密顿路径证明</strong></p><p><strong>证明：</strong><br>对顶点数 $n$ 归纳。$n=1,2$ 显然成立。<br>假设 $n=k$ 成立，路径为 $P = v_1 \to \dots \to v_k$。<br>加入点 $u$。</p><ul><li>若 $u \to v_1$，则 $u \to P$。</li><li>若 $v_k \to u$，则 $P \to u$。</li><li>否则，必存在 $v_i \to u$ 且 $u \to v_{i+1}$（因为从指向 $u$ 变成了被 $u$ 指向，中间必有翻转），插在中间即可。<br>证毕。</li></ul><hr><p><strong>九、 最优叶加权二叉树</strong></p><p>答案：$517$</p>]]></content>
    
    
    <categories>
      
      <category>往年题</category>
      
      <category>往年题解答</category>
      
    </categories>
    
    
    <tags>
      
      <tag>往年题</tag>
      
      <tag>往年题解答</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-2026计算机组成原理期末试卷参考解答</title>
    <link href="/posts/2025-2026%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7%E5%8F%82%E8%80%83%E8%A7%A3%E7%AD%94/"/>
    <url>/posts/2025-2026%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7%E5%8F%82%E8%80%83%E8%A7%A3%E7%AD%94/</url>
    
    <content type="html"><![CDATA[<h1 id="2025-2026计算机组成原理期末试卷参考解答"><a href="#2025-2026计算机组成原理期末试卷参考解答" class="headerlink" title="2025-2026计算机组成原理期末试卷参考解答"></a>2025-2026计算机组成原理期末试卷参考解答</h1><h2 id="一、单项选择题（每题-2-分，共-20-分）"><a href="#一、单项选择题（每题-2-分，共-20-分）" class="headerlink" title="一、单项选择题（每题 2 分，共 20 分）"></a>一、单项选择题（每题 2 分，共 20 分）</h2><ol><li><strong>B</strong><ul><li><strong>解析</strong>：32位补码整数的表示范围是 $[-2^{31}, 2^{31}-1]$。最小值是 $-2^{31}$。</li></ul></li><li><strong>B</strong><ul><li><strong>解析</strong>：时序逻辑电路的状态存储通常由触发器（Flip-flop）实现，D触发器是最常用的状态存储单元。</li></ul></li><li><strong>C</strong><ul><li><strong>解析</strong>：目标存储器 $64\text{K} \times 16$ 位。<ul><li>字数扩展（行）：$64\text{K} / 16\text{K} = 4$ 倍。</li><li>位数扩展（列）：$16 / 4 = 4$ 倍。</li><li>总芯片数：$4 \times 4 = 16$ 片。</li></ul></li></ul></li><li><strong>A</strong><ul><li><strong>解析</strong>：MIPS 指令 <code>lw $s1, 4($s0)</code> 意为 Load Word，将基址寄存器 <code>$s0</code> 的值加上偏移量 <code>4</code> 作为内存地址，取出该地址处的一个字（32位），存入目标寄存器 <code>$s1</code>。</li></ul></li><li><strong>B</strong><ul><li><strong>解析</strong>：代码分析：<ul><li>初始化 <code>$t0=0</code> (索引), <code>$t1=0</code> (累加和)。</li><li>循环条件 <code>slti $t2, $t0, 10</code>，即当 <code>$t0 &lt; 10</code> 时继续。</li><li><code>sll $t3, $t0, 2</code> 将索引乘4（字节偏移）。</li><li><code>add $t3, $t3, $a0</code> 计算数组元素地址。</li><li><code>lw</code> 取数，<code>add</code> 累加。</li><li>综上，该程序计算数组 A 中下标 0 到 9（前10个）元素的和。</li></ul></li></ul></li><li><strong>D</strong><ul><li><strong>解析</strong>：流水线技术通过重叠指令的执行过程，在同一时刻让不同指令处于不同的执行阶段，从而显著提高了指令的吞吐率（单位时间内完成的指令数），但由于流水线寄存器的延迟，单条指令的执行时间（延迟）通常不会减少，反而略有增加。</li></ul></li><li><strong>C</strong><ul><li><strong>解析</strong>：<ul><li>写直通（Write-through）：同时写入 Cache 和主存。</li><li>回写法（Write-back）：只写入 Cache，被替换时才写回主存。</li><li>题干描述符合写直通。</li></ul></li></ul></li><li><strong>B</strong><ul><li><strong>解析</strong>：<ul><li>TLB Miss，但页表命中：需要访问主存查找页表（1次访存）。</li><li>拿到物理地址后访问 Cache，Cache Hit：直接从 Cache 读取数据，不需要访问主存（0次访存）。</li><li>总计访存次数：1次。</li></ul></li></ul></li><li><strong>B</strong><ul><li><strong>解析</strong>：TLB 缺失但页表命中属于“软缺失”。硬件或操作系统会查找内存中的页表，找到对应的物理页框号，将其填入 TLB，然后重新执行该指令。这不属于缺页异常（Page Fault，即页面不在内存中）。</li></ul></li><li><strong>A</strong><ul><li><strong>解析</strong>：<ul><li>A正确：缺页异常是程序执行过程中访问了未分配物理页的地址触发的，属于内中断（异常）。</li><li>B错误：算术溢出属于内中断（异常），非外部中断。</li><li>C错误：I/O 请求属于外部中断。</li><li>D错误：系统调用属于一种特殊的异常（陷入/Trap）。</li></ul></li></ul></li></ol><hr><h2 id="二、逻辑与性能计算（共-15-分）"><a href="#二、逻辑与性能计算（共-15-分）" class="headerlink" title="二、逻辑与性能计算（共 15 分）"></a>二、逻辑与性能计算（共 15 分）</h2><h3 id="1-逻辑化简（5分）"><a href="#1-逻辑化简（5分）" class="headerlink" title="1. 逻辑化简（5分）"></a>1. 逻辑化简（5分）</h3><p>不记得具体题</p><h3 id="2-组合逻辑设计（5分）"><a href="#2-组合逻辑设计（5分）" class="headerlink" title="2. 组合逻辑设计（5分）"></a>2. 组合逻辑设计（5分）</h3><p><strong>目标函数</strong>：$F = \overline{A}~\overline{C} + BC + A\overline{B}$</p><p><strong>分析</strong>：<br>将 $F$ 整理为关于 $A, B$ 的最小项形式：</p><ul><li>当 $A=0, B=0$：$F = 1 \cdot \overline{C} + 0 + 0 = \overline{C}$</li><li>当 $A=0, B=1$ 时，代入原式：$F = 1\cdot\overline{C} + 1\cdot C + 0 = \overline{C} + C = 1$。</li><li>当 $A=1, B=0$ ($S_1S_0=10$)：$F = 0 + 0 + 1\cdot 1 = 1$。</li><li>当 $A=1, B=1$ ($S_1S_0=11$)：$F = 0 + 1\cdot C + 0 = C$。</li></ul><p><strong>连线设计</strong>：</p><ul><li><strong>使能端</strong>：$\overline{EN}$ 接地$GND$（有效）。</li><li><strong>数据输入端</strong>：<ul><li>$D_0$ (对应 00)：接 $\overline{C}$ （将 $C$ 接非门输入，非门输出接 $D_0$）。</li><li>$D_1$ (对应 01)：接高电平 $1$ ($VCC$)。</li><li>$D_2$ (对应 10)：接高电平 $1$ ($VCC$)。</li><li>$D_3$ (对应 11)：接 $C$。</li></ul></li></ul><h3 id="3-性能分析（5分）"><a href="#3-性能分析（5分）" class="headerlink" title="3. 性能分析（5分）"></a>3. 性能分析（5分）</h3><p><strong>（1）计算 CPI 和 MIPS</strong></p><ul><li><p><strong>优化前</strong>：</p><ul><li>$CPI_{old} = 0.4 \times 1 + 0.15 \times 2 + 0.35 \times 2 + 0.1 \times 2 = 0.4 + 0.3 + 0.7 + 0.2 = 1.6$</li><li>$MIPS_{old} = \frac{f}{CPI} = \frac{500}{1.6} = 312.5$</li></ul></li><li><p><strong>优化后</strong>：</p><ul><li>假设原总指令数为 $N$。</li><li>A类指令变为 $0.5 \times 0.4N = 0.2N$。其他指令不变，共 $0.6N$。</li><li>新总指令数 $N_{new} = 0.2N + 0.6N = 0.8N$。</li><li>新比例：<ul><li>A: $0.2N / 0.8N = 0.25$</li><li>B+C+D: $0.6N / 0.8N = 0.75$ (且 CPI 均为 2)</li></ul></li><li>$CPI_{new} = 0.25 \times 1 + 0.75 \times 2 = 0.25 + 1.5 = 1.75$</li><li>$MIPS_{new} = \frac{500}{1.75} \approx 285.7$</li></ul></li></ul><p><strong>（2）性能是否有提升？</strong></p><ul><li><strong>分析</strong>：性能取决于程序的总执行时间 $T = \text{Instruction Count} \times CPI \times \text{Cycle Time}$。</li><li>$T_{old} = N \times 1.6 \times \frac{1}{f}$</li><li>$T_{new} = (0.8N) \times 1.75 \times \frac{1}{f} = 1.4N \times \frac{1}{f}$</li><li>因为 $1.4 &lt; 1.6$，即 $T_{new} &lt; T_{old}$，所以<strong>性能有提升</strong>。</li><li><strong>加速比</strong>：$Speedup = \frac{T_{old}}{T_{new}} = \frac{1.6}{1.4} = \frac{8}{7} \approx 1.14$。</li></ul><hr><h3 id="三、有限状态机设计（10-分）"><a href="#三、有限状态机设计（10-分）" class="headerlink" title="三、有限状态机设计（10 分）"></a>三、有限状态机设计（10 分）</h3><p><strong>1. 状态机类型</strong><br>输出不仅取决于当前状态（当前序列历史），还取决于当前的输入信号。因此，这是一个 <strong>Mealy 型</strong> 状态机。</p><p><strong>2. 状态定义</strong><br>目标序列为 <strong>1101</strong>（检测重叠）。</p><ul><li><strong>S0 (00)</strong>: 初始状态 / 空序列</li><li><strong>S1 (01)</strong>: 已检测到 <strong>1</strong></li><li><strong>S2 (10)</strong>: 已检测到 <strong>11</strong></li><li><strong>S3 (11)</strong>: 已检测到 <strong>110</strong></li></ul><p><strong>3. 状态转换图</strong></p><p>略</p><p><strong>4. 状态转换表</strong></p><p>设当前状态为 $S_1S_0$，输入为 $A$，次态为 $S_1’S_0’$，输出为 $Q$。</p><div class="table-container"><table><thead><tr><th style="text-align:center">当前状态 ($S_1S_0$)</th><th style="text-align:center">输入 ($A$)</th><th style="text-align:center">次态 ($S_1’S_0’$)</th><th style="text-align:center">输出 ($Q$)</th></tr></thead><tbody><tr><td style="text-align:center"><strong>00</strong></td><td style="text-align:center">0</td><td style="text-align:center"><strong>00</strong></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>00</strong></td><td style="text-align:center">1</td><td style="text-align:center"><strong>01</strong></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>01</strong></td><td style="text-align:center">0</td><td style="text-align:center"><strong>00</strong></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>01</strong></td><td style="text-align:center">1</td><td style="text-align:center"><strong>10</strong></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>10</strong></td><td style="text-align:center">0</td><td style="text-align:center"><strong>11</strong></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>10</strong></td><td style="text-align:center">1</td><td style="text-align:center"><strong>10</strong></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>11</strong></td><td style="text-align:center">0</td><td style="text-align:center"><strong>00</strong></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>11</strong></td><td style="text-align:center">1</td><td style="text-align:center"><strong>01</strong></td><td style="text-align:center"><strong>1</strong></td></tr></tbody></table></div><p><strong>5. 逻辑表达式</strong></p><p>根据真值表画卡诺图或直接提取逻辑（使用与或式表达）：</p><ul><li><p><strong>次态高位 $S_1’$</strong>：</p><script type="math/tex; mode=display">S_1' = \overline{S_1}S_0 A + S_1\overline{S_0}~\overline{A} + S_1\overline{S_0} A</script><p><strong><script type="math/tex">= \overline{S_1}S_0 A + S_1\overline{S_0}</script></strong></p></li><li><p><strong>次态低位 $S_0’$</strong>：<br>为1的情况有：(00, 1)$\to$01，(10, 0)$\to$11，(11, 1)$\to$01。<br><strong><script type="math/tex">S_0' = \overline{S_1}~\overline{S_0} A + S_1\overline{S_0}~\overline{A} + S_1S_0 A</script></strong></p></li><li><p><strong>输出 $Q$</strong>：<br>仅在状态为11且输入为1时输出。<br><strong><script type="math/tex">Q = S_1 S_0 A</script></strong></p></li></ul><hr><h2 id="四、MIPS-汇编程序设计（10-分）"><a href="#四、MIPS-汇编程序设计（10-分）" class="headerlink" title="四、MIPS 汇编程序设计（10 分）"></a>四、MIPS 汇编程序设计（10 分）</h2><p><strong>补全代码如下</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs assembly">li $s0, 0         # 初始化计数器 count = 0<br>    li $t0, 0         # 初始化循环变量 i = 0<br><br>Loop:<br>    # 1. 循环条件检查：如果 i &gt;= N，跳转到 End<br>    bge $t0, $a1, End <br>    <br>    # 2. 计算偏移量：$t1 = i * 4 (左移2位)<br>    sll $t1, $t0 , 2    <br>        <br>    # 3. 计算地址：$t1 = 偏移量($t1) + 基地址($a0)<br>    add $t1, $t1 , $a0  <br>    <br>    # 4. 加载数据：从内存取出 A[i] 存入 $t2<br>    lw  $t2 , 0($t1)    <br>    <br>    # 5. 判断大小：如果 $t2 &lt; 0，则 $t3 = 1；否则 $t3 = 0<br>    slt $t3, $t2 , $zero<br>    <br>    # 6. 分支跳转：如果 $t3 == 0 (即 A[i] &gt;= 0)，跳转到 Next<br>    beq $t3, $zero , Next <br>    <br>    # 7. 计数累加：count++<br>    addi $s0, $s0, 1   <br>    <br>Next:<br>    # 8. 循环步进：i++<br>    addi $t0 , $t0 , 1   <br>    <br>    # 9. 继续循环<br>    j Loop<br><br>End:<br>    # 程序结束<br></code></pre></td></tr></table></figure><p><strong>整理后的标准答案</strong>：</p><ol><li><code>$t0</code></li><li><code>$t1</code> </li><li><code>$t2</code></li><li><code>$t2</code></li><li><code>$zero</code></li><li><code>$zero</code> </li><li><code>$t0</code></li><li><code>$t0</code></li><li><code>j</code></li><li><code>Loop</code></li></ol><hr><h2 id="五、存储系统扩展（10-分）"><a href="#五、存储系统扩展（10-分）" class="headerlink" title="五、存储系统扩展（10 分）"></a>五、存储系统扩展（10 分）</h2><ol><li><strong>地址线</strong>：<ul><li>DRAM 芯片 $16\text{K} \times 8$。地址空间 $16\text{K} = 2^{14}$，共 14 根地址线。</li><li>行列地址位数相等，故行、列选择线各为 <strong>256条</strong>。</li></ul></li><li><strong>刷新计数器</strong>：<ul><li>DRAM 按行刷新，行数为 $2^7 = 128$ 行。</li><li>刷新地址计数器需要 <strong>7 位</strong>。</li></ul></li><li><strong>刷新周期</strong>：<ul><li>刷新周期 = 最大刷新时间 =$4\text{ms}$。</li></ul></li><li><strong>片选与译码</strong>：<ul><li><strong>片选信号</strong>：总地址 16位 (64KB)。单芯片容量 16KB ($2^{14}$)。</li><li>用于片选的高位地址线为 <strong>A15, A14</strong> (共2位)。</li><li><strong>译码器</strong>：选用 <strong>2-4 译码器</strong>。<ul><li>00 -&gt; ROM (0-16K)</li><li>01 -&gt; DRAM1 (16-32K)</li><li>10 -&gt; DRAM2 (32-48K)</li><li>11 -&gt; DRAM3 (48-64K)</li></ul></li><li><strong>故障分析</strong>：若 A14, A15 误接恒定高电平 (11)，则译码器始终输出 “11” 对应的片选信号。</li><li>结果：只有 <strong>1 个 DRAM 芯片</strong> (对应高地址区的那个) 始终被选中工作。ROM 和其他 DRAM 无法被访问。</li></ul></li></ol><hr><h2 id="六、Cache-性能分析（15-分）"><a href="#六、Cache-性能分析（15-分）" class="headerlink" title="六、Cache 性能分析（15 分）"></a>六、Cache 性能分析（15 分）</h2><ol><li><p><strong>结构分析</strong>：</p><ul><li><p>主存地址 1MB $\to$ 20位。</p></li><li><p>Cache 32KB，Block 16B，8路组相联。</p></li><li><p>组数 Set = $32\text{KB} / (16\text{B} \times 8) = 2048 / 8 = 256$ 组。</p></li><li><p><strong>地址格式</strong>：</p><p>标记 (Tag): $20 - 8 - 4 = 8$ 位+组索引 (Index): $8$ 位+块内偏移 (Offset)$4$ 位。</p></li></ul></li></ol><ol><li><p><strong>总容量</strong>：</p><ul><li>Cache 行数 = $256 \times 8 = 2048$ 行。</li><li>每行位数 = Valid(1) + Dirty(1) + Tag(8) + Data(16*8=128) = 138 位。</li><li><em>(题目说“一组含8位修改位”，即每行1位修改位)</em></li><li>总容量 = $2048 \times 138 = \mathbf{282,624}$ 位 (Bits)。</li></ul></li><li><p><strong>命中率计算</strong>：</p><ul><li>$t_a \le 19\text{ns}$</li><li>$t_a = h \times t_c + (1-h) \times t_m$</li><li>$19 \ge 10h + 100(1-h)$</li><li>$19 \ge 100 - 90h$</li><li>$90h \ge 81 \implies h \ge 0.9$</li><li>命中率至少应为 <strong>90%</strong>。</li></ul></li><li><p><strong>Cache 缺失次数</strong>：</p><ul><li>数组大小：$64 \times 4\text{B} = 256\text{B}$。</li><li>块大小：16B。数组占 $256/16 = 16$ 个完整块容量。</li><li><strong>(1) 起始 84AB0H</strong>：<ul><li>地址结尾为 0H (0000)，刚好在块边界开始。</li><li>数组完整覆盖 16 个 Cache 块。</li><li>顺序访问，每块第一次访问 Miss，后续 Hit。</li><li>Miss 次数 = <strong>16 次</strong>。</li></ul></li><li><strong>(2) 起始 84AB8H</strong>：<ul><li>地址结尾 8H (1000)，从块的中间开始（偏移量8）。</li><li>数组跨越的块数：<ul><li>第1个块：包含 A[0], A[1] (8B)。</li><li>中间 15 个块：包含 $15 \times 4 = 60$ 个整数。</li><li>最后1个块：包含剩余的 A[62], A[63]。</li></ul></li><li>总共涉及 $1 + 15 + 1 = 17$ 个内存块。</li><li>Miss 次数 = <strong>17 次</strong>。</li></ul></li></ul></li></ol><hr><h2 id="七、虚拟存储器（10-分）"><a href="#七、虚拟存储器（10-分）" class="headerlink" title="七、虚拟存储器（10 分）"></a>七、虚拟存储器（10 分）</h2><ol><li><p><strong>逻辑地址与虚页</strong>：</p><ul><li>虚拟空间 4GB ($2^{32}$)。</li><li>逻辑地址为 <strong>32位</strong>。</li><li>页大小 4KB ($2^{12}$)。</li><li>虚页总数 = $4\text{GB} / 4\text{KB} = 2^{20} = \mathbf{1,048,576}$ 页 (1M页)。</li></ul></li><li><p><strong>TLB 结构</strong>：</p><p>虚地址中<strong>高20位</strong>（即第31位到第12位）是虚页号。</p><p>TLB中使用虚页号的<strong>高16位</strong>作为标记位（Tag）。</p><ol><li><strong>物理页号（PPN）：</strong><br>物理空间 1GB ($2^{30}$)，页大小 4KB ($2^{12}$)。<br>物理页号位数 $= 30 - 12 = 18$ 位。</li><li><strong>标记位（Tag）：</strong> 计算得出为 16 位</li><li><strong>控制位：</strong> 题目给出 1位有效位，1位脏位，共 2 位。</li></ol><p>单表项总位数 $= \text{PPN} + \text{Tag} + \text{控制位} = 18 + 16 + 2 = 36$ 位。</p><p>TLB总容量 $= \text{表项数} \times \text{单表项位数} = 32 \times 36 = 1152$ 位。</p></li><li><p><strong>磁盘计算</strong>：</p><ul><li>平均寻道：5 ms。</li><li>平均旋转延迟：$6000\text{rpm} \to 100\text{r/s} \to 10\text{ms/r}$。平均延迟 = $10 / 2 = 5\text{ms}$。</li><li><strong>平均访问时间</strong> = $5 + 5 = \mathbf{10\text{ms}}$。</li><li><strong>总容量</strong>：<ul><li>8 盘片 (假设 16 面)。</li><li>218 柱面。</li><li>每道 12 扇区 - 2 保留 = 10 有效扇区。</li><li>扇区 512B。</li><li>容量 = $16 \times 218 \times 10 \times 512B = 17440KB$。</li></ul></li></ul></li><li><p><strong>平均有效访问时间 (EAT)</strong>：</p><ul><li>$t_{hit} = 20\text{ns}$ (TLB/Cache 并行或包含)。</li><li>$t_{mem} = 90\text{ns}$。</li><li><strong>TLB Miss (1%)</strong>: 需访问页表 (1次内存) $\to$ 90ns。</li><li><strong>Cache Miss (2%)</strong>: 需读取数据 (1次内存) $\to$ 90ns。</li><li>EAT = 基本时间 + TLB缺失惩罚 + Cache缺失惩罚</li><li>$T = 20 + (0.01 \times 90) + (0.02 \times 90)$</li><li>$T = 20 + 0.9 + 1.8 = \mathbf{22.7\text{ns}}$。</li></ul></li></ol><hr><h2 id="八、CPU-流水线冒险（10-分）"><a href="#八、CPU-流水线冒险（10-分）" class="headerlink" title="八、CPU 流水线冒险（10 分）"></a>八、CPU 流水线冒险（10 分）</h2><ol><li><p><strong>相关性分析</strong>：</p><ul><li>I1 (<code>add $s2...</code>) 写 <code>$s2</code>。<ul><li>I2 读 <code>$s2</code> (RAW)。</li><li>I3 读 <code>$s2</code> (RAW)。</li><li>I4 读 <code>$s2</code> (RAW)。</li></ul></li><li>I2 (<code>lw $s1...</code>) 写 <code>$s1</code>。<ul><li>I3 读 <code>$s1</code> (RAW)。</li></ul></li><li>I3 (<code>sub $s4...</code>) 写 <code>$s4</code>。<ul><li>I4 读 <code>$s4</code> (RAW)。</li></ul></li><li>I4 (<code>or $s7...</code>) 写 <code>$s7</code>。<ul><li>I5 读 <code>$s7</code> (RAW)。</li></ul></li><li><strong>表示</strong>：$s2: \{I1,I2,I3,I4\}, s1: \{I1,I2,I3\}, s4: \{I3,I4\}, s7: \{I4, I5\}$。</li></ul></li><li><p><strong>冲突与解决 (仅有 W-&gt;E 转发)</strong>：</p><p>不能</p><ul><li><strong>累计插入</strong>：I1-I2 间1个, I2-I3间1个, I3-I4间1个, I4-I5间1个。总共需要插入 <strong>4 个 NOP</strong>。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>往年题</category>
      
      <category>往年题解答</category>
      
    </categories>
    
    
    <tags>
      
      <tag>往年题</tag>
      
      <tag>往年题解答</tag>
      
      <tag>CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-2026概率与数理模型期末试卷</title>
    <link href="/posts/2025-2026%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E6%A8%A1%E5%9E%8B%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7/"/>
    <url>/posts/2025-2026%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E6%A8%A1%E5%9E%8B%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="2025-2026概率与数理模型期末试卷"><a href="#2025-2026概率与数理模型期末试卷" class="headerlink" title="2025-2026概率与数理模型期末试卷"></a>2025-2026概率与数理模型期末试卷</h1><p>$Sorted~by~2406zhp$</p><h3 id="一、选择题（本大题共10小题，每题2分，共20分）"><a href="#一、选择题（本大题共10小题，每题2分，共20分）" class="headerlink" title="一、选择题（本大题共10小题，每题2分，共20分）"></a>一、选择题（本大题共10小题，每题2分，共20分）</h3><ol><li><p>设 $A, B$ 为两个随机事件，且 $B \subset A$，则下列说法正确的是（ ）。<br>A. $P(A \cup B) = P(B)$<br>B. $P(AB) = P(B)$<br>C. $P(A|B) = P(A)$<br>D. $A$ 与 $B$ 互为对立事件</p></li><li><p>设连续型随机变量 $X$ 的概率密度函数为 $f(x)$，分布函数为 $F(x)$。若随机变量 $X$ 与 $-X$ 同分布，则下列结论正确的是（ ）。<br>A. $F(x) = F(-x)$<br>B. $F(x) = -F(-x)$<br>C. $f(x) = f(-x)$<br>D. $f(x) = -f(-x)$</p></li><li><p>设随机变量 $X$ 的概率密度函数为 $f(x) = \begin{cases} Ae^{-x}, &amp; x &gt; \lambda \ 0, &amp; x \le \lambda \end{cases}$。关于概率 $P(\lambda &lt; X &lt; \lambda + a)$ （其中 $a&gt;0$），下列说法正确的是（ ）。<br>A. 与 $\lambda$ 无关，随 $a$ 增大而增大<br>B. 与 $a$ 无关，随 $\lambda$ 增大而减小<br>C. 与 $\lambda$ 无关，随 $a$ 增大而减小<br>D. 与 $a$ 无关，随 $\lambda$ 增大而增大</p></li><li><p>对随机变量 $X, Y$，等式 $D(X+Y) = D(X) + D(Y)$ 成立是 $X, Y$（ ）。<br>A. 相互独立的充分非必要条件<br>B. 相互独立的必要非充分条件<br>C. 不相关的充分必要条件<br>D. 不相关的必要非充分条件</p></li><li><p>设随机变量 $X \sim P(\lambda)$ （泊松分布），已知 $E[(X-1)(X-2)] = 1$，则 $\lambda =$ （ ）。<br>A. 0<br>B. 1<br>C. 2<br>D. -1</p></li><li><p>设 $X_1, X_2$ 是来自总体 $N(\mu, \sigma^2)$ 的简单随机样本（即 $X_1, X_2$ 独立同分布，且 $E(X_i)=\mu, D(X_i)=\sigma^2$），下列关于 $\mu$ 的估计量中，最合适（即无偏且最有效）的是：</p><ul><li>A. $\hat{\mu}_1 = \frac{2}{3}X_1 + \frac{1}{3}X_2$</li><li>B. $\hat{\mu}_2 = \frac{3}{2}X_1 - \frac{1}{2}X_2$ </li><li>C. $\hat{\mu}_3 = \frac{1}{4}X_1 + \frac{3}{4}X_2$ </li><li>D. $\hat{\mu}_4 = \frac{1}{4}X_1 + \frac{1}{4}X_2$</li></ul></li><li><p>进行单因素方差分析，研究三种药物的疗效，每种药物选取5名志愿者。给定显著性水平 $\alpha=0.05$，查表如下。若医院甲计算得到统计量 $F=4$，医院乙得到 $F=6$，则下列结论正确的是（ ）。</p><script type="math/tex; mode=display">\begin{array}{lll}F_{0.05}(2, 12) = 3.89 & F_{0.05}(2, 5) = 5.79 & F_{0.05}(2, 15) = 3.68 \\F_{0.05}(3, 12) = 3.49 & F_{0.05}(3, 5) = 5.41 & F_{0.05}(3, 15) = 3.29\end{array}</script><p>A. 甲、乙均认为药物疗效有显著差异<br>B. 甲、乙均认为药物疗效无显著差异<br>C. 甲认为有显著差异，乙认为无显著差异<br>D. 乙认为有显著差异，甲认为无显著差异</p></li></ol><p>（别问为什么只有七道，有三道我不记得了qwq）</p><hr><h3 id="二、填空题（本大题共4小题，每题3分，共12分）"><a href="#二、填空题（本大题共4小题，每题3分，共12分）" class="headerlink" title="二、填空题（本大题共4小题，每题3分，共12分）"></a>二、填空题（本大题共4小题，每题3分，共12分）</h3><ol><li><p>已知 $P(A) = \alpha$，$P(B) = 0.3$，$P(A \cup B) = 0.7$。若事件 $A$ 与 $B$ 相互独立，则 $\alpha = $ ________。</p></li><li><p>设随机变量 $X$ 的概率密度函数为 $f(x) = \begin{cases} ax+b, &amp; 0 &lt; x &lt; 1 \ 0, &amp; \text{其他} \end{cases}$。若 $P(X \ge 1/2) = 5/8$，则常数 $a = $ ________, $b = $ ________。</p></li><li><p>在 $n$ 次独立重复试验中，事件 $A$ 发生的次数为 $m$，每次试验中事件 $A$ 发生的概率为 $p$。对$\forall \epsilon &gt; 0$，则伯努利大数定律的数学表达式为：____________________。</p></li><li><p>某批元件寿命服从正态分布 $N(\mu, \sigma^2)$，$\sigma$ 已知。现抽取样本容量 $n=25$，检验假设 $H_0: \mu = \mu_0 = 10 \text{ms}$ 在显著性水平 $\alpha$ 下，该假设检验的<strong>接受域</strong>为 ____________________。</p></li></ol><hr><h3 id="三、简答题（本大题共3小题，每题6分，共18分）"><a href="#三、简答题（本大题共3小题，每题6分，共18分）" class="headerlink" title="三、简答题（本大题共3小题，每题6分，共18分）"></a>三、简答题（本大题共3小题，每题6分，共18分）</h3><ol><li><p>一个盒子里最初装有$3$个红球和$2$个白球。现进行如下抽样实验：每次从盒中随机取出一球，观察颜色后放回，并额外再往盒中加入$2$个与取出球颜色相同的球。求前两次均取出红球，且第三、四次均取出白球的概率。</p></li><li><p>某超算中心共有$2000$台超级计算机，假设每台计算机开机时耗电量为 $a$ 千瓦。每台计算机是否开机运行相互独立，开机概率均为 $p=0.6$。试问供电系统至少应提供多少千瓦的电力，才能保证以不低于 99.99% 的概率满足所有开机计算机的用电需求？<br>（提示：设标准正态分布随机变量 $Z$ 满足 $P(Z \le 3.72) = 0.9999$）</p></li><li><p>设总体 $X \sim B(n, p)$，$X_1, X_2, \dots, X_k$ 是来自该总体的简单随机样本。若统计量 $\hat{\theta} = c \sum_{i=1}^k X_i(X_i - 1)$ 是参数 $p^2$ 的无偏估计量，求常数 $c$ 的值。</p></li></ol><hr><h3 id="四、计算题（本大题共5小题，每题8分，共40分）"><a href="#四、计算题（本大题共5小题，每题8分，共40分）" class="headerlink" title="四、计算题（本大题共5小题，每题8分，共40分）"></a>四、计算题（本大题共5小题，每题8分，共40分）</h3><ol><li><p>已知随机变量 $X, Y$ 满足 $P(X \ge 0) = 4/7$， $P(Y \ge 0) = 4/7$， $P(X \ge 0, Y \ge 0) = 3/7$。求 $P(\max{X, Y} \ge 0)$。</p></li><li><p>设二维随机变量 $(X, Y)$ 在由直线 $y=x, y=0, x=2$ 所围成的区域 $D$ 内服从均匀分布。<br>(1) 写出 $(X, Y)$ 的联合概率密度函数 $f(x, y)$；<br>(2) 求 $X$ 的边缘概率密度函数 $f_X(x)$。</p></li><li><p>设随机变量 $X$ 的概率密度函数为 $f(x) = Ae^{-|x|}, -\infty &lt; x &lt; +\infty$。<br>(1) 求常数 $A$；<br>(2) 求 $X$ 的分布函数 $F(x)$；<br>(3) 求概率 $P(-1 &lt; X &lt; 1)$。</p></li><li><p>某工厂生产的产品次品率为 $p=0.02$。现随机抽取 $n$ 个产品进行检验。试利用中心极限定理计算，至少需要抽取多少个产品，才能使样本中的次品率低于 $4%$ 的概率不小于$ 0.977$？<br>（已知标准正态分布函数值 $\Phi(2) = 0.977$）</p></li><li><p>设总体 $X$ 服从参数为 $\theta (\theta &gt; 0)$ 的指数分布，其概率密度函数为 $f(x;\theta) = \theta e^{-\theta x}, x&gt;0$。$X_1, X_2$ 是来自该总体的两个简单随机样本，设 $Z = \max{X_1, X_2}$。<br>(1) 求 $Z$ 的分布函数 $F_Z(z)$ 与概率密度函数 $f_Z(z)$；<br>(2) 基于 $\bar{Z}$ ，利用矩估计法求参数 $\theta$ 的估计量 $\hat{\theta}$。</p></li></ol><hr><h3 id="五、应用题（本大题共10分）"><a href="#五、应用题（本大题共10分）" class="headerlink" title="五、应用题（本大题共10分）"></a>五、应用题（本大题共10分）</h3><p>随着大语言模型（LLM）的普及，区分人类撰写的文本与AI生成的文本已成为重要课题。现有一段待检测文本：“曲曲折折的荷塘上面，弥望的是田田的叶子……”</p><ol><li><p>请使用我们学过的知识（包括但不限于文法模型，深度学习模型），谈谈如何分析这段文字，其中用到哪些概率统计知识</p></li><li><p>假设定义随机变量 $Y \in {0, 1}$，其中 $Y=0$ 表示“人类生成”，$Y=1$ 表示“AI生成”。请设计一个基于概率统计的检测方案,使用我们学过的知识（包括但不限于关联规则，贝叶斯分类，因果性分析等），并说明其中用到哪些概率统计知识</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>往年题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>往年题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-2026离散数学2期末试卷</title>
    <link href="/posts/2025-2026%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7/"/>
    <url>/posts/2025-2026%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="2025-2026-离散数学2期末试卷"><a href="#2025-2026-离散数学2期末试卷" class="headerlink" title="2025-2026 离散数学2期末试卷"></a>2025-2026 离散数学2期末试卷</h1><p>$Sorted~by~2406zhp$</p><p><strong>一、</strong>判断题</p><p>1.对于集合A,B,C,D，若$A \subset C$，$B \subset D$，则$A\cup B \subset C \cup D$                            （  ）</p><p><strong>二、</strong><br>设集合$A=\{1,2,3,4\}$，$A$上有两个二元关系R1和R2：</p><p>$$R1 = \{(1,2), (2,3), (3,1), (1,4), (2,4), (3,4)\} ~~<br>R2 = \{(1,1), (2,2), (3,3), (4,4), (1,2), (2,1), (2,3), (3,4), (4,1)\}$$</p><p>请分别判断这两个关系具有自反、反自反、对称、反对称、传递这五种性质中的哪些，并计算它们的复合关系$R1∘R2$ 以及 $R2$ 的传递闭包$t(R2)$。</p><p><strong>三、</strong><br>集合$A=\{1,2,3,4,6,9,12,18\}$，定义整除关系为$A$上的偏序关系，</p><p>（1）请画出该偏序集对应的哈斯图，</p><p>（2）对子集$S=\{2,3,4,6,9\}$求出其最大元、最小元、极大元、极小元。</p><p>（3）对子集$S=\{3,6,9,18\}$，求出其上界、下界、最小上界以及最大下界</p><p><strong>四、</strong><br>设$R$和$S$是集合$A$上的两个等价关系，请证明：复合关系$R∘S$是等价关系当且仅当$R∘S$=$S∘R$。</p><p><strong>五、</strong><br>设函数$f: A→B$，且集合A至少有两个元素，请证明：函数$f$是可逆的当且仅当$f$存在唯一的右逆函数。</p><p><strong>六、</strong><br>证明：闭区间$[2,3]$与开区间$(0,1)$是等势的。</p><p><strong>七、</strong><br>对于如下的有向图，请分别指出该图中的强连通分量、单向连通分量以及弱连通分量。</p><img src="/posts/2025-2026%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7/ed32f22767c4a8f3ba153e0a4a3254fb.jpg" class="" title="ed32f22767c4a8f3ba153e0a4a3254fb"><p><strong>八、</strong><br>设有一个有向图，其对应的基础图是完全无向图，请证明该有向图中必然存在一条哈密顿路径。</p><p><strong>九、</strong><br>给定一组叶节点的权值$\{1, 3, 5, 7, 10, 15, 20, 30, 40, 55\}$，请构造一棵最优叶加权二叉树，并计算该树的带权路径长度。</p>]]></content>
    
    
    <categories>
      
      <category>离散2</category>
      
      <category>往年题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>往年题</tag>
      
      <tag>离散2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-2026计组期末试卷</title>
    <link href="/posts/2025-2026%E8%AE%A1%E7%BB%84%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7/"/>
    <url>/posts/2025-2026%E8%AE%A1%E7%BB%84%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="2025-2026-计算机组成原理-期末试卷"><a href="#2025-2026-计算机组成原理-期末试卷" class="headerlink" title="2025-2026 计算机组成原理 期末试卷"></a>2025-2026 计算机组成原理 期末试卷</h1><p>$Sorted ~by ~2406-zhp$</p><h2 id="一、单项选择题（每题-2-分，共-20-分）"><a href="#一、单项选择题（每题-2-分，共-20-分）" class="headerlink" title="一、单项选择题（每题 2 分，共 20 分）"></a>一、单项选择题（每题 2 分，共 20 分）</h2><ol><li><p><strong>若机器字长为 32 位，采用补码表示整数，则其能表示的最小值为：</strong><br>A. $0$<br>B. $-2^{31}$<br>C. $-2^{32}$<br>D. $-(2^{31}-1)$</p></li><li><p><strong>在设计时序逻辑电路时，若要存储电路的当前状态以便在下一时钟周期参与运算，最适合的硬件方案是：</strong><br>A. 仅使用组合逻辑电路<br>B. 使用一组 D 触发器<br>C. 使用只读存储器<br>D. 使用多路选择器</p></li><li><p><strong>某主存系统由 $16\text{K} \times 4$ 位的 DRAM 芯片组成，若要组成 $64\text{K} \times 16$ 位的存储器，则总共需要该 DRAM 芯片的数量是：</strong><br>A. 4 片<br>B. 8 片<br>C. 16 片<br>D. 32 片</p></li><li><p><strong>MIPS 指令 <code>lw $s1, 4($s0)</code> 的功能描述正确的是：</strong><br>A. 将内存地址 <code>$s0+4</code> 处的一个<strong>字</strong>加载到寄存器 <code>$s1</code> 中<br>B. 将内存地址 <code>$s1+4</code> 处的一个<strong>字</strong>加载到寄存器 <code>$s0</code> 中<br>C. 将内存地址 <code>$s0+4</code> 处的一个<strong>字节</strong>加载到寄存器 <code>$s1</code> 中<br>D. 将寄存器 <code>$s1</code> 的值存入内存地址 <code>$s0+4</code> 处</p></li><li><p><strong>分析下列 MIPS 代码片段，其功能是：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">la $a0,A<br>li $t0, 0          <br>li $t1, 0          <br>Loop:<br>    slti $t2, $t0, 10<br>    beq $t2, $zero, Exit<br>    sll $t3, $t0, 2<br>    add $t3, $t3, $a0<br>    lw  $t4, 0($t3)<br>    add $t1, $t1, $t4<br>    addi $t0, $t0, 1<br>    j Loop<br>Exit: ...<br></code></pre></td></tr></table></figure><p>A. 计算数组 A 中最小 10 个数的和<br>B. 计算数组 A 中前 10 个数的和<br>C. 计算数组 A 中最后 10 个数的和<br>D. 取出数组 A 的第 10 个数</p></li><li><p><strong>流水线 CPU（Pipelined）与单周期 CPU 相比，其主要优势在于：</strong><br>A. 缩短了单条指令的执行时间<br>B. 减少指令的执行周期<br>C. 避免了所有数据冒险<br>D. 增加指令的并行程度，提高了指令的吞吐率</p></li><li><p><strong>在 Cache 写操作中，若 CPU 写命中，同时修改 Cache 和主存中对应内容的策略称为：</strong><br>A. 回写法<br>B. 写分配<br>C. 写直通<br>D. 不写分配</p></li><li><p><strong>在虚实地址转换及访存过程中，关于 TLB 和 Cache 的访问次数，下列说法正确的是：</strong><br>A. TLB Hit, Cache Hit：访存 0 次<br>B. TLB Miss, Page Table Hit, Cache Hit：访存 1 次<br>C. TLB Miss, Page Table Hit, Cache Miss：访存 2 次<br>D. TLB Hit, Cache Miss：访存 2 次</p></li><li><p><strong>当发生 TLB 缺失（TLB Miss）但页表命中（Page Table Hit）时，系统的标准操作是：</strong><br>A. 抛出缺页异常（Page Fault），由操作系统从磁盘调页<br>B. 硬件或操作系统根据页表基址读取页表项，将物理页号填入 TLB，并重新执行指令<br>C. 抛出段错误（Segmentation Fault），终止程序运行<br>D. 直接绕过 TLB，仅使用 Cache 进行后续访问</p></li><li><p><strong>关于异常（Exception）和中断（Interrupt），下列说法正确的是：</strong><br>A. 缺页（Page Fault）属于一种异常（内中断），通常由程序执行触发<br>B. 算术溢出属于外部中断<br>C. I/O 设备请求属于异常<br>D. 系统调用（System Call）不属于异常处理机制</p></li></ol><hr><h2 id="二、逻辑与性能计算（共-15-分）"><a href="#二、逻辑与性能计算（共-15-分）" class="headerlink" title="二、逻辑与性能计算（共 15 分）"></a>二、逻辑与性能计算（共 15 分）</h2><ol><li><p><strong>逻辑化简（5分）</strong><br>已知逻辑函数 $F(A,B,C,D)$。<br>化简为最简与或表达式。<br><em>(提示：化简结果形式应类似于 $B + \overline{A}~\overline{C}$)</em></p></li><li><p><strong>组合逻辑设计（5分）</strong><br>请利用一个 <strong>4 选 1 多路选择器（MUX）</strong> 和一个连接了C的<strong>非门（NOT）</strong> 实现下列逻辑函数：</p><script type="math/tex; mode=display">F = \overline{A}~\overline{C} + BC + A\overline{B}</script><p>给出$D0-D3,\overline{EN}$的连线</p></li><li><p><strong>性能分析（5分）</strong></p><p>某计算机主频为 <strong>500 MHz</strong>，其指令集包含 A、B、C、D 四类指令。已知 A 类指令的 CPI 为 1，B、C、D 类指令的 CPI 均为 2。在某基准程序中，A 类指令占总指令数的 40%，B、C、D 类指令分别占总指令数的15%，35%，10%。<br>现对编译器进行优化，<strong>将程序中 A 类指令的数量减少了一半</strong>（其他指令数量不变）。</p><p><strong>请回答以下问题：</strong></p><p>（1）计算优化前和优化后的 CPI 以及 MIPS（MIPS保留一位小数）。</p><p>（2）优化后该程序的执行性能是否有提升？如果没有，请给出理由；若有，请计算加速比。</p></li></ol><hr><h2 id="三、有限状态机设计（10-分）"><a href="#三、有限状态机设计（10-分）" class="headerlink" title="三、有限状态机设计（10 分）"></a>三、有限状态机设计（10 分）</h2><p> 设计一个有限状态机实现1101的有重叠检测，当拍输入为“1”且当前序列为“110”时认为已检测到并立即输出。</p><ol><li>这是什么型状态机？</li><li>画出状态转换图。</li><li>列出状态转换表并写出次态的逻辑表达式。（S1S0为当前状态，A为输入，S1’S0’为下一状态，Q为输出）</li></ol><hr><h2 id="四、MIPS-汇编程序设计（10-分）"><a href="#四、MIPS-汇编程序设计（10-分）" class="headerlink" title="四、MIPS 汇编程序设计（10 分）"></a>四、MIPS 汇编程序设计（10 分）</h2><p><strong>题目：</strong> 给定一个整型数组 <code>A</code>，其首地址保存在寄存器 <code>$a0</code> 中，数组长度 $N$ 保存在 <code>$a1</code> 中。请补全下列 MIPS 代码，功能为：<strong>统计数组 A 中所有“小于 0”的元素的个数</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs assembly">li $s0, 0         <br>    li $t0, 0          <br><br>Loop:<br>    bge $t0, $a1, End <br>    <br>    sll $t1, ____ , 2    <br>        <br>    add $t1, ____ , $a0  <br>    <br>    lw  ____ , 0($t1)    <br>    <br>    slt $t3, ____ , ____<br>    <br>    beq $t3, ____ , Next <br>    <br>    addi $s0, $s0, 1   <br>    <br>Next:<br>    addi ____ , ____ , 1   <br>    <br>    __ ______<br><br>End:<br></code></pre></td></tr></table></figure><hr><h2 id="五、存储系统扩展（10-分）"><a href="#五、存储系统扩展（10-分）" class="headerlink" title="五、存储系统扩展（10 分）"></a>五、存储系统扩展（10 分）</h2><p>某计算机主存地址空间大小为 64KB，按字节编址（数据总线 8 位）。系统程序区占低地址区，<code>0-0x3FFF</code>：占用 16KB 空间，由 ROM 芯片组成。剩余高地址区为用户数据区。</p><p>现有芯片规格如下：<strong>ROM 芯片</strong>：$4K \times 4$ 位，<strong>DRAM 芯片</strong>：$16K \times 8$ 位</p><ol><li>上述 DRAM 芯片行、列地址位数相等，求该 DRAM 芯片的行选择线和列选择线各为多少条？</li><li>DRAM 采用按行刷新，刷新地址计数器应设为多少位？</li><li>若 DRAM 采用分布式（异步）刷新方式，刷新间隔（最大刷新周期）为 4ms，求刷新周期。</li><li>设计主存时，哪几位用于生成片选信号？选用什么译码器最佳？若地址线 A14、A15 误接为恒定高电平，则系统中实际有几个 DRAM 芯片和几个 ROM 芯片可以正常被访问？</li></ol><hr><h2 id="六、Cache-性能分析（15-分）"><a href="#六、Cache-性能分析（15-分）" class="headerlink" title="六、Cache 性能分析（15 分）"></a>六、Cache 性能分析（15 分）</h2><p>某计算机主存地址空间大小为 1MB，Cache采用<strong>8路组相联</strong>映射方式，Cache大小32KB，数据块大小16B。每块包含一位有效位，一组含8位修改位。</p><p>请回答下列问题：</p><ol><li>求Cache包含的组数以及主存地址格式（名称+位数），指出Tag位数。</li><li>求出Cache的总存储容量。</li><li>假设CPU执行某段程序时，Cache命中时的访问时间为 $t_c = 10\text{ns}$，Cache缺失时处理包含访问主存的累计时间为 $t_m = 100\text{ns}$。若要求平均访问时间 $t_a$ 不超过 $19\text{ns}$，则Cache的命中率至少应为多少？</li><li>现有数组定义 <code>int A[64]</code>（假设 <code>int</code> 占4字节），程序顺序读取该数组。<ul><li>(1) 若数组 A 的起始地址为 <strong>84AB0H</strong>，Cache缺失次数是多少？</li><li>(2) 若数组 A 的起始地址为 <strong>84AB8H</strong>，Cache缺失次数是多少？</li></ul></li></ol><hr><h2 id="七、虚拟存储器（10-分）"><a href="#七、虚拟存储器（10-分）" class="headerlink" title="七、虚拟存储器（10 分）"></a>七、虚拟存储器（10 分）</h2><p>某计算机系统采用虚拟页式存储管理，物理空间$1$GB，虚拟空间4GB，页大小为 <strong>4KB</strong>。TLB（快表）采用 <strong>2路组相联</strong> 映射方式， TLB 拥有 32 个表项。每个表项包含1位有效位、1位脏位。</p><p>1.逻辑地址为多少位，一共有多少虚页？</p><p>2.虚地址中哪几位是虚页号，虚页号TLB中哪几位为标记位(Tag)，计算TLB总容量。</p><p>3.系统使用一个磁盘子系统，磁盘转速为6000 rpm，有8个盘，218个柱面，每个磁道12个扇区，其中有两个扇区保留不存储信息，扇区大小512B，平均寻道时间为5 ms，求磁盘平均访问时间和总存储容量。</p><p>4.假设系统中TLB和Cache的缺失率分别为1%和2%，且二者命中情况相互独立，CPU访问TLB和Cache命中时的用时为20ns，主存访问时间为90ns。若TLB不命中，系统需要访问一次主存查询页表；若Cache不命中，系统需要访问一次主存读取数据。请根据上述参数计算该存储系统的平均有效访问时间。</p><hr><h2 id="八、CPU-流水线冒险（10-分）"><a href="#八、CPU-流水线冒险（10-分）" class="headerlink" title="八、CPU 流水线冒险（10 分）"></a>八、CPU 流水线冒险（10 分）</h2><p><strong>题目：</strong> 考虑标准的 MIPS 五级流水线（IF, ID, EX, MEM, WB）。仅有W级到E级的转发通路，其他旁路与寄存器内部转发均无，现有如下指令序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">I1: add $s2, $s1, $s3<br>I2: lw $s1, 0($s2)<br>I3: sub $s4, $s2, $s1<br>I4: or $s7, $s2, $s4<br>I5: sw $s7, 0($s6)<br></code></pre></td></tr></table></figure><ol><li><p>指出所有读写与写读相关。表示为：表示为：<u>$s8，{I2，I3，I5}</u></p></li><li><p>指出所有存在的数据冲突。在不新增旁路的情况下，能否解决冲突？如果不能，请给出如何插入及累计需要插入几个nop。（推荐画时空图说明）</p></li></ol><blockquote><p>致谢：感谢我的同学zlx以及我的三位舍友在题面回忆上做出的帮助和贡献</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计组理论</category>
      
      <category>往年题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>往年题</tag>
      
      <tag>CO</tag>
      
      <tag>计组理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组总结-写在最后的话</title>
    <link href="/posts/%E8%AE%A1%E7%BB%84%E6%80%BB%E7%BB%93-%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E%E7%9A%84%E8%AF%9D/"/>
    <url>/posts/%E8%AE%A1%E7%BB%84%E6%80%BB%E7%BB%93-%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E%E7%9A%84%E8%AF%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="计组总结-写在最后的话"><a href="#计组总结-写在最后的话" class="headerlink" title="计组总结-写在最后的话"></a>计组总结-写在最后的话</h1><p><strong>题记：“通往完美流水线的道路，是由冒险和异常中断铺就的。”</strong></p><p>屏幕上那个绿色的“Accepted”亮起的时候，我以为我会跳起来，或者至少长舒一口气，靠在椅背上庆祝新生。</p><p>但现实是，我愣住了。周围是键盘敲击的嘈杂声，依然有同学在眉头紧锁地盯着波形图，而我坐在那里，盯着那个通过字样，耳边仿佛有一种巨大的轰鸣后的寂静。没有狂喜，没有哪怕一丝意料之中的激动，取而代之的，是一种漫无边际的茫然，和一种“结束了？”的不真实感。</p><p>至此，P7完结，我的计算机组成原理实验，也就是传说中让无数六系学子脱发、失眠的“计组”，终于画上了句号。</p><p>那个曾让我夜不能寐的MIPS架构，那些在梦里都在连线的多路选择器，此刻静静地躺在我的D盘深处，成了一堆冰冷的Verilog代码。</p><p><strong>回首向来萧瑟处，也无风雨也无晴。但在真的走到这一步之前，我曾以为那是过不去的火焰山。</strong></p><p>第一次P7上机前的那周，那时候的我，像个即将奔赴战场的狂热信徒。为了确保万无一失，我没日没夜地调试评测机环境，六七位同学把代码发给我，我的电脑每晚不关机，风扇呼啸着，挂着跑完一万个测试点。</p><p>看着那一排排绿色的“Accepted”，我心里有一种笃定的骄傲：这么高强度的对拍，这么极端的测试，我怎么可能过不了强测？那种急切想要第一批通过的欲望，像火一样烧着我。哪怕拿不满分我也要交，我要的是速度，是解脱。</p><p><strong>然而命运是最好的编剧，它最爱在主角自以为是的时候，给出一记响亮的耳光。</strong></p><p>万丛绿中一点红。那个刺眼的错误提示，像一根针扎破了所有的虚荣。我从未如此静心地Debug，甚至可以说是虔诚地在一行行代码中像朝圣一样寻找漏洞。我想不通，真的想不通，明明跑过了一万个点，为什么会折在这里？</p><p>回到宿舍，我不久便找出了那处bug。它甚至不是什么高深的逻辑问题，它就静静地躺在我一开始就检查过的地方，嘲笑着我的粗心。</p><p>那一刻，我哑然失笑，笑得比哭还难看。</p><p>和我对拍的同学们几乎全部顺利通过了。机房里此起彼伏地响起：“恭喜你，同学，通关计组实验，请问你对计组实验有什么建议吗？”</p><p>每一声“恭喜”，都像是在击溃我心理防线的最后一块砖瓦。</p><p>那天风很大，天很冷，但我的心更冷。作为一名 6 系的学生，我们太熟悉那种“掉队”的恐惧了。周围的人都在奔跑，绩点、综测、保研，每一项指标都像悬在头顶的达摩克利斯之剑。一次失误，仿佛就会被这个卷到极致的系统甩出离心机。我裹紧了衣服，看着路灯下被风卷起的落叶，第一次感到如此深的无力感。</p><p><strong>这就是6系，这就是北航。</strong> 这里的空气里似乎都弥漫着焦虑的味道。太卷了，真的太卷了。每一个不眠之夜，每一次看到别人满分而自己出错的落差，每一次面对Deadline时的绝望，都像一把把刻刀，在我的大二生活上雕刻出深深的痕迹。</p><p>也就是在那段时间之内，北京下了这一冬的第一场雪。</p><p>雪下了一天一夜，很大。作为一个在南方长大的孩子，我曾在无数个湿冷的冬天里翘首以盼北国的千里冰封，万里雪飘。可当它真的来了，正好卡在六级考试、P7 挂科的那个周末。我站在雪地里，周围是兴奋的人群，我却感到一种不知所措的疏离。</p><p>小时候那种想要在雪地里打滚的心气，似乎在无数个熬夜写代码的夜晚里被消磨殆尽了。最后，我只是蹲下来，用手指在厚厚的积雪上，画了一个简易版的流水线 CPU，也算留下一点痕迹。</p><p>那一刻我觉得自己很可笑，又很浪漫。这或许就是工科生的宿命，我们将青春熔铸进这些逻辑门和寄存器里，哪怕是在最感性的雪地里，留下的也是理性的痕迹。雪会化，痕迹会消失，就像那第一次挂掉的 P7，终将被时间掩埋。</p><p>挂科让我错过了一次机会，却也给了我一种奇怪的“平和”。第二次上机前，我不再急切。我告诉自己，大不了手动挂P，大不了三战，人生不会因为一段 Verilog 代码而崩塌。</p><p>幸运的是，我没有机会去验证那种艰难的抉择。我做完了五道题，提交，通过。</p><p>那一刻的茫然，或许是因为我已经预支了所有的情绪。</p><p>又是那个熟悉的场景，又是那句熟悉的台词。</p><p>“恭喜你，同学，通关计组实验，请问你对计组实验有什么建议吗？”</p><p>这一次，这句话是对我说的。</p><p>我曾无数次在脑海中预演过这个场景。我仿佛有无数话要说。但在那一刻，一切都烟消云散了。支支吾吾挤出一句：“没什么建议”。那一瞬间，我的大脑仿佛在跳出计组上机的指令时被清空了延迟槽。</p><p>原来，当你真正跨过那道坎的时候，所有的苦难都变成了沉默的背景板。</p><p>走出机房，抬头看天，北航的夜空依旧深邃。</p><p>有时候我很迷茫。人们都说计算机专业前途光明，可我看不见那束光在哪里；人们说道路曲折，可我觉得这曲折似乎永远走不完。</p><p>六系真的很卷，卷到让人感到窒息。多少个不眠之夜，多少次看着大佬代码产生的落差感，多少次觉得自己前途无<br>“亮”。我们就像流水线上的指令，被时钟信号推着向前，一刻也不能停歇。</p><p>每次上机前的紧张与生理性胃痛，像是一种周期性的病痛；OO、OS还在前方虎视眈眈；保研的竞争遥遥无期，一切仿佛都经不起一点失误。</p><p>不过我想，我之所以感到痛苦，是因为我不甘平庸吧。我之所以感到迷茫，是因为我在试图走出一条属于自己的路吧。这也正是我们选择计算机、选择北航的意义吧。</p><p>P7结束了，计组上机完结了。这或许只是漫长人生中一个微不足道的节点，但对于现在的我来说，它是一座刚刚翻越的雪山。再见了，Logisim；再见了，Verilog；再见了，我的计组实验。</p><p>我们在一次次冒险中学会处理冲突，在一次次暂停中学会等待时机，在一次次转发中学会将过往的经验传递给未来。</p><p>虽然错过了初雪，但我终于造出了属于我的CPU。<br>虽然未来依旧迷雾重重，但我已不再畏惧代码中的红点。</p><p>我不希望过上一眼望得到头的人生。既然选择了这条充满冒险与异常的流水线，那就让时钟信号继续跳动吧。</p><p>Run 1000ns.</p><p>Run 1000days.</p>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P7课下-支持中断异常的MIPS微系统</title>
    <link href="/posts/P7%E8%AF%BE%E4%B8%8B-%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E7%9A%84MIPS%E5%BE%AE%E7%B3%BB%E7%BB%9F/"/>
    <url>/posts/P7%E8%AF%BE%E4%B8%8B-%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E7%9A%84MIPS%E5%BE%AE%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="CO设计文档—支持中断异常的MIPS微系统"><a href="#CO设计文档—支持中断异常的MIPS微系统" class="headerlink" title="CO设计文档—支持中断异常的MIPS微系统"></a>CO设计文档—支持中断异常的MIPS微系统</h1><p>恭喜你，挑战者，你迎来了最终boss，你是否已经热泪盈眶百感交集？</p><h2 id="总体设计概述"><a href="#总体设计概述" class="headerlink" title="总体设计概述"></a>总体设计概述</h2><p>要求实现的指令集为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add, sub, and, or, slt, sltu, lui<br>addi, andi, ori<br>lb, lh, lw, sb, sh, sw<br>mult, multu, div, divu, mfhi, mflo, mthi, mtlo<br>beq, bne, jal, jr<br>mfc0, mtc0, eret, syscall<br></code></pre></td></tr></table></figure><p><strong>支持延迟槽</strong>。</p><p>整体结构如下图所示：</p><img src="/posts/P7%E8%AF%BE%E4%B8%8B-%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E7%9A%84MIPS%E5%BE%AE%E7%B3%BB%E7%BB%9F/P7-cpu%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="P7-CPU示意图"><img src="/posts/P7%E8%AF%BE%E4%B8%8B-%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E7%9A%84MIPS%E5%BE%AE%E7%B3%BB%E7%BB%9F/b78cca4748ec39cb585be2a285fc4964.png" class="" title="b78cca4748ec39cb585be2a285fc4964"><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li>对于元件的文件命名，均为<code>元件英文简称</code>，例如<code>GRF.v</code>，<code>ALU.v</code>等，实例化时命名为<code>_小写英文名</code>，例如<code>_alu</code>，<code>_grf</code>等</li><li>对于流水线寄存器文件命名为<code>两边的流水线层级reg</code>，例如<code>FDreg.v</code>，<code>DEreg.v</code>，实例化时命名相同。</li><li>每一级的控制信号和临时的<code>wire</code>均以本级的名称开头，如<code>E_ALUOp</code>，<code>M_DMwr</code>等</li><li>在流水线中参与流水的信息遵从以下约定（以D级为例）<ul><li><code>PC</code>和<code>Instr</code>命名以流水线层级开头，如<code>D_PC</code>，<code>D_Instr</code></li><li>寄存器地址分别为<code>D_A1</code>，<code>D_A3</code>，读出数据为<code>D_RD1</code>，<code>D_RD2</code></li><li>转发后得到的修复的寄存器数据（直接读取也视为一种转发）记作<code>D_fixedRD1</code>，<code>D_fixedRD2</code></li><li>即将写入的寄存器地址为<code>W_A3</code>，即将写入的数据记作<code>W_WD</code>，选择信号为<code>W_WDSel</code></li></ul></li></ul><p>下面将按照流水线层级逐一分析各个单元CPU</p><p>CPU部分与P6相比添加了重要模块CP0协处理器，其余的端口定义和转发、阻塞规则与P6相同，详见附带的P6设计文档，在此处不再赘述</p><p>考虑到宏观PC的处理，我把CP0协处理器放置在了M级</p><h4 id="CP0协处理器"><a href="#CP0协处理器" class="headerlink" title="CP0协处理器"></a>CP0协处理器</h4><p><strong>介绍</strong></p><p>协处理器 0，包含 4 个 32 位寄存器，用于支持中断和异常。</p><p><strong>端口定义</strong></p><div class="table-container"><table><thead><tr><th>端口</th><th>输入/输出</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td><code>addr</code></td><td>I</td><td>5</td><td>指定 4 个寄存器中的一个，作为写入的目标寄存器</td></tr><tr><td><code>WD</code></td><td>I</td><td>32</td><td>写入寄存器的数据信号</td></tr><tr><td><code>VPC</code></td><td>I</td><td>32</td><td>目前传入的下一个 EPC 值</td></tr><tr><td><code>ExcCode</code></td><td>I</td><td>5</td><td>目前传入的下一个 ExcCode 值</td></tr><tr><td><code>BD</code></td><td>I</td><td>32</td><td>目前传入的下一个 BD 值</td></tr><tr><td><code>HWInt</code></td><td>I</td><td>6</td><td>外部硬件中断信号</td></tr><tr><td><code>WE</code></td><td>I</td><td>1</td><td>写使能信号，高电平有效</td></tr><tr><td><code>EXLclr</code></td><td>I</td><td>1</td><td>传入 eret 指令时将 SR 的 EXL 位置 0 ，高电平有效</td></tr><tr><td><code>clk</code></td><td>I</td><td>1</td><td>时钟信号</td></tr><tr><td><code>reset</code></td><td>I</td><td>1</td><td>同步复位信号</td></tr><tr><td><code>Req</code></td><td>O</td><td>1</td><td>输出当前的中断请求</td></tr><tr><td><code>EPCout</code></td><td>O</td><td>32</td><td>输出当前 EPC 寄存器中的值</td></tr><tr><td><code>data</code></td><td>O</td><td>32</td><td>输出 A 指定的寄存器中的数据</td></tr></tbody></table></div><p><strong>功能定义</strong></p><div class="table-container"><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>同步复位</td><td>当时钟上升沿到来且同步复位信号有效时，将所有寄存器的值设置为 0x00000000。</td></tr><tr><td>2</td><td>读数据</td><td>读出 <code>addr</code> 地址对应寄存器中存储的数据到 data；当 WE 有效时会将 WD 的值会实时反馈到对应的data，当 ERET 有效时会将 EXL 置 0，即内部转发。</td></tr><tr><td>3</td><td>写数据</td><td>当 WE 有效且时钟上升沿到来时，将 WD 的数据写入 <code>addr</code> 对应的寄存器中。</td></tr><tr><td>4</td><td>中断处理</td><td>根据各种传入信号和寄存器的值判断当前是否要进行中断，将结果输出到 <code>Req</code>。</td></tr></tbody></table></div><p>处理异常的流程如下图：</p><p>将异常码<code>ExcCode</code>、是否处于延迟槽中的判断信号<code>BD</code>和当前<code>PC</code>（如果时取指地址异常则传递错误的PC值）一直跟着流水线到达M级直至提交至CP0，由CP0综合判断分析是否响应该异常</p><p>如果需要响应该异常，则CP0输出Req信号置为1，此时FD、DE、DM、MW寄存器响应Req信号，清空<code>Instr</code>，将PC值设为0x4180，然后输入F级的NPC也被置为0x4180，下一条指令从0x4180开始执行</p><p>当外设和系统外部输入中断信号时，CP0同样也会确认是否响应该中断，然后把Req置为1，执行相同的操作</p><h3 id="F级-Fetch-取指令"><a href="#F级-Fetch-取指令" class="headerlink" title="F级(Fetch/取指令)"></a>F级(Fetch/取指令)</h3><ul><li>本级没有转发，阻塞时需要取消<code>PC</code>写使能</li><li>本级的输入有来自D级的<code>NPC</code>，本级的输出是<code>F_PC</code>和<code>F_Instr</code>，两者需要参与流水线流水</li></ul><h4 id="IFU（取指单元）"><a href="#IFU（取指单元）" class="headerlink" title="IFU（取指单元）"></a>IFU（取指单元）</h4><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>NPC[31:0]</td><td>输入</td><td>待写入PC的指令地址</td></tr><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>PC_en</td><td>输入</td><td>PC的写使能</td></tr><tr><td>PC[31:0]</td><td>输出</td><td>当前指令地址</td></tr><tr><td>Instr[31:0]</td><td>输出</td><td>32位的指令值</td></tr></tbody></table></div><p>然后与<code>mips_txt.v</code>交互获得当前指令</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog">PC _pc (<span class="hljs-variable">.clk</span>(clk),<br>  <span class="hljs-variable">.reset</span>(reset),<br>  <span class="hljs-variable">.PC_en</span>(PC_en),<br>  <span class="hljs-variable">.PC</span>(F_PC),<br>  <span class="hljs-variable">.NPC</span>(F_NPC)<br>  );<br><br><span class="hljs-keyword">assign</span> i_inst_addr = F_PC;<br><span class="hljs-keyword">assign</span> F_Instr = i_inst_rdata;<br></code></pre></td></tr></table></figure><h4 id="NPC（次地址计算单元）"><a href="#NPC（次地址计算单元）" class="headerlink" title="NPC（次地址计算单元）"></a>NPC（次地址计算单元）</h4><p>把<code>beq</code>是否执行的判断交给了D级的<code>CMP</code>，根据输入信号<code>zero</code>和控制信号<code>NPCop</code>判断是否跳转</p><p>其实<code>NPC</code>横跨了F级和D级两级，我们只输入<code>F_PC</code>即可，因为事实上<code>F_PC=D_PC+4</code>，<code>beq</code>转发的<code>D_PC+4+offset=F_PC+offset</code>。<code>F_PC+8</code>则用于流水<code>PC</code>值，后面<code>jal</code>转发的时候用</p><p>我们一路携带<code>PC+8</code>到各级，便于转发。</p><p>传入中断异常信号Req，当 <code>Req</code> 为 1 时，将输出的 <code>NPC</code> 值设置为内核地址 <code>0x00004180</code>即可。</p><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>F_PC[31:0]</td><td>输入</td><td>32位输入当前F级地址</td></tr><tr><td>zero</td><td>输入</td><td>指示b类型指令是否跳转</td></tr><tr><td>NPCop[2:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>grf[31:0]</td><td>输入</td><td><strong>处理完转发后</strong><code>$rs</code>寄存器保存的32位地址</td></tr><tr><td>NPC[31:0]</td><td>输出</td><td>32位输出次地址</td></tr><tr><td>Req</td><td>输入</td><td>中断异常</td></tr></tbody></table></div><h5 id="控制信号说明"><a href="#控制信号说明" class="headerlink" title="控制信号说明"></a>控制信号说明</h5><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>$000$</td><td><code>NPC=PC+4</code></td></tr><tr><td>$001$</td><td>执行<code>beq</code>等b类指令</td></tr><tr><td>$110$</td><td>执行<code>j</code>，<code>jal</code>指令</td></tr><tr><td>$111$</td><td>执行<code>jalr</code>，<code>jr</code>指令</td></tr></tbody></table></div><h3 id="D级-Decode-译码"><a href="#D级-Decode-译码" class="headerlink" title="D级(Decode/译码)"></a>D级(Decode/译码)</h3><ul><li>本级需要处理来自E, M, W级的转发，转发信号为<code>EPCplus8</code>，<code>MPCplus8</code>，<code>M_ALUans</code>，<code>W_WD</code>，优先级按顺序排列，最低为原寄存器读出的值<code>D_RD1</code>，<code>D_RD2</code>。</li><li>本级的输入是来自F级的<code>PC</code>和<code>Instr</code>，输出是<code>D_fixedRD1</code>，<code>D_fixedRD2</code>，<code>D_ext32</code>，<code>D_PC</code>和<code>D_Instr</code>，还有输出到F级的<code>NPC</code>，<code>A3</code>和<code>PCplus8</code>记得一路带着。</li><li>本级元件较多，比较复杂</li></ul><h4 id="FD-REG（F-D级流水线寄存器）"><a href="#FD-REG（F-D级流水线寄存器）" class="headerlink" title="FD_REG（F/D级流水线寄存器）"></a>FD_REG（F/D级流水线寄存器）</h4><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>FD_clear</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>F_PC</td><td>输入</td><td>F级PC的指令地址</td></tr><tr><td>F_Instr[31:0]</td><td>输入</td><td>32位的指令值</td></tr><tr><td>FPCplus8</td><td>输入</td><td>F_PC+8</td></tr><tr><td>F_ExcCode</td><td>输入</td><td>F级指令异常</td></tr><tr><td>F_BD</td><td>输入</td><td>是否是延迟槽指令</td></tr><tr><td>Req</td><td>输入</td><td>是否有中断异常请求</td></tr><tr><td>D_PC</td><td>输出</td><td>D级PC的指令地址</td></tr><tr><td>D_Instr[31:0]</td><td>输出</td><td>32位的指令值</td></tr><tr><td>DPCplus8</td><td>输出</td><td><code>jal</code>指令要存入<code>$ra</code>的值</td></tr><tr><td>FD_ExcCode</td><td>输出</td><td>F流水至D级的异常码</td></tr><tr><td>D_BD</td><td>输出</td><td>是否是延迟槽指令</td></tr></tbody></table></div><h4 id="D-GRF（寄存器堆）"><a href="#D-GRF（寄存器堆）" class="headerlink" title="D_GRF（寄存器堆）"></a>D_GRF（寄存器堆）</h4><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A1[4:0]</td><td>输入</td><td>5位地址输入信号，将其储存的数据读出到RD1</td></tr><tr><td>A2[4:0]</td><td>输入</td><td>5位地址输入信号，将其储存的数据读出到RD2</td></tr><tr><td>A3[4:0]</td><td>输入</td><td>5位地址输入信号，将其作为写入数据的目标寄存器</td></tr><tr><td>RD1[31:0]</td><td>输出</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr><td>RD2[31:0]</td><td>输出</td><td>输出A2指定的寄存器中的32位数据</td></tr><tr><td>WD[31:0]</td><td>输入</td><td>32位数据输入信号</td></tr><tr><td>GRFwe</td><td>输入</td><td>写使能</td></tr><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>异步复位信号，将32个寄存器中的数据清零；1：复位；0：无效</td></tr></tbody></table></div><h5 id="控制信号说明-1"><a href="#控制信号说明-1" class="headerlink" title="控制信号说明"></a>控制信号说明</h5><p><strong><code>D_A3slt</code></strong></p><p>从<code>rt</code>字段，<code>rd</code>字段，$0x1f$中进行选择，与P4相同，但与P4不同的是，我们A3信号需要一直带着走到W级才写寄存器。寄存器所有与<strong>写入</strong>有关的端口都应连<strong>W级信号</strong>！包括<code>W_GRFwe</code>，<code>W_A3</code>，<code>W_WD</code>。P5采用分布式译码，<code>D_A3slt</code>在<code>D_ctrl</code>模块译出，<code>W_GRFwe</code>在W级译出，<code>W_A3</code>从D级选出<code>D_A3</code>后一路跟着流水，<code>W_WD</code>是在W级通过选择而得到的。</p><h4 id="D-EXT（位扩展）"><a href="#D-EXT（位扩展）" class="headerlink" title="D_EXT（位扩展）"></a>D_EXT（位扩展）</h4><p>将16位二进制数进行零扩展或符号扩展到32位</p><p><strong>控制信号说明</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>$0$</td><td>零扩展</td></tr><tr><td>$1$</td><td>符号扩展</td></tr></tbody></table></div><h4 id="D-CMP（比较器）"><a href="#D-CMP（比较器）" class="headerlink" title="D_CMP（比较器）"></a>D_CMP（比较器）</h4><p>把原来ALU中比较值是否相等的运算移到了CMP里面，去指导<code>beq</code>这一类型的指令是否跳转</p><p>P5控制信号只有<code>CMP_beq=0</code>，现在P6扩展一个<code>bne</code>指令。</p><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>rs[31:0]</td><td>输入</td><td><strong>处理完转发后</strong><code>$rs</code>寄存器的值</td></tr><tr><td>rt[31:0]</td><td>输入</td><td><strong>处理完转发后</strong><code>$rt</code>寄存器的值</td></tr><tr><td>CMPOp[2:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>zero</td><td>输出</td><td>指示是否跳转，输入<code>NPC</code></td></tr></tbody></table></div><p><strong>控制信号</strong></p><p><strong><code>CMPop</code></strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>$0$</td><td><code>beq</code></td></tr><tr><td>$1$</td><td><code>bne</code></td></tr></tbody></table></div><h3 id="E级-Execute-执行"><a href="#E级-Execute-执行" class="headerlink" title="E级(Execute/执行)"></a>E级(Execute/执行)</h3><h4 id="DE-REG（D-E级流水线寄存器）"><a href="#DE-REG（D-E级流水线寄存器）" class="headerlink" title="DE_REG（D/E级流水线寄存器）"></a>DE_REG（D/E级流水线寄存器）</h4><ul><li><p>输入<code>D_PC,D_Instr,D_ext32</code>，此外上一级修正后的<code>D_fixedRD1</code>和<code>D_fixedRD2</code>的值也要参与流水，，<strong>这是由于指令序列<code>sw, nop, add</code>的存在，<code>sw</code>在M级需要使用<code>$rt</code>的数据，但是在E级不会再进行转发（因为在D级已经转发过了），因此需要让正确的<code>$rt</code>值参与流水</strong></p></li><li><p>输出<code>E_PC,E_Instr,E_ext32,E_RD1,E_RD2</code>，<code>ALU</code>需要这些信息</p></li></ul><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>DE_clear</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>D_PC[31:0]</td><td>输入</td><td>D级PC的指令地址</td></tr><tr><td>D_Instr[31:0]</td><td>输入</td><td>32位的指令值</td></tr><tr><td>D_ext32[31:0]</td><td>输入</td><td>16位立即数经<code>EXT</code>扩展的结果</td></tr><tr><td>D_RD1[31:0]</td><td>输入</td><td>32位的寄存器数据</td></tr><tr><td>D_RD2[31:0]</td><td>输入</td><td>32位的寄存器数据</td></tr><tr><td>DPCplus8</td><td>输入</td><td>PC+8</td></tr><tr><td>D_ExcCode</td><td>输入</td><td>D级指令异常</td></tr><tr><td>D_BD</td><td>输入</td><td>是否是延迟槽指令</td></tr><tr><td>Req</td><td>输入</td><td>是否有中断异常请求</td></tr><tr><td>E_PC[31:0]</td><td>输出</td><td>E级PC的指令地址</td></tr><tr><td>E_Instr[31:0]</td><td>输出</td><td>32位的指令值</td></tr><tr><td>E_ext32[31:0]</td><td>输出</td><td>16位立即数经<code>EXT</code>扩展的结果</td></tr><tr><td>E_RD1[31:0]</td><td>输出</td><td>32位的寄存器数据</td></tr><tr><td>E_RD2[31:0]</td><td>输出</td><td>32位的寄存器数据</td></tr><tr><td>EPCplus8</td><td>输出</td><td>PC+8</td></tr><tr><td>DE_ExcCode</td><td>输出</td><td>D流水至E级的异常码</td></tr><tr><td>E_BD</td><td>输出</td><td>是否是延迟槽指令</td></tr></tbody></table></div><h4 id="E-ALU（算术逻辑单元）"><a href="#E-ALU（算术逻辑单元）" class="headerlink" title="E_ALU（算术逻辑单元）"></a>E_ALU（算术逻辑单元）</h4><ul><li>相比于P4，ALU变化不大，仅仅是去掉了$zero$输出，给了<code>CMP</code>模块。</li></ul><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>输入</td><td>32位输入运算数A</td></tr><tr><td>B[31:0]</td><td>输入</td><td>32位输入运算数B</td></tr><tr><td>ALUOp[4:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>C[31:0]</td><td>输出</td><td>32位输出运算结果</td></tr></tbody></table></div><p><strong>控制信号说明</strong></p><p><strong>1. ALUOp</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>$000$</td><td>执行加法运算</td></tr><tr><td>$001$</td><td>执行减法运算</td></tr><tr><td>$010$</td><td>执行逻辑与运算</td></tr><tr><td>$011$</td><td>执行逻辑或运算</td></tr><tr><td>$100$</td><td>执行<code>lui</code>指令</td></tr></tbody></table></div><p><strong>2. ALUASel</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>$0$</td><td>选修正后的<code>E_fixedRD1</code></td></tr><tr><td>$1$</td><td>保留</td></tr></tbody></table></div><p><strong>3. ALUBSel</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>$0$</td><td>选修正后的<code>E_fixedRD2</code></td></tr><tr><td>$1$</td><td>选择立即数进行运算</td></tr></tbody></table></div><h4 id="E-MDU（乘除槽）"><a href="#E-MDU（乘除槽）" class="headerlink" title="E_MDU（乘除槽）"></a>E_MDU（乘除槽）</h4><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>复位信号</td></tr><tr><td><code>MDUOp[2:0]</code></td><td>输入</td><td>控制信号</td></tr><tr><td><code>InputA[31:0]</code></td><td>输入</td><td>32位输入运算数A</td></tr><tr><td><code>InputB[31:0]</code></td><td>输入</td><td>32位输入运算数B</td></tr><tr><td>start</td><td>输入</td><td>开始运算的指示信号</td></tr><tr><td>busy</td><td>输出</td><td>是否处于运算过程中</td></tr><tr><td>HI[31:0]</td><td>输出</td><td>32位HI寄存器值结果</td></tr><tr><td>LO[31:0]</td><td>输出</td><td>32位LO寄存器值结果</td></tr></tbody></table></div><p><strong>控制信号说明</strong></p><p><strong>1. MDUOp</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>0</td><td>乘法运算</td></tr><tr><td>1</td><td>除法运算</td></tr><tr><td>2</td><td>无符号乘法运算</td></tr><tr><td>3</td><td>无符号除法运算</td></tr><tr><td>4</td><td><code>mfhi</code>指令</td></tr><tr><td>5</td><td><code>mflo</code>指令</td></tr><tr><td>6</td><td><code>mthi</code>指令，把D1的值赋给HI寄存器中</td></tr><tr><td>7</td><td><code>mtlo</code>指令，把D1的值赋给LO寄存器中</td></tr><tr><td>8</td><td>不是乘除法运算</td></tr></tbody></table></div><h3 id="M级-Memory-储存"><a href="#M级-Memory-储存" class="headerlink" title="M级(Memory/储存)"></a>M级(Memory/储存)</h3><ul><li>输入<code>E_PC,E_Instr</code>，此外上一级的<code>E_ALUAns</code>参与流水，即<code>E_ALUAns</code>需要参与流水，<strong>这是因为<code>ALUAns</code>是待写入或读取的内存地址</strong>，<strong>另外，上一级的修正后的rt值需要参与流水</strong>，因此还需要输入<code>E_fixedRD2</code>，<strong>这是因为<code>sw</code>指令会向内存中写入<code>$rt</code>的数据</strong></li><li>输出<code>M_PC,M_Instr,M_ALUAns,M_DMrd</code></li></ul><h4 id="EM-REG（E-M级流水线寄存器）"><a href="#EM-REG（E-M级流水线寄存器）" class="headerlink" title="EM_REG（E/M级流水线寄存器）"></a>EM_REG（E/M级流水线寄存器）</h4><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>EM_clear</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>E_PC[31:0]</td><td>输入</td><td>E级PC的指令地址</td></tr><tr><td>E_Instr[31:0]</td><td>输入</td><td>32位的指令值</td></tr><tr><td>E_fixedRD2[31:0]</td><td>输入</td><td>32位的寄存器数据</td></tr><tr><td>E_ALUAns[31:0]</td><td>输入</td><td>32位的ALU运算结果</td></tr><tr><td>EPCplus8</td><td>输入</td><td>PC+8</td></tr><tr><td>E_ExcCode</td><td>输入</td><td>E级指令异常</td></tr><tr><td>E_BD</td><td>输入</td><td>是否是延迟槽指令</td></tr><tr><td>Req</td><td>输入</td><td>是否有中断异常请求</td></tr><tr><td>M_PC[31:0]</td><td>输出</td><td>M级PC的指令地址</td></tr><tr><td>M_Instr[31:0]</td><td>输出</td><td>32位的指令值</td></tr><tr><td>M_ALUAns[31:0]</td><td>输出</td><td>32位的ALU运算结果</td></tr><tr><td>M_RD2[31:0]</td><td>输出</td><td>32位的寄存器数据</td></tr><tr><td>MPCplus8</td><td>输出</td><td>PC+8</td></tr><tr><td>EM_ExcCode</td><td>输出</td><td>E流水至M级的异常码</td></tr><tr><td>M_BD</td><td>输出</td><td>是否是延迟槽指令</td></tr></tbody></table></div><h4 id="M-DM（数据储存器）"><a href="#M-DM（数据储存器）" class="headerlink" title="M_DM（数据储存器）"></a>M_DM（数据储存器）</h4><ul><li><p><code>DM</code>已经不需要自行实现，调用<code>mips_txt.v</code>中的接口即可</p></li><li><p>利用BE模块处理待写入数据，使其支持按半字、字节、字储存</p></li><li>利用DE模块处理DM返回的数据，使其可以按照不同要求存入寄存器</li></ul><h5 id="M-BE"><a href="#M-BE" class="headerlink" title="M_BE"></a>M_BE</h5><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td><code>saveop[3:0]</code></td><td>输入</td><td>控制信号</td></tr><tr><td><code>addr[31:0]</code></td><td>输入</td><td>地址信息，用于处理半字、字节</td></tr><tr><td><code>data[31:0]</code></td><td>输入</td><td>读取的寄存器数据，待处理</td></tr><tr><td><code>DMwr[3:0]</code></td><td>输出</td><td>控制写入半字、字节的位置</td></tr><tr><td><code>fixed_data[31:0]</code></td><td>输出</td><td>待写入数据</td></tr></tbody></table></div><h5 id="M-DE"><a href="#M-DE" class="headerlink" title="M_DE"></a>M_DE</h5><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td><code>loadop[3:0]</code></td><td>输入</td><td>控制信号</td></tr><tr><td><code>addr[31:0]</code></td><td>输入</td><td>地址信息，用于处理半字、字节</td></tr><tr><td><code>data[31:0]</code></td><td>输入</td><td><code>mips_txt.v</code>返回的DM中的数据</td></tr><tr><td><code>fixed_data[31:0]</code></td><td>输出</td><td>处理之后的正确的读取数据</td></tr></tbody></table></div><h5 id="与接口进行交互"><a href="#与接口进行交互" class="headerlink" title="与接口进行交互"></a>与接口进行交互</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 与DM交互</span><br>BE _be (<span class="hljs-variable">.addr</span>(M_DMaddr),<br> <span class="hljs-variable">.data</span>(M_DM_WD), <br> <span class="hljs-variable">.saveop</span>(M_saveop), <br> <span class="hljs-variable">.DMwr</span>(M_DM_bytewr),<br>       <span class="hljs-variable">.fixed_data</span>(M_fixed_DM_WD));<br>DE _de  (<span class="hljs-variable">.addr</span>(M_DMaddr),<br><span class="hljs-variable">.data</span>(M_DMrd),<br><span class="hljs-variable">.loadop</span>(M_loadop),<br><span class="hljs-variable">.fixed_data</span>(M_fixedRD)<br>);<br><span class="hljs-keyword">assign</span> m_inst_addr = M_PC;<br><span class="hljs-keyword">assign</span> m_data_addr = M_ALUAns;<br><span class="hljs-keyword">assign</span> m_data_addr = M_DMaddr;<br><span class="hljs-keyword">assign</span> m_data_wdata = M_fixed_DM_WD;<br><span class="hljs-keyword">assign</span> m_data_byteen = M_DM_bytewr;<br><span class="hljs-keyword">assign</span> M_DMrd = m_data_rdata;<br><br><span class="hljs-comment">// 正确输出GRF读写信息</span><br><span class="hljs-keyword">assign</span> m_inst_addr = M_PC;<br><span class="hljs-keyword">assign</span> w_inst_addr = W_PC;<br><span class="hljs-keyword">assign</span> w_grf_we    = W_GRFwe;<br><span class="hljs-keyword">assign</span> w_grf_addr  = W_A3;<br><span class="hljs-keyword">assign</span> w_grf_wdata = W_WD;<br></code></pre></td></tr></table></figure><h3 id="W级-Write-回写"><a href="#W级-Write-回写" class="headerlink" title="W级(Write/回写)"></a>W级(Write/回写)</h3><ul><li>W级事实上与D级重合了，但是仍然需要处理向E,M级的转发</li></ul><h4 id="MW-REG（M-W级流水线寄存器）"><a href="#MW-REG（M-W级流水线寄存器）" class="headerlink" title="MW_REG（M/W级流水线寄存器）"></a>MW_REG（M/W级流水线寄存器）</h4><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>MW_clear</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>M_PC[31:0]</td><td>输入</td><td>M级PC的指令地址</td></tr><tr><td>M_Instr[31:0]</td><td>输入</td><td>32位的指令值</td></tr><tr><td>M_DMRD[31:0]</td><td>输入</td><td>从内存中读取的值</td></tr><tr><td>M_ALUAns[31:0]</td><td>输入</td><td>32位的ALU运算结果</td></tr><tr><td>MPCplus8</td><td>输入</td><td>PC+8</td></tr><tr><td>W_PC[31:0]</td><td>输出</td><td>W级PC的指令地址</td></tr><tr><td>W_Instr[31:0]</td><td>输出</td><td>32位的指令值</td></tr><tr><td>W_DMrd[31:0]</td><td>输出</td><td>从内存中读取的值</td></tr><tr><td>W_ALUAns[31:0]</td><td>输出</td><td>32位的ALU运算结果</td></tr><tr><td>WPCplus8</td><td>输出</td><td>PC+8</td></tr></tbody></table></div><h3 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h3><p>我采用分布式译码，每一级实例化一个控制器，对于所有<code>CTRL</code>均有：</p><div class="table-container"><table><thead><tr><th>指令</th><th>opcode</th><th>funct</th><th>NPCOp</th><th>WRA3Sel</th><th>WDSel</th><th>EXTOp</th><th>WE</th><th>ALUASel</th><th>ALUBSel</th><th>ALUOp</th><th>DMWr</th></tr></thead><tbody><tr><td><strong>add</strong></td><td>000000</td><td>100000</td><td>000</td><td>01</td><td>00</td><td>X</td><td>1</td><td>0</td><td>0</td><td>000</td><td>0</td></tr><tr><td><strong>sub</strong></td><td>000000</td><td>100010</td><td>000</td><td>01</td><td>00</td><td>X</td><td>1</td><td>0</td><td>0</td><td>001</td><td>0</td></tr><tr><td><strong>ori</strong></td><td>001101</td><td></td><td>000</td><td>00</td><td>00</td><td>0</td><td>1</td><td>0</td><td>1</td><td>011</td><td>0</td></tr><tr><td><strong>lw</strong></td><td>100011</td><td></td><td>000</td><td>00</td><td>01</td><td>1</td><td>1</td><td>0</td><td>1</td><td>000</td><td>0</td></tr><tr><td><strong>sw</strong></td><td>101011</td><td></td><td>000</td><td>00</td><td>01</td><td>1</td><td>0</td><td>0</td><td>1</td><td>000</td><td>1</td></tr><tr><td><strong>beq</strong></td><td>000100</td><td></td><td>001</td><td>X</td><td>X</td><td>1</td><td>0</td><td>0</td><td>0</td><td>001</td><td>0</td></tr><tr><td><strong>lui</strong></td><td>001111</td><td></td><td>000</td><td>00</td><td>00</td><td>X</td><td>1</td><td>0</td><td>1</td><td>100</td><td>0</td></tr><tr><td><strong>jal</strong></td><td>000011</td><td></td><td>110</td><td>10</td><td>10</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td><strong>jr</strong></td><td>000000</td><td>001000</td><td>111</td><td>00</td><td>00</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><p>对于不同级的<code>CTRL</code>，我们只需连出那一级所需控制信号即可。</p><p>D级：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] D_A3slt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] D_NPCop;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] D_CMPop;<br><span class="hljs-keyword">wire</span> D_EXTop;<br><span class="hljs-keyword">wire</span> D_GRFwe;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] D_t_use_rs;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] D_t_use_rt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] D_t_new;<br></code></pre></td></tr></table></figure><p>E级：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> E_ALUAslt;<br><span class="hljs-keyword">wire</span> E_ALUBslt;<br><span class="hljs-keyword">wire</span> E_GRFwe;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] E_ALUop;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] E_t_use_rs;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] E_t_use_rt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] E_t_new;<br></code></pre></td></tr></table></figure><p>M级：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> M_DMwr;<br><span class="hljs-keyword">wire</span> M_GRFwe;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] M_t_use_rs;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] M_t_use_rt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] M_t_new;<br></code></pre></td></tr></table></figure><p>W级：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] W_WDslt;<br><span class="hljs-keyword">wire</span> W_GRFwe;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] W_t_use_rs;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] W_t_use_rt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] W_t_new;<br></code></pre></td></tr></table></figure><h2 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h2><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>采用暴力转发和AT模型，注意由于T_new和在哪一级有关，我们得让这一级的CTRL知道它处在哪一级，于是我给控制模块传入一个$t$，$t=0,1,2,3$分别代表D,E,M,W级。这样，以add的T_new为例，就可以如下计算：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">T_new=(t&lt;=<span class="hljs-number">4&#x27;h2</span>)? (<span class="hljs-number">4&#x27;h2</span>-t) : <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><img src="/posts/P7%E8%AF%BE%E4%B8%8B-%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E7%9A%84MIPS%E5%BE%AE%E7%B3%BB%E7%BB%9F/e27b5c863cead7f2912b8885e7d38375.png" class="" title="e27b5c863cead7f2912b8885e7d38375"><img src="/posts/P7%E8%AF%BE%E4%B8%8B-%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E7%9A%84MIPS%E5%BE%AE%E7%B3%BB%E7%BB%9F/d722038c84b1b2f3eabc92416978bb1b.png" class="" title="d722038c84b1b2f3eabc92416978bb1b"><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p><code>T_use&lt;T_new</code>时阻塞。需要以下这些条件同时成立：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">A3 != <span class="hljs-number">5&#x27;b00000</span> &amp; rs == A3 &amp; T_use_rs != <span class="hljs-number">4&#x27;hf</span> &amp; T_new != <span class="hljs-number">4&#x27;h0</span> &amp; D_T_use_rs &lt; E_T_new<br></code></pre></td></tr></table></figure><p>对于每一级，就加上级号，如<code>D_A3</code>。</p><p>得到阻塞信号后，<code>PC</code>，<code>FDreg</code>写使能赋$0$，<code>DEreg</code>清空。</p><p>P7与P6不同的是，遇到<code>eret</code>指令后续都得阻塞，所以加两行：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">(D_eret &amp;&amp; E_ismtc0 &amp;&amp; E_rd == <span class="hljs-number">5&#x27;b01110</span>) ? <span class="hljs-number">1&#x27;b1</span> :<br>(D_eret &amp;&amp; M_ismtc0 &amp;&amp; M_rd == <span class="hljs-number">5&#x27;b01110</span>) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br></code></pre></td></tr></table></figure><h3 id="MIPS-Bridge与Timer"><a href="#MIPS-Bridge与Timer" class="headerlink" title="MIPS,Bridge与Timer"></a>MIPS,Bridge与Timer</h3><img src="/posts/P7%E8%AF%BE%E4%B8%8B-%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E7%9A%84MIPS%E5%BE%AE%E7%B3%BB%E7%BB%9F/2de8ca541ec5476a8cca234aaaca7200.png" class="" title="2de8ca541ec5476a8cca234aaaca7200"><h3 id="异常码"><a href="#异常码" class="headerlink" title="异常码"></a>异常码</h3><div class="table-container"><table><thead><tr><th style="text-align:left">异常与中断码</th><th style="text-align:left">助记符与名称</th><th style="text-align:left">指令与指令类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left"><code>Int</code> （外部中断）</td><td style="text-align:left">所有指令</td><td style="text-align:left">中断请求，来源于计时器与外部中断。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>AdEL</code> （取指异常）</td><td style="text-align:left">所有指令</td><td style="text-align:left">PC 地址未字对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">PC 地址超过 <code>0x3000 ~ 0x6ffc</code>。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>AdEL</code> （取数异常）</td><td style="text-align:left"><code>lw</code></td><td style="text-align:left">取数地址未与 4 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>lh</code></td><td style="text-align:left">取数地址未与 2 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>lh</code>, <code>lb</code></td><td style="text-align:left">取 Timer 寄存器的值。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">load 型指令</td><td style="text-align:left">计算地址时加法溢出。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">load 型指令</td><td style="text-align:left">取数地址超出 DM、Timer0、Timer1、中断发生器的范围。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><code>AdES</code> （存数异常）</td><td style="text-align:left"><code>sw</code></td><td style="text-align:left">存数地址未 4 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>sh</code></td><td style="text-align:left">存数地址未 2 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>sh</code>, <code>sb</code></td><td style="text-align:left">存 Timer 寄存器的值。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">store 型指令</td><td style="text-align:left">计算地址加法溢出。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">store 型指令</td><td style="text-align:left">向计时器的 Count 寄存器存值。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">store 型指令</td><td style="text-align:left">存数地址超出 DM、Timer0、Timer1、中断发生器的范围。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><code>Syscall</code> （系统调用）</td><td style="text-align:left"><code>syscall</code></td><td style="text-align:left">系统调用。</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><code>RI</code>（未知指令）</td><td style="text-align:left">-</td><td style="text-align:left">未知的指令码。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><code>Ov</code>（溢出异常）</td><td style="text-align:left"><code>add</code>, <code>addi</code>, <code>sub</code></td><td style="text-align:left">算术溢出。</td></tr></tbody></table></div><h3 id="有关加指令"><a href="#有关加指令" class="headerlink" title="有关加指令"></a>有关加指令</h3><p>加指令有几种类型，一般是一道R型的普通运算，一道<code>beq</code>类并清空延迟槽，一道<code>lw</code>类并卡时间。</p><h4 id="1-R型运算指令"><a href="#1-R型运算指令" class="headerlink" title="1.R型运算指令"></a>1.R型运算指令</h4><p>和P4单周期CPU没有什么本质区别，主要改动Ctrl模块和ALU模块即可。</p><h4 id="2-类beq型清空延迟槽指令"><a href="#2-类beq型清空延迟槽指令" class="headerlink" title="2.类beq型清空延迟槽指令"></a>2.类<code>beq</code>型清空延迟槽指令</h4><p>以P5_L2_2022的<code>bonall</code>指令为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">I:<br><br>target_offset ← sign_extend(offset||02)<br><br>Condition ← GPR[rs] + GPR[rt] = 032<br><br>GPR[31] ← PC + 8<br><br>I+1:<br><br>If condition then<br><br>PC ← PC + target_offset<br><br>else<br><br>NullifyCurrentInstruction()<br><br>endif<br></code></pre></td></tr></table></figure><p>需要按如下步骤修改：</p><ol><li><p>修改CMP模块，加上一个输出端口（如<code>opposite</code>)示意现在是否满足跳转条件；同时应用上<code>CMPop</code>，虽然理论上这是一个冗余设计，因为你并不需要用<code>CMPop</code>作为MUX，是输出到一个新的端口，但这是一种保护性的设计，对于长期维护可能很乱，但是课上只要加一条指令，就非常让人安心。</p></li><li><p>在CTRL模块中加入该指令。指令驱动型的最大优势在此处一览无余。一般而言，我们直接将<code>beq</code>指令下的信号复制过来即可，再扫一遍有没有需要变化的，比如如果这个指令需要写入，<code>A3slt</code>，<code>WDslt</code>，<code>GRFwe</code>就都得变。</p></li><li><p>在<code>NPCop</code>中添加<code>input opposite</code>，并在assign语句的三目运算符下增加判断，一般形如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">(NPCop==<span class="hljs-number">3&#x27;b010</span> &amp;&amp; !opposite) ? PC4:<br>(NPCop==<span class="hljs-number">3&#x27;b010</span> &amp;&amp; opposite) ? F_PC+offsetbeq:<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>在顶层连线。将1中端口加上流水线级别设出来（如<code>D_opposite</code>），连入<code>NPC</code>，<code>CMP</code>。有的时候是否写入寄存器、写入哪个寄存器和这个判断信号有关，那么还需连入CTRL</p></li><li><p>最重要也是最容易忘的一步！！！加入<code>PC+8</code>硬编码！否则不会转发！</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> E_isPCplus8 = (E_Instr[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] === <span class="hljs-number">6&#x27;b000011</span> || E_Instr[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>]==<span class="hljs-number">6&#x27;b011001</span>);<br><span class="hljs-keyword">assign</span> M_isPCplus8 = (M_Instr[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] === <span class="hljs-number">6&#x27;b000011</span> || M_Instr[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>]==<span class="hljs-number">6&#x27;b011001</span>);<br></code></pre></td></tr></table></figure></li><li><p>如果需要增加寄存器接口（如<code>D_RD2</code>)，请务必接入转发后的数据，如<code>D_fixedRD2</code>.</p></li><li><p>如果需要作为<code>input</code>传入各级CTRL，可能要把这个<code>condition</code>信号流水。一般出现于<code>GRFwe</code>不定的时候。</p></li></ol><h4 id="3-类lw型指令与时间优化"><a href="#3-类lw型指令与时间优化" class="headerlink" title="3.类lw型指令与时间优化"></a>3.类<code>lw</code>型指令与时间优化</h4><p>这是最困难的一类题！我们以推荐题中最难的L5_2022为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">vAddr ← sign_extend(offset) + GPR[base]<br><br>pAddr ← vAddr31...2 || 02<br><br>memword ← memory[pAddr]<br><br>bit ← vAddr1<br><br>def:<br><br>countOne(x): x 中 1 的个数<br><br>countZero(x): x 中 0 的个数<br><br>memHalf ← memword15+16*bit ..16*bit<br><br>Condition ← countZero(memHalf) ≤ countOne(memHalf)<br><br>if Condition:<br><br>GPR[rt] ← sign_extend(memHalf)<br><br>else:<br><br>GPR[31] ← PC + 4<br><br>end if<br></code></pre></td></tr></table></figure><p>首先，因为它是取出字（半字、字节）进行操作，那么我们得到操作数至少在<code>dm</code>模块才能出来。于是我们有两个选择，要么在<code>dm</code>模块加一个输出端口，在<code>dm</code>内部算出需要的结果；要么在顶层直接计算。</p><ol><li>如果使用前者，我们将新结果放入<code>DMans</code>，0数是否小于1数放入<code>condition</code>端口，相当于给dm模块加了两个输出。</li><li>将<code>DMans</code>，<code>condition</code>从M级开始参与流水。</li><li>在CTRL模块内增加该指令，先默认其选用rt寄存器，并写入DMans，即<code>`A3slt=0</code>，<code>WDslt=3</code>，注意WD是多加了一个接口的。</li><li>在顶层连线后，修正M级的A3和W级的WD，并将所有用到<code>M_A3</code>的地方修正。</li><li>阻塞模块，遇到E级是该指令且<code>D_rs</code>或<code>D_rt</code>等于<code>E_A3</code>或$31$号寄存器时阻塞，注意阻塞的<code>T_use</code>等条件仍需写！</li></ol><p>注意以下可能出bug的地方：</p><ul><li>注意A3在M级就修正，而WD直接在选择端口加一个硬编码即可。</li><li>阻塞是阻塞E级！传入<code>E_islwer</code>之类的</li><li>注意CTRL可能不一定能照抄，比如会用到rt之类的。</li></ul><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a><strong>测试方案</strong></h2><p>使用$COT$评测机进行对拍。</p><p>不过使用中遇到不少问题。由于阻塞周期不同，和MARS对拍会出现timer给出的中断不一致的情况。如果能找到阻塞方式完全相同的同学，就可以实现对拍。</p><p>构造数据就是覆盖所有可能中断异常的情况，然后重点测试延迟槽有关的异常中断。</p><p>下面是一段内部异常的自测代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lw      $t0, 1($zero)<br>sw      $t0, 2($zero)<br>addi    $t0, $zero, 0x7fff<br>lui     $t0, 0x7fff<br>addi    $t1, $t0, 1<br>sll     $t0, $t0, 1<br></code></pre></td></tr></table></figure><p><code>handler</code>使用学长评测机里的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># 主要处理PC异常<br>_quick_handle:<br>    mfc0 $k0, $13<br>    andi $k0, $k0, 0x00fc<br><br>    # 没有srl指令，这一步骤判断异常是否为0x0004<br>    ori$k1, $0, 0x0010<br>    beq$k0, $k1, adel_handler_quick<br>    nop<br>    <br>    beq $0, $0, _entry<br>    nop<br><br># 入口程序<br>_entry:<br>    mfc0 $1, $13<br>    ori$k0, $0, 0x1000<br>    sw $sp, -4($k0)<br>    <br>    addi $k0, $k0, -256<br>    add $sp, $0, $k0<br>    <br>    beq $0, $0,_save_context<br>    nop<br><br># PC错误<br>adel_handler_quick:<br>    mfc0 $k0, $14<br>    addi $k0, $k0, -0x3000<br>    lui $k1, 0xffff<br>    ori $k1,$k1,0xe000<br>    and $k0,$k0,$k1<br>    bne $k0,$0,adel_type_2<br>    nop<br>    mfc0 $k0, $14<br>    andi $k0,$k0,3<br>    bne $k0,$0,adel_type_1<br>    nop<br>    jal _entry<br>    nop<br>    <br># PC未对齐<br>adel_type_1:<br>    mfc0 $k0, $14<br>    andi $k0, $k0, 0xfffc<br>    addi $k0, $k0, 4<br>    mtc0 $k0, $14<br>    eret<br>    ori $1, $0, 0x1234<br>    <br># PC超出范围<br>adel_type_2:<br>    ori $k0, $0, 0x2180<br>    lw $k0, 0($k0)<br>    mtc0 $k0,$14<br>    nop<br>    eret<br>    ori $1, $0, 0x1234<br><br># 判断异常中断类型<br>_main_handler:<br>    mfc0 $k0, $13<br>    andi $k0, $k0, 0x00fc<br>    <br>    ori$k1, $0, 0x0000<br>    beq$k0, $k1, int_handler<br>    nop<br>    ori$k1, $0, 0x0010<br>    beq$k0, $k1, adel_handler<br>    nop<br>    ori$k1, $0, 0x0014<br>    beq$k0, $k1, ades_handler<br>    nop<br>    ori$k1, $0, 0x0028<br>    beq$k0, $k1, ri_handler<br>    nop<br>    ori$k1, $0, 0x0030<br>    beq$k0, $k1, ov_handler<br>    nop<br>    ori $k1, $0, 0x0020<br>    beq $k0, $k1, syscall_handler<br>    nop<br><br># 判断中断类型<br>int_handler:<br>    sw $ra, 0($sp)<br>    addi $sp, $sp, -16<br>    mfc0 $v0, $12<br>    sw $v0, 0($sp)<br>    mfc0 $v0, $13<br>    sw $v0, 4($sp)<br>        <br>    # check INT[3]<br>    lw $v0, 0($sp)<br>    lw $v1, 4($sp)<br>    and$v0, $v1, $v0<br>    andi $v0, $v0, 0x800<br>    bne$v0, $0, timer1_handler<br>    nop<br>    <br>    # check INT[2]<br>    lw$v0, 0($sp)<br>    lw$v1, 4($sp)<br>    and$v0, $v1, $v0<br>    andi $v0, $v0, 0x400<br>    bne$v0, $0, timer0_handler<br>    nop<br>    jal interrupt_handler<br>    nop<br><br># 外部中断<br>interrupt_handler:<br>    lui $k0, 0xffff<br>    ori $k0, $k0, 0xffff<br>    addi $k1, $0, 0x2180<br>    lw $k1, 0($k1)<br>    addi $k0, $0, 0x7f20<br>    sb $0, 0($k0)<br>    jal _restore_context<br>    nop<br><br># Timer0中断<br>timer0_handler:<br>    lui $k0, 0xffff<br>    addi $k1, $0, 0x2180<br>    lw $k1, 0($k1) <br>    addi $k0, $0, 0x7f00<br>    sw $0, 0($k0)<br>    jal _restore_context<br>    nop<br><br># Timer1中断<br>timer1_handler:<br>    lui $k0, 0xffff<br>    ori $k0, $k0, 0x1<br>    addi $k1, $0, 0x2180<br>    lw $k1, 0($k1)<br>    addi $k0, $0, 0x7f10<br>    sw $0, 0($k0)<br>    jal _restore_context<br>    nop<br><br># 其他AdEL异常直接跳过<br>adel_handler:<br>    mfc0 $t0, $14<br>    mfc0 $k0, $13<br>    lui$t2, 0x8000<br>    and$t3, $k0, $t2<br>    addi $t0, $t0, 4<br>    bne$t3, $t2, adel_nxt<br>    nop<br>    addi $t0, $t0, 4<br>    adel_nxt:<br>    mtc0 $t0, $14<br>    jal_restore_context<br>    nop<br><br># AdES异常直接跳过<br>ades_handler:<br>    mfc0 $t0, $14<br>    mfc0 $k0, $13<br>    lui$t2, 0x8000<br>    and$t3, $k0, $t2<br>    addi $t0, $t0, 4<br>    bne$t3, $t2, ades_nxt<br>    nop<br>    addi $t0, $t0, 4<br>    ades_nxt:<br>    mtc0 $t0, $14<br>    jal_restore_context<br>    nop<br><br># 未知指令直接跳过<br>ri_handler:<br>    mfc0 $t0, $14<br>    mfc0 $k0, $13<br>    lui$t2, 0x8000<br>    and$t3, $k0, $t2<br>    addi $t0, $t0, 4<br>    bne$t3, $t2, ri_nxt<br>    nop<br>    addi $t0, $t0, 4<br>    ri_nxt:<br>    mtc0 $t0, $14<br>    jal_restore_context<br>    nop<br>    <br># 算术溢出直接跳过<br>ov_handler:<br>    mfc0 $t0, $14<br>    mfc0 $k0, $13<br>    lui$t2, 0x8000<br>    and$t3, $k0, $t2<br>    addi $t0, $t0, 4<br>    bne$t3, $t2, ov_nxt<br>    nop<br>    addi $t0, $t0, 4<br>    ov_nxt:<br>    mtc0 $t0, $14<br>    jal_restore_context<br>    nop<br><br># 处理一下syscall直接跳过<br>syscall_handler:<br>    mfc0 $t0, $14<br>    mfc0 $k0, $13<br>    lui$t2, 0x8000<br>    and$t3, $k0, $t2<br>    addi $t0, $t0, 4<br>    bne$t3, $t2, syscall_nxt<br>    nop<br>    addi $t0, $t0, 4<br>    syscall_nxt:<br>    mtc0 $t0, $14<br>    jal_restore_context<br>    nop<br><br># 返回<br>_restore:<br>    eret<br>    ori $1, $0, 0x1234<br>    <br># 保存上下文<br>_save_context:<br>    sw $2, 8($sp)    <br>    sw $3, 12($sp)    <br>    sw $4, 16($sp)    <br>    sw $5, 20($sp)    <br>    sw $6, 24($sp)    <br>    sw $7, 28($sp)    <br>    sw $8, 32($sp)    <br>    sw $9, 36($sp)    <br>    sw $10, 40($sp)   <br>    sw $11, 44($sp)    <br>    sw $12, 48($sp)   <br>    sw $13, 52($sp)    <br>    sw $14, 56($sp)   <br>    sw $15, 60($sp)    <br>    sw $16, 64($sp)   <br>    sw $17, 68($sp)    <br>    sw $18, 72($sp)   <br>    sw $19, 76($sp)    <br>    sw $20, 80($sp)   <br>    sw $21, 84($sp)    <br>    sw $22, 88($sp)   <br>    sw $23, 92($sp)    <br>    sw $24, 96($sp)   <br>    sw $25, 100($sp)   <br>    sw $28, 112($sp)   <br>    sw $29, 116($sp)   <br>    sw $30, 120($sp)   <br>    sw $31, 124($sp)<br>    mfhi $k0<br>    sw $k0, 128($sp)<br>    mflo $k0<br>    sw $k0, 132($sp)<br>    jal_main_handler<br>    nop<br>    <br># 恢复上下文<br>_restore_context:<br>    addi $sp, $0, 0x1000<br>    addi $sp, $sp, -256<br>    lw $2, 8($sp)   <br>    lw $3, 12($sp)   <br>    lw $4, 16($sp)   <br>    lw $5, 20($sp)   <br>    lw $6, 24($sp)   <br>    lw $7, 28($sp)   <br>    lw $8, 32($sp)   <br>    lw $9, 36($sp)   <br>    lw $10, 40($sp)    <br>    lw $11, 44($sp)   <br>    lw $12, 48($sp)    <br>    lw $13, 52($sp)   <br>    lw $14, 56($sp)    <br>    lw $15, 60($sp)   <br>    lw $16, 64($sp)    <br>    lw $17, 68($sp)   <br>    lw $18, 72($sp)    <br>    lw $19, 76($sp)   <br>    lw $20, 80($sp)    <br>    lw $21, 84($sp)   <br>    lw $22, 88($sp)    <br>    lw $23, 92($sp)   <br>    lw $24, 96($sp)    <br>    lw $25, 100($sp)    <br>    lw $28, 112($sp)   <br>    lw $30, 120($sp)   <br>    lw $31, 124($sp)   <br>    lw $k0, 128($sp)<br>    mthi $k0<br>    lw $k0, 132($sp)<br>    mtlo $k0<br>    lw $29, 116($sp)<br>    ori $1,$0,1<br>    beq $0, $0, _restore<br>    nop<br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="思考题1"><a href="#思考题1" class="headerlink" title="思考题1"></a>思考题1</h3><blockquote><p>请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p></blockquote><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>主要通过两种方式：<strong>轮询（Polling）</strong> 和 <strong>中断（Interrupt）</strong>。在现代操作系统中，中断是主要使用的方式。</p><h4 id="1-轮询-Polling"><a href="#1-轮询-Polling" class="headerlink" title="1. 轮询 (Polling)"></a>1. 轮询 (Polling)</h4><p>轮询是一种相对原始和低效的方式。它的工作原理如下：</p><ul><li><strong>CPU 主动查询</strong>：CPU 在其执行循环中，会周期性地、主动地去检查外设的状态。例如，CPU 会不断读取键盘控制器的某个状态寄存器。</li><li><strong>状态判断</strong>：如果状态寄存器中的某个标志位（例如“数据就绪”位）被设置，CPU 就知道有新的键盘输入了。</li><li><strong>数据读取</strong>：确认有新数据后，CPU 会从键盘控制器的数据寄存器中读取按键的扫描码（scancode），并进行处理。</li><li><strong>循环往复</strong>：如果没有新数据，CPU 就继续执行其他任务，过一会儿再回来查询。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>效率低下</strong>：CPU 需要花费大量的时钟周期去执行无意义的查询操作，即使大部分时间里用户并没有操作键盘或鼠标。这浪费了宝贵的计算资源。</li><li><strong>响应不及时</strong>：CPU 两次查询之间存在时间间隔。如果用户在这个间隔内输入，CPU 无法立即响应，必须等到下一次查询时才能发现，导致延迟。</li></ul><p>轮询通常只在一些简单的嵌入式系统或操作系统启动的早期阶段（此时中断系统还未初始化好）使用。</p><h4 id="2-中断-Interrupt"><a href="#2-中断-Interrupt" class="headerlink" title="2. 中断 (Interrupt)"></a>2. 中断 (Interrupt)</h4><p>中断是现代计算机系统处理外设交互的主流方式，它高效且响应迅速。其工作流程如下：</p><ol><li><strong>事件发生</strong>：用户按下键盘上的一个键，或者移动/点击鼠标。</li><li><strong>设备控制器处理</strong>：键盘/鼠标控制器（一个专门的硬件芯片）s检测到这个物理动作，将其转换为数字信号（例如，键盘的扫描码），并将其存入自己的内部缓冲区（数据寄存器）。</li><li><strong>发送中断请求 (IRQ)</strong>：设备控制器通过一根物理信号线，向 <strong>中断控制器</strong>（如经典的 8259A PIC 或现代的 APIC）发送一个中断请求（Interrupt Request, IRQ）信号。这个信号就像是设备在对 CPU “举手”，表示“我有急事找你”。</li><li><strong>中断控制器通知 CPU</strong>：中断控制器接收到来自多个设备的中断请求后，会根据优先级进行仲裁，然后向 CPU 的一个特定引脚（中断引脚）发送一个中断信号。</li><li><strong>CPU 响应中断</strong>：<ul><li>CPU 在执行完当前指令后，会检查中断引脚。如果检测到中断信号，并且中断是允许的（即中断标志位未被屏蔽），CPU 就会暂停当前正在执行的程序。</li><li><strong>保存现场</strong>：CPU 会自动将当前的程序计数器（PC）和一些关键寄存器（如程序状态字 PSW）的值压入内核堆栈。这是为了在处理完中断后能够准确地返回到原来的执行位置。</li><li><strong>识别中断源</strong>：CPU 会向中断控制器询问是哪个设备触发了中断。中断控制器会返回一个唯一的数字，称为 <strong>中断向量号</strong>。</li></ul></li><li><strong>跳转到中断服务程序 (ISR)</strong>：<ul><li>CPU 使用这个中断向量号，在内存中的一个预设的表——<strong>中断向量表（Interrupt Vector Table, IVT）</strong>——中查找对应的条目。</li><li>这个表中的每个条目都存放着一个地址，指向处理特定中断的程序，这个程序被称为 <strong>中断服务程序（Interrupt Service Routine, ISR）</strong> 或中断处理程序。</li><li>CPU 将 PC 设置为这个 ISR 的地址，开始执行中断处理。</li></ul></li><li><strong>执行 ISR</strong>：<ul><li>ISR 是操作系统内核的一部分（通常是设备驱动程序的一部分）。它会从设备控制器的数据寄存器中读取数据（如键盘扫描码）。</li><li>对数据进行处理（例如，将其放入操作系统的键盘缓冲区，等待应用程序读取）。</li><li>向设备控制器发送一个确认信号，表示数据已被处理，设备可以准备下一次输入。</li></ul></li><li><strong>恢复现场</strong>：ISR 执行完毕后，会执行一条特殊指令（如 <code>iret</code>）。这条指令会从内核堆栈中弹出之前保存的 PC 和寄存器值，将其恢复到 CPU 中。</li><li><strong>返回原程序</strong>：CPU 从被中断的地方继续执行原来的程序，就好像什么都没发生过一样。</li></ol><h3 id="思考题2"><a href="#思考题2" class="headerlink" title="思考题2"></a>思考题2</h3><blockquote><p>请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p></blockquote><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><h4 id="1-为什么必须是指定好的地址？"><a href="#1-为什么必须是指定好的地址？" class="headerlink" title="1. 为什么必须是指定好的地址？"></a>1. 为什么必须是指定好的地址？</h4><p>原因在于 <strong>安全</strong>、<strong>稳定</strong> 和 <strong>隔离</strong>。</p><ul><li><p><strong>安全性 (Security)</strong>：中断和异常处理程序（Handler/ISR）通常在 <strong>内核模式（Kernel Mode）</strong> 或特权模式下运行。在这个模式下，代码拥有最高权限，可以访问所有内存、所有硬件设备，并执行所有 CPU 指令。如果允许用户程序自定义这个入口地址，就相当于给了用户程序一个直接跳转到内核模式并执行任意代码的机会。</p><ul><li><strong>恶意攻击</strong>：一个恶意程序可以将其入口地址设置为一段它自己编写的恶意代码。当中断发生时，CPU 会以最高权限执行这段恶意代码，从而绕过所有安全限制，窃取数据、破坏系统、安装病毒等。这是一种典型的 <strong>权限提升（Privilege Escalation）</strong> 攻击。</li></ul></li><li><p><strong>稳定性 (Stability)</strong>：中断处理程序是系统的核心，必须编写得极其小心和健壮。它需要正确地保存和恢复现场、与硬件交互、管理系统资源。</p><ul><li><strong>系统崩溃</strong>：即使用户程序不是恶意的，其提供的处理程序也可能存在 bug。例如，它可能忘记在处理完后向中断控制器发送确认信号，导致该中断被不断触发（称为“中断风暴”），使系统完全卡死。或者，它可能没有正确恢复所有寄存器，导致返回原程序后，原程序状态被破坏，从而崩溃。如果一个用户程序的 bug 就能导致整个操作系统崩溃，那这个系统是完全不可靠的。</li></ul></li><li><p><strong>隔离性 (Isolation)</strong>：现代操作系统的一个基本原则是进程隔离。一个进程的错误不应该影响到其他进程或操作系统内核。让操作系统统一管理中断处理，确保了无论哪个用户程序在运行时发生中断，处理逻辑都是一致、可靠、且与用户程序隔离的。</p></li></ul><h4 id="2-如果支持用户自定义入口地址，会怎样？"><a href="#2-如果支持用户自定义入口地址，会怎样？" class="headerlink" title="2. 如果支持用户自定义入口地址，会怎样？"></a>2. 如果支持用户自定义入口地址，会怎样？</h4><p><strong>它不能提供我们所希望的功能。</strong> 我们希望的功能是一个安全、稳定、多任务的计算环境。允许用户自定义中断入口地址会彻底摧毁这个环境。</p><p>即使我们假设“用户提供的中断处理程序合法”（即没有语法错误，能运行），也会出现以下致命问题：</p><ul><li><p><strong>问题一：权限提升与安全崩溃</strong></p><ul><li><strong>例子</strong>：一个用户程序 <code>A</code> 想要读取另一个用户程序 <code>B</code> 的密码（这在正常情况下被内存保护机制所禁止）。<code>A</code> 可以编写一个中断处理程序，该程序的功能是“读取物理地址 <code>0x12345678</code>（假设这是程序 B 存放密码的地方）的数据，并存到 <code>A</code> 的内存里”。然后，<code>A</code> 将这个处理程序的地址设置为计时器中断的处理入口。当计时器中断发生时，CPU 会跳转到 <code>A</code> 的代码，并以内核权限执行它。<code>A</code> 就成功地绕过了所有内存保护，窃取了 <code>B</code> 的数据。整个系统的安全模型荡然无存。</li></ul></li><li><p><strong>问题二：系统不稳定与资源冲突</strong></p><ul><li><strong>例子</strong>：假设两个不同的用户程序 <code>P1</code> 和 <code>P2</code> 都想自定义同一个硬件（如磁盘）的中断处理程序。<code>P1</code> 设置了它的处理程序，开始进行磁盘读写。此时操作系统切换到 <code>P2</code> 运行，<code>P2</code> 又把中断处理程序改成了它自己的。当中断（表示 <code>P1</code> 的磁盘操作已完成）到来时，CPU 却跳转到了 <code>P2</code> 的处理程序。<code>P2</code> 的代码不知道如何处理这个中断，或者错误地处理了它，很可能导致数据损坏或系统死锁。由操作系统统一管理可以确保资源访问的一致性和正确性。</li></ul></li><li><p><strong>问题三：破坏抽象与复杂性</strong></p><ul><li>操作系统为应用程序提供了简洁的抽象接口（系统调用，如 <code>read</code>、<code>write</code>）。应用程序不需要关心底层硬件中断的细节。如果让应用程序自己处理中断，那么每个需要I/O的程序都必须包含针对特定硬件的、复杂的、低级别的中断处理代码，这将使得编程变得异常困难，且程序不具备可移植性。</li></ul></li></ul><p><strong>结论</strong>：<br>中断/异常入口地址是用户态和内核态之间的一道至关重要的“门”。这扇门必须由操作系统这位“守门员”严格把控。允许用户程序随意指定这扇门通向哪里，无异于将整个系统的钥匙交给了每一个用户程序，必然会导致安全和稳定性的灾难。因此，中断向量表（或类似的机制）必须由操作系统独占和管理，这是现代操作系统设计的基石。</p><h3 id="思考题3"><a href="#思考题3" class="headerlink" title="思考题3"></a>思考题3</h3><blockquote><p>为何与外设通信需要 Bridge？</p></blockquote><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><ol><li><strong>地址解码与请求路由 (Address Decoding and Request Routing)</strong><ul><li><strong>核心功能</strong>：CPU 采用<strong>内存映射 I/O (Memory-Mapped I/O, MMIO)</strong> 的方式与外设通信。这意味着在 CPU 的视角里，外设的控制寄存器、数据寄存器等被映射到主存地址空间中的特定地址。CPU 访问这些特殊地址就等同于访问外设。</li><li><strong>桥的作用</strong>：CPU 在执行 <code>load</code> 或 <code>store</code> 指令时，只负责产生一个内存地址，并将这个请求发送到总线上。它并不关心这个地址最终对应的是物理内存（RAM）还是某个外设。系统桥的核心职责就是<strong>监视</strong>总线上的地址。当它看到一个地址时，会根据预设的地址空间划分（如题目中表格所示），来判断这个请求应该被发送给谁。</li><li><strong>具体例子</strong>：<ul><li>如果 CPU 访问地址 <code>0x0000_1000</code>，系统桥解码后发现它在数据存储器（DM）的范围 <code>0x0000_0000 ~ 0x0000_2FFF</code> 内，于是它会将请求路由到 DM。</li><li>如果 CPU 访问地址 <code>0x0000_7F00</code>，系统桥解码后发现这是计时器 0 的地址，于是它会将请求路由到计时器 0 模块，并激活相应的寄存器读写操作。</li></ul></li><li><strong>总结</strong>：系统桥就像一个<strong>交通警察或路由器</strong>，它根据地址这个“门牌号”，将 CPU 的访问请求精确地导向正确的目的地（内存或各种外设）。</li></ul></li><li><p><strong>模块化与可扩展性 (Modularity and Scalability)</strong></p><ul><li>通过将地址解码逻辑集中在系统桥中，CPU 的设计可以保持简洁和通用。CPU 核心只需要关心如何生成访存请求，而不需要知道系统中有哪些外设以及它们的地址是什么。</li><li>当系统需要增加或移除一个外设时，我们只需要修改系统桥的解码逻辑，而无需改动复杂的 CPU 核心。这大大增强了设计的<strong>模块化</strong>和<strong>可扩展性</strong>。</li></ul></li><li><p><strong>总线协议转换 (Bus Protocol Conversion)</strong></p><ul><li>在更复杂的系统中，CPU 内部总线（通常速度很快）和外设总线（可能速度较慢，协议也不同，如 APB, AHB, AXI 等）之间存在差异。桥可以作为不同总线之间的<strong>协议转换器</strong>，负责同步和匹配不同总线的数据宽度、时序和信号。虽然在 P7 这个简化的系统中可能不明显，但在真实系统中这是桥的另一个关键作用。</li></ul></li><li><p><strong>隔离与解耦 (Isolation and Decoupling)</strong></p><ul><li>系统桥将 CPU 核心与具体的物理设备实现解耦。CPU 无需关心计时器内部是如何工作的，只需通过 <code>load/store</code> 指令读写其“内存地址”即可。这种抽象使得整个系统设计更加清晰，层次分明。</li></ul></li></ol><p>综上所述，系统桥是连接 CPU 核心与系统中其他组件（内存、外设）的关键枢纽。它通过<strong>地址解码</strong>实现了统一地址空间下的请求分发，并通过<strong>模块化设计</strong>提升了系统的可扩展性和可维护性。没有桥，CPU 将无法区分和访问挂载在同一总线上的不同设备。</p><h3 id="思考题4"><a href="#思考题4" class="headerlink" title="思考题4"></a>思考题4</h3><blockquote><p>请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</p></blockquote><h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><h4 id="1-单次触发模式-One-shot-Mode"><a href="#1-单次触发模式-One-shot-Mode" class="headerlink" title="1. 单次触发模式 (One-shot Mode)"></a>1. 单次触发模式 (One-shot Mode)</h4><ul><li><strong>激活条件</strong>: <code>ctrl[2:1]</code> 的值为 <code>2&#39;b00</code>。</li><li><strong>工作行为</strong>:<ol><li>软件通过设置 <code>ctrl[0] = 1</code> 来启动定时器。</li><li>状态机从 <code>IDLE</code> -&gt; <code>LOAD</code> -&gt; <code>CNT</code> 进行转换。</li><li>在 <code>CNT</code> 状态，<code>count</code> 寄存器开始倒计时。</li><li>当 <code>count</code> 减至 1，在下一个时钟周期，状态机进入 <code>INT</code> 状态，并将内部中断标志 <code>_IRQ</code> 置为 1。</li><li>在 <code>INT</code> 状态，由于满足条件 <code>ctrl[2:1] == 2&#39;b00</code>，硬件会执行 <code>ctrl[0] &lt;= 1&#39;b0;</code>。<strong>这是该模式的核心特征：定时器硬件会自动将其自身的使能位清零，从而实现自我禁用。</strong></li><li>执行完自我禁用操作后，状态机转换回 <code>IDLE</code> 状态并保持。</li></ol></li><li><strong>总结</strong>: 在此模式下，定时器倒计时一次，触发一次中断，然后自动停止，直到软件下一次显式地重新使能它。</li></ul><h4 id="2-周期性模式-Periodic-Mode"><a href="#2-周期性模式-Periodic-Mode" class="headerlink" title="2. 周期性模式 (Periodic Mode)"></a>2. 周期性模式 (Periodic Mode)</h4><ul><li><p><strong>激活条件</strong>: <code>ctrl[2:1]</code> 的值不为 <code>2&#39;b00</code> (即 <code>01</code>, <code>10</code>, 或 <code>11</code>)。</p></li><li><p><strong>工作行为</strong>:</p><ol><li>软件通过设置 <code>ctrl[0] = 1</code> 来启动定时器。</li><li>状态机从 <code>IDLE</code> -&gt; <code>LOAD</code> -&gt; <code>CNT</code> 进行转换。</li><li>在 <code>CNT</code> 状态，<code>count</code> 寄存器开始倒计时。</li><li>当 <code>count</code> 减至 1，状态机进入 <code>INT</code> 状态，并将 <code>_IRQ</code> 置为 1。</li><li>在 <code>INT</code> 状态，由于不满足 <code>ctrl[2:1] == 2&#39;b00</code> 的条件，硬件会执行 <code>else</code> 分支：<code>_IRQ &lt;= 1&#39;b0;</code>，然后转换回 <code>IDLE</code> 状态。</li><li><strong>关键在于，<code>ctrl[0]</code> 的值保持为 1 (未被硬件修改)</strong>。因此，在下一个时钟周期，当状态机处于 <code>IDLE</code> 状态时，<code>if(</code>ctrl[0])<code>的条件立即满足，定时器会自动重新进入</code>LOAD` 状态，开始新一轮的倒计时。</li></ol></li><li><p><strong>总结</strong>: 在此模式下，定时器倒计时一次，触发一次中断，然后立即自动重新加载预设值并开始下一轮倒计时，如此循环往复，直到软件将 <code>ctrl[0]</code> 清零来主动停止它。</p><img src="/posts/P7%E8%AF%BE%E4%B8%8B-%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E7%9A%84MIPS%E5%BE%AE%E7%B3%BB%E7%BB%9F/%E5%9B%BE6.4.1%EF%BC%9ATimer%E6%A8%A1%E5%9D%97Mode0.png" class="" width="0"></li></ul><img src="/posts/P7%E8%AF%BE%E4%B8%8B-%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E7%9A%84MIPS%E5%BE%AE%E7%B3%BB%E7%BB%9F/%E5%9B%BE6.4.2%EF%BC%9ATimer%E6%A8%A1%E5%9D%97Mode1.png" class="" width="1"><h3 id="思考题5"><a href="#思考题5" class="headerlink" title="思考题5"></a>思考题5</h3><blockquote><p>倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p></blockquote><h3 id="解答-4"><a href="#解答-4" class="headerlink" title="解答"></a>解答</h3><p>如果所有信息都为空，包括PC，那会导致<code>eret</code>返回时EPC=0，跳回到0处，而PC地址是从3000开始的，立马就又会出发地址越界的错误，从而卡死在异常处理程序里出不来。</p><p>应该保留<strong>原始指令的 PC 值</strong>和<strong>是否是延迟槽指令BD</strong></p><h3 id="思考题6"><a href="#思考题6" class="headerlink" title="思考题6"></a>思考题6</h3><blockquote><p>为什么 <code>jalr</code> 指令的两个寄存器不能相同，例如 <code>jalr $31, $31</code>？</p></blockquote><h3 id="解答-5"><a href="#解答-5" class="headerlink" title="解答"></a>解答</h3><p>因为这会导致<strong>跳转的目标地址</strong>被<strong>返回地址</strong>覆盖，造成原始的跳转信息丢失。</p><p><code>jalr $31, $31</code> 指令要做两件事：</p><ol><li><strong>跳转</strong>：读取 $31 寄存器里的地址，准备跳过去。</li><li><strong>链接</strong>：把返回地址（PC+8）<strong>写回</strong>到 $31 寄存器。</li></ol><p><strong>问题在于</strong>：当指令执行完毕后，$31 寄存器里存的不再是原来的跳转目标地址，而是新的返回地址。原来的目标地址就被<strong>擦除</strong>了。</p><h3 id="思考题7"><a href="#思考题7" class="headerlink" title="思考题7"></a>思考题7</h3><blockquote><p>[P7 选做] 请详细描述你的测试方案及测试数据构造策略。</p></blockquote><h3 id="解答-6"><a href="#解答-6" class="headerlink" title="解答"></a>解答</h3><p>见上测试方案</p><h3 id="附：课下随手记，一些容易出现的bug"><a href="#附：课下随手记，一些容易出现的bug" class="headerlink" title="附：课下随手记，一些容易出现的bug"></a>附：课下随手记，一些容易出现的bug</h3><h1 id="P7-随手记"><a href="#P7-随手记" class="headerlink" title="P7-随手记"></a>P7-随手记</h1><p>ExcCode这里要按顺序，可能会有点问题。</p><p>有线没定义，没连，Req连入be</p><p>笔误</p><p>如何跳转回EPC？</p><p>Stall和Req的优先级</p><p>M_fixedALUans，转发用这个</p><p>clear还需要置1吗？</p><p>流水线寄存器，PC不能置0！</p><p>CTRL的RI，cp0we</p>]]></content>
    
    
    <categories>
      
      <category>CO课下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>CO课下</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P6课下-更复杂五级流水线CPU</title>
    <link href="/posts/P6%E8%AF%BE%E4%B8%8B-%E6%9B%B4%E5%A4%8D%E6%9D%82%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/"/>
    <url>/posts/P6%E8%AF%BE%E4%B8%8B-%E6%9B%B4%E5%A4%8D%E6%9D%82%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/</url>
    
    <content type="html"><![CDATA[<h1 id="CO设计文档—更复杂五级流水线CPU"><a href="#CO设计文档—更复杂五级流水线CPU" class="headerlink" title="CO设计文档—更复杂五级流水线CPU"></a>CO设计文档—更复杂五级流水线CPU</h1><p>P6是奖励关，难度和P5 P7不在一个档次；</p><h2 id="总体设计概述"><a href="#总体设计概述" class="headerlink" title="总体设计概述"></a>总体设计概述</h2><p>要求实现的指令集为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add, sub, and, or, slt, sltu, lui<br>addi, andi, ori<br>lb, lh, lw, sb, sh, sw<br>mult, multu, div, divu, mfhi, mflo, mthi, mtlo<br>beq, bne, jal, jr<br></code></pre></td></tr></table></figure><p><strong>支持延迟槽</strong>。</p><p>整体结构如下图所示：</p><img src="/posts/P6%E8%AF%BE%E4%B8%8B-%E6%9B%B4%E5%A4%8D%E6%9D%82%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/p7.png" class="" title="p7"><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li>对于元件的文件命名，均为<code>元件英文简称</code>，例如<code>GRF.v</code>，<code>ALU.v</code>等，实例化时命名为<code>_小写英文名</code>，例如<code>_alu</code>，<code>_grf</code>等</li><li>对于流水线寄存器文件命名为<code>两边的流水线层级reg</code>，例如<code>FDreg.v</code>，<code>DEreg.v</code>，实例化时命名相同。</li><li>每一级的控制信号和临时的<code>wire</code>均以本级的名称开头，如<code>E_ALUOp</code>，<code>M_DMwr</code>等</li><li>在流水线中参与流水的信息遵从以下约定（以D级为例）<ul><li><code>PC</code>和<code>Instr</code>命名以流水线层级开头，如<code>D_PC</code>，<code>D_Instr</code></li><li>寄存器地址分别为<code>D_A1</code>，<code>D_A3</code>，读出数据为<code>D_RD1</code>，<code>D_RD2</code></li><li>转发后得到的修复的寄存器数据（直接读取也视为一种转发）记作<code>D_fixedRD1</code>，<code>D_fixedRD2</code></li><li>即将写入的寄存器地址为<code>W_A3</code>，即将写入的数据记作<code>W_WD</code>，选择信号为<code>W_WDSel</code></li></ul></li></ul><p>下面将按照流水线层级逐一分析各个单元</p><h3 id="F级-Fetch-取指令"><a href="#F级-Fetch-取指令" class="headerlink" title="F级(Fetch/取指令)"></a>F级(Fetch/取指令)</h3><ul><li>本级没有转发，阻塞时需要取消<code>PC</code>写使能</li><li>本级的输入有来自D级的<code>NPC</code>，本级的输出是<code>F_PC</code>和<code>F_Instr</code>，两者需要参与流水线流水</li></ul><h4 id="IFU（取指单元）"><a href="#IFU（取指单元）" class="headerlink" title="IFU（取指单元）"></a>IFU（取指单元）</h4><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>NPC[31:0]</td><td>输入</td><td>待写入PC的指令地址</td></tr><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>PC_en</td><td>输入</td><td>PC的写使能</td></tr><tr><td>PC[31:0]</td><td>输出</td><td>当前指令地址</td></tr><tr><td>Instr[31:0]</td><td>输出</td><td>32位的指令值</td></tr></tbody></table></div><p>然后与<code>mips_txt.v</code>交互获得当前指令</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog">PC _pc (<span class="hljs-variable">.clk</span>(clk),<br>  <span class="hljs-variable">.reset</span>(reset),<br>  <span class="hljs-variable">.PC_en</span>(PC_en),<br>  <span class="hljs-variable">.PC</span>(F_PC),<br>  <span class="hljs-variable">.NPC</span>(F_NPC)<br>  );<br><br><span class="hljs-keyword">assign</span> i_inst_addr = F_PC;<br><span class="hljs-keyword">assign</span> F_Instr = i_inst_rdata;<br></code></pre></td></tr></table></figure><h4 id="NPC（次地址计算单元）"><a href="#NPC（次地址计算单元）" class="headerlink" title="NPC（次地址计算单元）"></a>NPC（次地址计算单元）</h4><p>把<code>beq</code>是否执行的判断交给了D级的<code>CMP</code>，根据输入信号<code>zero</code>和控制信号<code>NPCop</code>判断是否跳转</p><p>其实<code>NPC</code>横跨了F级和D级两级，我们只输入<code>F_PC</code>即可，因为事实上<code>F_PC=D_PC+4</code>，<code>beq</code>转发的<code>D_PC+4+offset=F_PC+offset</code>。<code>F_PC+8</code>则用于流水<code>PC</code>值，后面<code>jal</code>转发的时候用</p><p>我们一路携带<code>PC+8</code>到各级，便于转发。</p><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>F_PC[31:0]</td><td>输入</td><td>32位输入当前F级地址</td></tr><tr><td>zero</td><td>输入</td><td>指示b类型指令是否跳转</td></tr><tr><td>NPCop[2:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>grf[31:0]</td><td>输入</td><td><strong>处理完转发后</strong><code>$rs</code>寄存器保存的32位地址</td></tr><tr><td>NPC[31:0]</td><td>输出</td><td>32位输出次地址</td></tr></tbody></table></div><h5 id="控制信号说明"><a href="#控制信号说明" class="headerlink" title="控制信号说明"></a>控制信号说明</h5><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>$000$</td><td><code>NPC=PC+4</code></td></tr><tr><td>$001$</td><td>执行<code>beq</code>等b类指令</td></tr><tr><td>$110$</td><td>执行<code>j</code>，<code>jal</code>指令</td></tr><tr><td>$111$</td><td>执行<code>jalr</code>，<code>jr</code>指令</td></tr></tbody></table></div><h3 id="D级-Decode-译码"><a href="#D级-Decode-译码" class="headerlink" title="D级(Decode/译码)"></a>D级(Decode/译码)</h3><ul><li>本级需要处理来自E, M, W级的转发，转发信号为<code>EPCplus8</code>，<code>MPCplus8</code>，<code>M_ALUans</code>，<code>W_WD</code>，优先级按顺序排列，最低为原寄存器读出的值<code>D_RD1</code>，<code>D_RD2</code>。</li><li>本级的输入是来自F级的<code>PC</code>和<code>Instr</code>，输出是<code>D_fixedRD1</code>，<code>D_fixedRD2</code>，<code>D_ext32</code>，<code>D_PC</code>和<code>D_Instr</code>，还有输出到F级的<code>NPC</code>，<code>A3</code>和<code>PCplus8</code>记得一路带着。</li><li>本级元件较多，比较复杂</li></ul><h4 id="FD-REG（F-D级流水线寄存器）"><a href="#FD-REG（F-D级流水线寄存器）" class="headerlink" title="FD_REG（F/D级流水线寄存器）"></a>FD_REG（F/D级流水线寄存器）</h4><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>FD_clear</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>F_PC</td><td>输入</td><td>F级PC的指令地址</td></tr><tr><td>F_Instr[31:0]</td><td>输入</td><td>32位的指令值</td></tr><tr><td>FPCplus8</td><td>输入</td><td>F_PC+8</td></tr><tr><td>D_PC</td><td>输出</td><td>D级PC的指令地址</td></tr><tr><td>D_Instr[31:0]</td><td>输出</td><td>32位的指令值</td></tr><tr><td>DPCplus8</td><td>输出</td><td><code>jal</code>指令要存入<code>$ra</code>的值</td></tr></tbody></table></div><h4 id="D-GRF（寄存器堆）"><a href="#D-GRF（寄存器堆）" class="headerlink" title="D_GRF（寄存器堆）"></a>D_GRF（寄存器堆）</h4><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A1[4:0]</td><td>输入</td><td>5位地址输入信号，将其储存的数据读出到RD1</td></tr><tr><td>A2[4:0]</td><td>输入</td><td>5位地址输入信号，将其储存的数据读出到RD2</td></tr><tr><td>A3[4:0]</td><td>输入</td><td>5位地址输入信号，将其作为写入数据的目标寄存器</td></tr><tr><td>RD1[31:0]</td><td>输出</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr><td>RD2[31:0]</td><td>输出</td><td>输出A2指定的寄存器中的32位数据</td></tr><tr><td>WD[31:0]</td><td>输入</td><td>32位数据输入信号</td></tr><tr><td>GRFwe</td><td>输入</td><td>写使能</td></tr><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>异步复位信号，将32个寄存器中的数据清零；1：复位；0：无效</td></tr></tbody></table></div><h5 id="控制信号说明-1"><a href="#控制信号说明-1" class="headerlink" title="控制信号说明"></a>控制信号说明</h5><p><strong><code>D_A3slt</code></strong></p><p>从<code>rt</code>字段，<code>rd</code>字段，$0x1f$中进行选择，与P4相同，但与P4不同的是，我们A3信号需要一直带着走到W级才写寄存器。寄存器所有与<strong>写入</strong>有关的端口都应连<strong>W级信号</strong>！包括<code>W_GRFwe</code>，<code>W_A3</code>，<code>W_WD</code>。P5采用分布式译码，<code>D_A3slt</code>在<code>D_ctrl</code>模块译出，<code>W_GRFwe</code>在W级译出，<code>W_A3</code>从D级选出<code>D_A3</code>后一路跟着流水，<code>W_WD</code>是在W级通过选择而得到的。</p><h4 id="D-EXT（位扩展）"><a href="#D-EXT（位扩展）" class="headerlink" title="D_EXT（位扩展）"></a>D_EXT（位扩展）</h4><p>将16位二进制数进行零扩展或符号扩展到32位</p><p><strong>控制信号说明</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>$0$</td><td>零扩展</td></tr><tr><td>$1$</td><td>符号扩展</td></tr></tbody></table></div><h4 id="D-CMP（比较器）"><a href="#D-CMP（比较器）" class="headerlink" title="D_CMP（比较器）"></a>D_CMP（比较器）</h4><p>把原来ALU中比较值是否相等的运算移到了CMP里面，去指导<code>beq</code>这一类型的指令是否跳转</p><p>P5控制信号只有<code>CMP_beq=0</code>，现在P6扩展一个<code>bne</code>指令。</p><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>rs[31:0]</td><td>输入</td><td><strong>处理完转发后</strong><code>$rs</code>寄存器的值</td></tr><tr><td>rt[31:0]</td><td>输入</td><td><strong>处理完转发后</strong><code>$rt</code>寄存器的值</td></tr><tr><td>CMPOp[2:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>zero</td><td>输出</td><td>指示是否跳转，输入<code>NPC</code></td></tr></tbody></table></div><p><strong>控制信号</strong></p><p><strong><code>CMPop</code></strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>$0$</td><td><code>beq</code></td></tr><tr><td>$1$</td><td><code>bne</code></td></tr></tbody></table></div><h3 id="E级-Execute-执行"><a href="#E级-Execute-执行" class="headerlink" title="E级(Execute/执行)"></a>E级(Execute/执行)</h3><h4 id="DE-REG（D-E级流水线寄存器）"><a href="#DE-REG（D-E级流水线寄存器）" class="headerlink" title="DE_REG（D/E级流水线寄存器）"></a>DE_REG（D/E级流水线寄存器）</h4><ul><li><p>输入<code>D_PC,D_Instr,D_ext32</code>，此外上一级修正后的<code>D_fixedRD1</code>和<code>D_fixedRD2</code>的值也要参与流水，，<strong>这是由于指令序列<code>sw, nop, add</code>的存在，<code>sw</code>在M级需要使用<code>$rt</code>的数据，但是在E级不会再进行转发（因为在D级已经转发过了），因此需要让正确的<code>$rt</code>值参与流水</strong></p></li><li><p>输出<code>E_PC,E_Instr,E_ext32,E_RD1,E_RD2</code>，<code>ALU</code>需要这些信息</p></li></ul><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>DE_clear</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>D_PC[31:0]</td><td>输入</td><td>D级PC的指令地址</td></tr><tr><td>D_Instr[31:0]</td><td>输入</td><td>32位的指令值</td></tr><tr><td>D_ext32[31:0]</td><td>输入</td><td>16位立即数经<code>EXT</code>扩展的结果</td></tr><tr><td>D_RD1[31:0]</td><td>输入</td><td>32位的寄存器数据</td></tr><tr><td>D_RD2[31:0]</td><td>输入</td><td>32位的寄存器数据</td></tr><tr><td>DPCplus8</td><td>输入</td><td>PC+8</td></tr><tr><td>E_PC[31:0]</td><td>输出</td><td>E级PC的指令地址</td></tr><tr><td>E_Instr[31:0]</td><td>输出</td><td>32位的指令值</td></tr><tr><td>E_ext32[31:0]</td><td>输出</td><td>16位立即数经<code>EXT</code>扩展的结果</td></tr><tr><td>E_RD1[31:0]</td><td>输出</td><td>32位的寄存器数据</td></tr><tr><td>E_RD2[31:0]</td><td>输出</td><td>32位的寄存器数据</td></tr><tr><td>EPCplus8</td><td>输出</td><td>PC+8</td></tr></tbody></table></div><h4 id="E-ALU（算术逻辑单元）"><a href="#E-ALU（算术逻辑单元）" class="headerlink" title="E_ALU（算术逻辑单元）"></a>E_ALU（算术逻辑单元）</h4><ul><li>相比于P4，ALU变化不大，仅仅是去掉了$zero$输出，给了<code>CMP</code>模块。</li></ul><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>输入</td><td>32位输入运算数A</td></tr><tr><td>B[31:0]</td><td>输入</td><td>32位输入运算数B</td></tr><tr><td>ALUOp[4:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>C[31:0]</td><td>输出</td><td>32位输出运算结果</td></tr></tbody></table></div><p><strong>控制信号说明</strong></p><p><strong>1. ALUOp</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>$000$</td><td>执行加法运算</td></tr><tr><td>$001$</td><td>执行减法运算</td></tr><tr><td>$010$</td><td>执行逻辑与运算</td></tr><tr><td>$011$</td><td>执行逻辑或运算</td></tr><tr><td>$100$</td><td>执行<code>lui</code>指令</td></tr></tbody></table></div><p><strong>2. ALUASel</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>$0$</td><td>选修正后的<code>E_fixedRD1</code></td></tr><tr><td>$1$</td><td>保留</td></tr></tbody></table></div><p><strong>3. ALUBSel</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>$0$</td><td>选修正后的<code>E_fixedRD2</code></td></tr><tr><td>$1$</td><td>选择立即数进行运算</td></tr></tbody></table></div><h4 id="E-MDU（乘除槽）"><a href="#E-MDU（乘除槽）" class="headerlink" title="E_MDU（乘除槽）"></a>E_MDU（乘除槽）</h4><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>复位信号</td></tr><tr><td><code>MDUOp[2:0]</code></td><td>输入</td><td>控制信号</td></tr><tr><td><code>InputA[31:0]</code></td><td>输入</td><td>32位输入运算数A</td></tr><tr><td><code>InputB[31:0]</code></td><td>输入</td><td>32位输入运算数B</td></tr><tr><td>start</td><td>输入</td><td>开始运算的指示信号</td></tr><tr><td>busy</td><td>输出</td><td>是否处于运算过程中</td></tr><tr><td>HI[31:0]</td><td>输出</td><td>32位HI寄存器值结果</td></tr><tr><td>LO[31:0]</td><td>输出</td><td>32位LO寄存器值结果</td></tr></tbody></table></div><p><strong>控制信号说明</strong></p><p><strong>1. MDUOp</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>0</td><td>乘法运算</td></tr><tr><td>1</td><td>除法运算</td></tr><tr><td>2</td><td>无符号乘法运算</td></tr><tr><td>3</td><td>无符号除法运算</td></tr><tr><td>4</td><td><code>mfhi</code>指令</td></tr><tr><td>5</td><td><code>mflo</code>指令</td></tr><tr><td>6</td><td><code>mthi</code>指令，把D1的值赋给HI寄存器中</td></tr><tr><td>7</td><td><code>mtlo</code>指令，把D1的值赋给LO寄存器中</td></tr><tr><td>8</td><td>不是乘除法运算</td></tr></tbody></table></div><h3 id="M级-Memory-储存"><a href="#M级-Memory-储存" class="headerlink" title="M级(Memory/储存)"></a>M级(Memory/储存)</h3><ul><li>输入<code>E_PC,E_Instr</code>，此外上一级的<code>E_ALUAns</code>参与流水，即<code>E_ALUAns</code>需要参与流水，<strong>这是因为<code>ALUAns</code>是待写入或读取的内存地址</strong>，<strong>另外，上一级的修正后的rt值需要参与流水</strong>，因此还需要输入<code>E_fixedRD2</code>，<strong>这是因为<code>sw</code>指令会向内存中写入<code>$rt</code>的数据</strong></li><li>输出<code>M_PC,M_Instr,M_ALUAns,M_DMrd</code></li></ul><h4 id="EM-REG（E-M级流水线寄存器）"><a href="#EM-REG（E-M级流水线寄存器）" class="headerlink" title="EM_REG（E/M级流水线寄存器）"></a>EM_REG（E/M级流水线寄存器）</h4><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>EM_clear</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>E_PC[31:0]</td><td>输入</td><td>E级PC的指令地址</td></tr><tr><td>E_Instr[31:0]</td><td>输入</td><td>32位的指令值</td></tr><tr><td>E_fixedRD2[31:0]</td><td>输入</td><td>32位的寄存器数据</td></tr><tr><td>E_ALUAns[31:0]</td><td>输入</td><td>32位的ALU运算结果</td></tr><tr><td>EPCplus8</td><td>输入</td><td>PC+8</td></tr><tr><td>M_PC[31:0]</td><td>输出</td><td>M级PC的指令地址</td></tr><tr><td>M_Instr[31:0]</td><td>输出</td><td>32位的指令值</td></tr><tr><td>M_ALUAns[31:0]</td><td>输出</td><td>32位的ALU运算结果</td></tr><tr><td>M_RD2[31:0]</td><td>输出</td><td>32位的寄存器数据</td></tr><tr><td>MPCplus8</td><td>输出</td><td>PC+8</td></tr></tbody></table></div><h4 id="M-DM（数据储存器）"><a href="#M-DM（数据储存器）" class="headerlink" title="M_DM（数据储存器）"></a>M_DM（数据储存器）</h4><ul><li><p><code>DM</code>已经不需要自行实现，调用<code>mips_txt.v</code>中的接口即可</p></li><li><p>利用BE模块处理待写入数据，使其支持按半字、字节、字储存</p></li><li>利用DE模块处理DM返回的数据，使其可以按照不同要求存入寄存器</li></ul><h5 id="M-BE"><a href="#M-BE" class="headerlink" title="M_BE"></a>M_BE</h5><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td><code>saveop[3:0]</code></td><td>输入</td><td>控制信号</td></tr><tr><td><code>addr[31:0]</code></td><td>输入</td><td>地址信息，用于处理半字、字节</td></tr><tr><td><code>data[31:0]</code></td><td>输入</td><td>读取的寄存器数据，待处理</td></tr><tr><td><code>DMwr[3:0]</code></td><td>输出</td><td>控制写入半字、字节的位置</td></tr><tr><td><code>fixed_data[31:0]</code></td><td>输出</td><td>待写入数据</td></tr></tbody></table></div><h5 id="M-DE"><a href="#M-DE" class="headerlink" title="M_DE"></a>M_DE</h5><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td><code>loadop[3:0]</code></td><td>输入</td><td>控制信号</td></tr><tr><td><code>addr[31:0]</code></td><td>输入</td><td>地址信息，用于处理半字、字节</td></tr><tr><td><code>data[31:0]</code></td><td>输入</td><td><code>mips_txt.v</code>返回的DM中的数据</td></tr><tr><td><code>fixed_data[31:0]</code></td><td>输出</td><td>处理之后的正确的读取数据</td></tr></tbody></table></div><h5 id="与接口进行交互"><a href="#与接口进行交互" class="headerlink" title="与接口进行交互"></a>与接口进行交互</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 与DM交互</span><br>BE _be (<span class="hljs-variable">.addr</span>(M_DMaddr),<br> <span class="hljs-variable">.data</span>(M_DM_WD), <br> <span class="hljs-variable">.saveop</span>(M_saveop), <br> <span class="hljs-variable">.DMwr</span>(M_DM_bytewr),<br>       <span class="hljs-variable">.fixed_data</span>(M_fixed_DM_WD));<br>DE _de  (<span class="hljs-variable">.addr</span>(M_DMaddr),<br><span class="hljs-variable">.data</span>(M_DMrd),<br><span class="hljs-variable">.loadop</span>(M_loadop),<br><span class="hljs-variable">.fixed_data</span>(M_fixedRD)<br>);<br><span class="hljs-keyword">assign</span> m_inst_addr = M_PC;<br><span class="hljs-keyword">assign</span> m_data_addr = M_ALUAns;<br><span class="hljs-keyword">assign</span> m_data_addr = M_DMaddr;<br><span class="hljs-keyword">assign</span> m_data_wdata = M_fixed_DM_WD;<br><span class="hljs-keyword">assign</span> m_data_byteen = M_DM_bytewr;<br><span class="hljs-keyword">assign</span> M_DMrd = m_data_rdata;<br><br><span class="hljs-comment">// 正确输出GRF读写信息</span><br><span class="hljs-keyword">assign</span> m_inst_addr = M_PC;<br><span class="hljs-keyword">assign</span> w_inst_addr = W_PC;<br><span class="hljs-keyword">assign</span> w_grf_we    = W_GRFwe;<br><span class="hljs-keyword">assign</span> w_grf_addr  = W_A3;<br><span class="hljs-keyword">assign</span> w_grf_wdata = W_WD;<br></code></pre></td></tr></table></figure><h3 id="W级-Write-回写"><a href="#W级-Write-回写" class="headerlink" title="W级(Write/回写)"></a>W级(Write/回写)</h3><ul><li>W级事实上与D级重合了，但是仍然需要处理向E,M级的转发</li></ul><h4 id="MW-REG（M-W级流水线寄存器）"><a href="#MW-REG（M-W级流水线寄存器）" class="headerlink" title="MW_REG（M/W级流水线寄存器）"></a>MW_REG（M/W级流水线寄存器）</h4><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>MW_clear</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>M_PC[31:0]</td><td>输入</td><td>M级PC的指令地址</td></tr><tr><td>M_Instr[31:0]</td><td>输入</td><td>32位的指令值</td></tr><tr><td>M_DMRD[31:0]</td><td>输入</td><td>从内存中读取的值</td></tr><tr><td>M_ALUAns[31:0]</td><td>输入</td><td>32位的ALU运算结果</td></tr><tr><td>MPCplus8</td><td>输入</td><td>PC+8</td></tr><tr><td>W_PC[31:0]</td><td>输出</td><td>W级PC的指令地址</td></tr><tr><td>W_Instr[31:0]</td><td>输出</td><td>32位的指令值</td></tr><tr><td>W_DMrd[31:0]</td><td>输出</td><td>从内存中读取的值</td></tr><tr><td>W_ALUAns[31:0]</td><td>输出</td><td>32位的ALU运算结果</td></tr><tr><td>WPCplus8</td><td>输出</td><td>PC+8</td></tr></tbody></table></div><h3 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h3><p>我采用分布式译码，每一级实例化一个控制器，对于所有<code>CTRL</code>均有：</p><div class="table-container"><table><thead><tr><th>指令</th><th>opcode</th><th>funct</th><th>NPCOp</th><th>WRA3Sel</th><th>WDSel</th><th>EXTOp</th><th>WE</th><th>ALUASel</th><th>ALUBSel</th><th>ALUOp</th><th>DMWr</th></tr></thead><tbody><tr><td><strong>add</strong></td><td>000000</td><td>100000</td><td>000</td><td>01</td><td>00</td><td>X</td><td>1</td><td>0</td><td>0</td><td>000</td><td>0</td></tr><tr><td><strong>sub</strong></td><td>000000</td><td>100010</td><td>000</td><td>01</td><td>00</td><td>X</td><td>1</td><td>0</td><td>0</td><td>001</td><td>0</td></tr><tr><td><strong>ori</strong></td><td>001101</td><td></td><td>000</td><td>00</td><td>00</td><td>0</td><td>1</td><td>0</td><td>1</td><td>011</td><td>0</td></tr><tr><td><strong>lw</strong></td><td>100011</td><td></td><td>000</td><td>00</td><td>01</td><td>1</td><td>1</td><td>0</td><td>1</td><td>000</td><td>0</td></tr><tr><td><strong>sw</strong></td><td>101011</td><td></td><td>000</td><td>00</td><td>01</td><td>1</td><td>0</td><td>0</td><td>1</td><td>000</td><td>1</td></tr><tr><td><strong>beq</strong></td><td>000100</td><td></td><td>001</td><td>X</td><td>X</td><td>1</td><td>0</td><td>0</td><td>0</td><td>001</td><td>0</td></tr><tr><td><strong>lui</strong></td><td>001111</td><td></td><td>000</td><td>00</td><td>00</td><td>X</td><td>1</td><td>0</td><td>1</td><td>100</td><td>0</td></tr><tr><td><strong>jal</strong></td><td>000011</td><td></td><td>110</td><td>10</td><td>10</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td><strong>jr</strong></td><td>000000</td><td>001000</td><td>111</td><td>00</td><td>00</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><p>对于不同级的<code>CTRL</code>，我们只需连出那一级所需控制信号即可。</p><p>D级：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] D_A3slt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] D_NPCop;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] D_CMPop;<br><span class="hljs-keyword">wire</span> D_EXTop;<br><span class="hljs-keyword">wire</span> D_GRFwe;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] D_t_use_rs;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] D_t_use_rt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] D_t_new;<br></code></pre></td></tr></table></figure><p>E级：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> E_ALUAslt;<br><span class="hljs-keyword">wire</span> E_ALUBslt;<br><span class="hljs-keyword">wire</span> E_GRFwe;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] E_ALUop;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] E_t_use_rs;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] E_t_use_rt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] E_t_new;<br></code></pre></td></tr></table></figure><p>M级：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> M_DMwr;<br><span class="hljs-keyword">wire</span> M_GRFwe;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] M_t_use_rs;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] M_t_use_rt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] M_t_new;<br></code></pre></td></tr></table></figure><p>W级：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] W_WDslt;<br><span class="hljs-keyword">wire</span> W_GRFwe;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] W_t_use_rs;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] W_t_use_rt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] W_t_new;<br></code></pre></td></tr></table></figure><h2 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h2><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>采用暴力转发和AT模型，注意由于T_new和在哪一级有关，我们得让这一级的CTRL知道它处在哪一级，于是我给控制模块传入一个$t$，$t=0,1,2,3$分别代表D,E,M,W级。这样，以add的T_new为例，就可以如下计算：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">T_new=(t&lt;=<span class="hljs-number">4&#x27;h2</span>)? (<span class="hljs-number">4&#x27;h2</span>-t) : <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><img src="/posts/P6%E8%AF%BE%E4%B8%8B-%E6%9B%B4%E5%A4%8D%E6%9D%82%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/e27b5c863cead7f2912b8885e7d38375.png" class="" title="e27b5c863cead7f2912b8885e7d38375"><img src="/posts/P6%E8%AF%BE%E4%B8%8B-%E6%9B%B4%E5%A4%8D%E6%9D%82%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/d722038c84b1b2f3eabc92416978bb1b.png" class="" title="d722038c84b1b2f3eabc92416978bb1b"><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p><code>T_use&lt;T_new</code>时阻塞。需要以下这些条件同时成立：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">A3 != <span class="hljs-number">5&#x27;b00000</span> &amp; rs == A3 &amp; T_use_rs != <span class="hljs-number">4&#x27;hf</span> &amp; T_new != <span class="hljs-number">4&#x27;h0</span> &amp; D_T_use_rs &lt; E_T_new<br></code></pre></td></tr></table></figure><p>对于每一级，就加上级号，如<code>D_A3</code>。</p><p>得到阻塞信号后，<code>PC</code>，<code>FDreg</code>写使能赋$0$，<code>DEreg</code>清空。</p><h3 id="有关加指令"><a href="#有关加指令" class="headerlink" title="有关加指令"></a>有关加指令</h3><p>加指令有几种类型，一般是一道R型的普通运算，一道<code>beq</code>类并清空延迟槽，一道<code>lw</code>类并卡时间。</p><h4 id="1-R型运算指令"><a href="#1-R型运算指令" class="headerlink" title="1.R型运算指令"></a>1.R型运算指令</h4><p>和P4单周期CPU没有什么本质区别，主要改动Ctrl模块和ALU模块即可。</p><h4 id="2-类beq型清空延迟槽指令"><a href="#2-类beq型清空延迟槽指令" class="headerlink" title="2.类beq型清空延迟槽指令"></a>2.类<code>beq</code>型清空延迟槽指令</h4><p>以P5_L2_2022的<code>bonall</code>指令为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">I:<br><br>target_offset ← sign_extend(offset||02)<br><br>Condition ← GPR[rs] + GPR[rt] = 032<br><br>GPR[31] ← PC + 8<br><br>I+1:<br><br>If condition then<br><br>PC ← PC + target_offset<br><br>else<br><br>NullifyCurrentInstruction()<br><br>endif<br></code></pre></td></tr></table></figure><p>需要按如下步骤修改：</p><ol><li><p>修改CMP模块，加上一个输出端口（如<code>opposite</code>)示意现在是否满足跳转条件；同时应用上<code>CMPop</code>，虽然理论上这是一个冗余设计，因为你并不需要用<code>CMPop</code>作为MUX，是输出到一个新的端口，但这是一种保护性的设计，对于长期维护可能很乱，但是课上只要加一条指令，就非常让人安心。</p></li><li><p>在CTRL模块中加入该指令。指令驱动型的最大优势在此处一览无余。一般而言，我们直接将<code>beq</code>指令下的信号复制过来即可，再扫一遍有没有需要变化的，比如如果这个指令需要写入，<code>A3slt</code>，<code>WDslt</code>，<code>GRFwe</code>就都得变。</p></li><li><p>在<code>NPCop</code>中添加<code>input opposite</code>，并在assign语句的三目运算符下增加判断，一般形如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">(NPCop==<span class="hljs-number">3&#x27;b010</span> &amp;&amp; !opposite) ? PC4:<br>(NPCop==<span class="hljs-number">3&#x27;b010</span> &amp;&amp; opposite) ? F_PC+offsetbeq:<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>在顶层连线。将1中端口加上流水线级别设出来（如<code>D_opposite</code>），连入<code>NPC</code>，<code>CMP</code>。有的时候是否写入寄存器、写入哪个寄存器和这个判断信号有关，那么还需连入CTRL</p></li><li><p>最重要也是最容易忘的一步！！！加入<code>PC+8</code>硬编码！否则不会转发！</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> E_isPCplus8 = (E_Instr[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] === <span class="hljs-number">6&#x27;b000011</span> || E_Instr[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>]==<span class="hljs-number">6&#x27;b011001</span>);<br><span class="hljs-keyword">assign</span> M_isPCplus8 = (M_Instr[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] === <span class="hljs-number">6&#x27;b000011</span> || M_Instr[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>]==<span class="hljs-number">6&#x27;b011001</span>);<br></code></pre></td></tr></table></figure></li><li><p>如果需要增加寄存器接口（如<code>D_RD2</code>)，请务必接入转发后的数据，如<code>D_fixedRD2</code>.</p></li><li><p>如果需要作为<code>input</code>传入各级CTRL，可能要把这个<code>condition</code>信号流水。一般出现于<code>GRFwe</code>不定的时候。</p></li></ol><h4 id="3-类lw型指令与时间优化"><a href="#3-类lw型指令与时间优化" class="headerlink" title="3.类lw型指令与时间优化"></a>3.类<code>lw</code>型指令与时间优化</h4><p>这是最困难的一类题！我们以推荐题中最难的L5_2022为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">vAddr ← sign_extend(offset) + GPR[base]<br><br>pAddr ← vAddr31...2 || 02<br><br>memword ← memory[pAddr]<br><br>bit ← vAddr1<br><br>def:<br><br>countOne(x): x 中 1 的个数<br><br>countZero(x): x 中 0 的个数<br><br>memHalf ← memword15+16*bit ..16*bit<br><br>Condition ← countZero(memHalf) ≤ countOne(memHalf)<br><br>if Condition:<br><br>GPR[rt] ← sign_extend(memHalf)<br><br>else:<br><br>GPR[31] ← PC + 4<br><br>end if<br></code></pre></td></tr></table></figure><p>首先，因为它是取出字（半字、字节）进行操作，那么我们得到操作数至少在<code>dm</code>模块才能出来。于是我们有两个选择，要么在<code>dm</code>模块加一个输出端口，在<code>dm</code>内部算出需要的结果；要么在顶层直接计算。</p><ol><li>如果使用前者，我们将新结果放入<code>DMans</code>，0数是否小于1数放入<code>condition</code>端口，相当于给dm模块加了两个输出。</li><li>将<code>DMans</code>，<code>condition</code>从M级开始参与流水。</li><li>在CTRL模块内增加该指令，先默认其选用rt寄存器，并写入DMans，即<code>`A3slt=0</code>，<code>WDslt=3</code>，注意WD是多加了一个接口的。</li><li>在顶层连线后，修正M级的A3和W级的WD，并将所有用到<code>M_A3</code>的地方修正。</li><li>阻塞模块，遇到E级是该指令且<code>D_rs</code>或<code>D_rt</code>等于<code>E_A3</code>或$31$号寄存器时阻塞，注意阻塞的<code>T_use</code>等条件仍需写！</li></ol><p>注意以下可能出bug的地方：</p><ul><li>注意A3在M级就修正，而WD直接在选择端口加一个硬编码即可。</li><li>阻塞是阻塞E级！传入<code>E_islwer</code>之类的</li><li>注意CTRL可能不一定能照抄，比如会用到rt之类的。</li></ul><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a><strong>测试方案</strong></h2><p>本人采用Python自动生成指令程序然后手动复制进MARS汇编再复制进code.txt进行对拍。</p><p>需要注意以下几点：</p><ul><li>指令数不能太多，否则MARS汇编不出来；我选择在800-1000条之间随机；</li><li><code>lw</code>，<code>sw</code>要尽可能缩小存储地址范围，提高命中率，避免“存进去的都取不到”；</li><li><code>jr</code>指令的生成。正常来说，在数据生成的过程中，会出现<code>jr $1</code>这种数据，而$1存了个很大的数，一下就跳到很远的没有指令处了。我使用两种方式生成<code>jr</code>：一种和<code>jal</code>配对，在<code>jal</code>跳完所在的指令后面多少行生成<code>jr $31</code>；第二种是和赋值语句配对，<code>jr $x</code>前绑定<code>add sub lui ori</code>之一算出<code>$x</code>，满足$x在当前指令地址-最后一条指令地址之间。</li><li>注意字对齐</li><li>限制寄存器范围，避免使用编译器需要使用的特殊寄存器，也能提升命中率。</li><li>立即数范围不超过$16$位（我取的$8$位），以免被当成伪指令汇编成多条，出现我们没有实现的<code>addu</code>等</li><li>分支测试，生成<code>label_i</code>这种标签供跳转。</li></ul><p>Python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> struct<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PipelineTestGenerator</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 指令集定义</span><br>        <span class="hljs-variable language_">self</span>.instructions = [<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;sub&#x27;</span>, <span class="hljs-string">&#x27;ori&#x27;</span>, <span class="hljs-string">&#x27;lw&#x27;</span>, <span class="hljs-string">&#x27;sw&#x27;</span>, <span class="hljs-string">&#x27;beq&#x27;</span>, <span class="hljs-string">&#x27;lui&#x27;</span>, <span class="hljs-string">&#x27;jal&#x27;</span>, <span class="hljs-string">&#x27;jr&#x27;</span>, <span class="hljs-string">&#x27;nop&#x27;</span>]<br><br>        <span class="hljs-comment"># 存储器限制</span><br>        <span class="hljs-variable language_">self</span>.im_start = <span class="hljs-number">0x00003000</span><br>        <span class="hljs-variable language_">self</span>.im_size = <span class="hljs-number">1024</span>  <span class="hljs-comment"># 限制为1024条指令</span><br>        <span class="hljs-variable language_">self</span>.dm_start = <span class="hljs-number">0x00000000</span><br>        <span class="hljs-variable language_">self</span>.dm_size = <span class="hljs-number">3072</span>  <span class="hljs-comment"># 12KiB</span><br><br>        <span class="hljs-comment"># 寄存器定义</span><br>        <span class="hljs-variable language_">self</span>.registers = [<span class="hljs-string">f&#x27;$<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>)]<br><br>        <span class="hljs-comment"># 限制的寄存器范围（避免使用特殊寄存器）</span><br>        <span class="hljs-variable language_">self</span>.data_regs = [<span class="hljs-string">f&#x27;$<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">26</span>)]  <span class="hljs-comment"># $1-$25</span><br>        <span class="hljs-variable language_">self</span>.temp_regs = [<span class="hljs-string">f&#x27;$<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>, <span class="hljs-number">16</span>)]  <span class="hljs-comment"># $8-$15 作为临时寄存器</span><br><br>        <span class="hljs-comment"># 数据地址范围限制（为了增加lw/sw命中概率）</span><br>        <span class="hljs-variable language_">self</span>.data_addr_range = <span class="hljs-built_in">range</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-number">0x0100</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment"># 限制在256字节范围内</span><br><br>        <span class="hljs-comment"># 分支地址范围</span><br>        <span class="hljs-variable language_">self</span>.branch_range = <span class="hljs-built_in">range</span>(-<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment"># 缩小分支偏移范围</span><br><br>        <span class="hljs-comment"># 立即数范围</span><br>        <span class="hljs-variable language_">self</span>.imm_range = <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>)  <span class="hljs-comment"># 8位立即数</span><br><br>        <span class="hljs-comment"># 测试序列计数器</span><br>        <span class="hljs-variable language_">self</span>.test_count = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.label_count = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.func_count = <span class="hljs-number">0</span><br><br>        <span class="hljs-comment"># 已生成的指令计数</span><br>        <span class="hljs-variable language_">self</span>.generated_count = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.max_instructions = random.randint(<span class="hljs-number">800</span>, <span class="hljs-number">1000</span>)  <span class="hljs-comment"># 在800-1000条之间随机</span><br><br>        <span class="hljs-comment"># 记录函数位置信息</span><br>        <span class="hljs-variable language_">self</span>.func_locations = &#123;&#125;  <span class="hljs-comment"># &#123;func_name: (start_index, end_index)&#125;</span><br>        <span class="hljs-variable language_">self</span>.current_func = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 记录指令位置</span><br>        <span class="hljs-variable language_">self</span>.instruction_positions = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_instruction_sequence</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成指令序列&quot;&quot;&quot;</span><br>        code = []<br><br>        <span class="hljs-comment"># 初始化部分 - 设置寄存器和内存</span><br>        init_code = <span class="hljs-variable language_">self</span>._generate_initialization()<br>        code.extend(init_code)<br>        <span class="hljs-variable language_">self</span>.generated_count += <span class="hljs-built_in">len</span>(init_code)<br>        <span class="hljs-variable language_">self</span>._update_instruction_positions(init_code)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;初始化代码生成完成，共 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(init_code)&#125;</span> 条指令&quot;</span>)<br><br>        <span class="hljs-comment"># 生成测试序列</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-variable language_">self</span>.generated_count &lt; <span class="hljs-variable language_">self</span>.max_instructions:<br>            <span class="hljs-comment"># 随机选择指令类型，增加数据相关指令的概率</span><br>            instr_type = random.choices(<br>                [<span class="hljs-string">&#x27;data_related&#x27;</span>, <span class="hljs-string">&#x27;control&#x27;</span>, <span class="hljs-string">&#x27;memory&#x27;</span>, <span class="hljs-string">&#x27;nop&#x27;</span>],<br>                weights=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.05</span>]<br>            )[<span class="hljs-number">0</span>]<br><br>            new_code = []<br>            <span class="hljs-keyword">if</span> instr_type == <span class="hljs-string">&#x27;data_related&#x27;</span>:<br>                new_code = <span class="hljs-variable language_">self</span>._generate_data_related_pair()<br>            <span class="hljs-keyword">elif</span> instr_type == <span class="hljs-string">&#x27;control&#x27;</span>:<br>                new_code = <span class="hljs-variable language_">self</span>._generate_control_flow()<br>            <span class="hljs-keyword">elif</span> instr_type == <span class="hljs-string">&#x27;memory&#x27;</span>:<br>                new_code = <span class="hljs-variable language_">self</span>._generate_memory_access()<br>            <span class="hljs-keyword">else</span>:<br>                new_code = [<span class="hljs-string">&#x27;nop&#x27;</span>]<br><br>            <span class="hljs-comment"># 检查是否会超出限制</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.generated_count + <span class="hljs-built_in">len</span>(new_code) &gt; <span class="hljs-variable language_">self</span>.max_instructions:<br>                <span class="hljs-comment"># 如果超出，用nop填充剩余空间</span><br>                remaining = <span class="hljs-variable language_">self</span>.max_instructions - <span class="hljs-variable language_">self</span>.generated_count<br>                <span class="hljs-keyword">if</span> remaining &gt; <span class="hljs-number">0</span>:<br>                    new_code = [<span class="hljs-string">&#x27;nop&#x27;</span>] * remaining<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">break</span><br><br>            code.extend(new_code)<br>            <span class="hljs-variable language_">self</span>.generated_count += <span class="hljs-built_in">len</span>(new_code)<br>            <span class="hljs-variable language_">self</span>._update_instruction_positions(new_code)<br><br>            <span class="hljs-comment"># 每生成50条指令输出进度</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.generated_count % <span class="hljs-number">50</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;已生成 <span class="hljs-subst">&#123;self.generated_count&#125;</span> 条指令...&quot;</span>)<br><br>        <span class="hljs-comment"># 添加结束代码</span><br>        final_code = <span class="hljs-variable language_">self</span>._generate_final_code()<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.generated_count + <span class="hljs-built_in">len</span>(final_code) &lt;= <span class="hljs-variable language_">self</span>.max_instructions:<br>            code.extend(final_code)<br>            <span class="hljs-variable language_">self</span>.generated_count += <span class="hljs-built_in">len</span>(final_code)<br>            <span class="hljs-variable language_">self</span>._update_instruction_positions(final_code)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果空间不足，调整结束代码</span><br>            code.append(<span class="hljs-string">&quot;end_loop:&quot;</span>)<br>            code.append(<span class="hljs-string">&quot;nop&quot;</span>)<br>            code.append(<span class="hljs-string">&quot;beq $0, $0, end_loop&quot;</span>)<br>            code.append(<span class="hljs-string">&quot;nop&quot;</span>)<br>            <span class="hljs-variable language_">self</span>.generated_count += <span class="hljs-number">4</span><br>            <span class="hljs-variable language_">self</span>._update_instruction_positions([<span class="hljs-string">&quot;end_loop:&quot;</span>, <span class="hljs-string">&quot;nop&quot;</span>, <span class="hljs-string">&quot;beq $0, $0, end_loop&quot;</span>, <span class="hljs-string">&quot;nop&quot;</span>])<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最终生成 <span class="hljs-subst">&#123;self.generated_count&#125;</span> 条指令&quot;</span>)<br>        <span class="hljs-keyword">return</span> code<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_instruction_positions</span>(<span class="hljs-params">self, instructions</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;更新指令位置信息&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> instr <span class="hljs-keyword">in</span> instructions:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> instr.strip() <span class="hljs-keyword">or</span> instr.startswith(<span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">or</span> instr.endswith(<span class="hljs-string">&#x27;:&#x27;</span>):<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-variable language_">self</span>.instruction_positions.append(<br>                <span class="hljs-variable language_">self</span>.generated_count - <span class="hljs-built_in">len</span>(instructions) + <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.instruction_positions))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_initialization</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成初始化代码&quot;&quot;&quot;</span><br>        init_code = []<br><br>        <span class="hljs-comment"># 添加文件头注释</span><br>        init_code.append(<span class="hljs-string">&quot;# MIPS流水线处理器自动化测试程序&quot;</span>)<br>        init_code.append(<span class="hljs-string">&quot;# 生成的指令序列用于测试转发、暂停和数据相关&quot;</span>)<br>        init_code.append(<span class="hljs-string">&quot;&quot;</span>)<br><br>        <span class="hljs-comment"># 初始化数据寄存器</span><br>        <span class="hljs-keyword">for</span> i, reg <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>]):  <span class="hljs-comment"># 只初始化前8个数据寄存器</span><br>            imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>            init_code.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;reg&#125;</span>, $0, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># 初始化内存区域 - 简化版本</span><br>        base_reg = <span class="hljs-variable language_">self</span>.data_regs[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> offset <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>]:  <span class="hljs-comment"># 只初始化3个内存位置</span><br>            imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>            temp_reg = <span class="hljs-variable language_">self</span>.temp_regs[<span class="hljs-number">0</span>]<br>            init_code.append(<span class="hljs-string">f&quot;lui <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>            init_code.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>            init_code.append(<span class="hljs-string">f&quot;sw <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br><br>        <span class="hljs-keyword">return</span> init_code<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_data_related_pair</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成数据相关指令对（用于测试转发）&quot;&quot;&quot;</span><br>        pair = []<br><br>        <span class="hljs-comment"># 选择指令类型组合</span><br>        producer_types = [<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;sub&#x27;</span>, <span class="hljs-string">&#x27;ori&#x27;</span>, <span class="hljs-string">&#x27;lui&#x27;</span>, <span class="hljs-string">&#x27;lw&#x27;</span>]<br>        consumer_types = [<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;sub&#x27;</span>, <span class="hljs-string">&#x27;ori&#x27;</span>, <span class="hljs-string">&#x27;sw&#x27;</span>]<br><br>        producer = random.choice(producer_types)<br>        consumer = random.choice(consumer_types)<br><br>        <span class="hljs-comment"># 选择寄存器</span><br>        dest_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])  <span class="hljs-comment"># 使用已初始化的寄存器</span><br>        src_reg1 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>        src_reg2 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>        temp_reg = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br><br>        <span class="hljs-comment"># 生成生产者指令</span><br>        <span class="hljs-keyword">if</span> producer == <span class="hljs-string">&#x27;add&#x27;</span>:<br>            pair.append(<span class="hljs-string">f&quot;add <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;src_reg1&#125;</span>, <span class="hljs-subst">&#123;src_reg2&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> producer == <span class="hljs-string">&#x27;sub&#x27;</span>:<br>            pair.append(<span class="hljs-string">f&quot;sub <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;src_reg1&#125;</span>, <span class="hljs-subst">&#123;src_reg2&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> producer == <span class="hljs-string">&#x27;ori&#x27;</span>:<br>            imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>            pair.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;src_reg1&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> producer == <span class="hljs-string">&#x27;lui&#x27;</span>:<br>            imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>            pair.append(<span class="hljs-string">f&quot;lui <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> producer == <span class="hljs-string">&#x27;lw&#x27;</span>:<br>            base_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">5</span>])<br>            offset = random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<br>            pair.append(<span class="hljs-string">f&quot;lw <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br><br>        <span class="hljs-comment"># 插入0-2条无关指令</span><br>        nop_count = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nop_count):<br>            <span class="hljs-comment"># 插入真正无关的指令（不使用目标寄存器）</span><br>            unrelated_instr = random.choice([<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;sub&#x27;</span>, <span class="hljs-string">&#x27;ori&#x27;</span>, <span class="hljs-string">&#x27;nop&#x27;</span>])<br>            <span class="hljs-keyword">if</span> unrelated_instr == <span class="hljs-string">&#x27;nop&#x27;</span>:<br>                pair.append(<span class="hljs-string">&#x27;nop&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                reg1 = random.choice([r <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.temp_regs <span class="hljs-keyword">if</span> r != dest_reg])<br>                reg2 = random.choice([r <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.temp_regs <span class="hljs-keyword">if</span> r != dest_reg])<br>                reg3 = random.choice([r <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.temp_regs <span class="hljs-keyword">if</span> r != dest_reg])<br><br>                <span class="hljs-keyword">if</span> unrelated_instr == <span class="hljs-string">&#x27;add&#x27;</span>:<br>                    pair.append(<span class="hljs-string">f&quot;add <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;reg3&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">elif</span> unrelated_instr == <span class="hljs-string">&#x27;sub&#x27;</span>:<br>                    pair.append(<span class="hljs-string">f&quot;sub <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;reg3&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>                    pair.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># 生成消费者指令（使用生产者产生的数据）</span><br>        <span class="hljs-keyword">if</span> consumer == <span class="hljs-string">&#x27;add&#x27;</span>:<br>            pair.append(<span class="hljs-string">f&quot;add <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;src_reg1&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> consumer == <span class="hljs-string">&#x27;sub&#x27;</span>:<br>            pair.append(<span class="hljs-string">f&quot;sub <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;src_reg1&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> consumer == <span class="hljs-string">&#x27;ori&#x27;</span>:<br>            imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>            pair.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> consumer == <span class="hljs-string">&#x27;sw&#x27;</span>:<br>            base_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">5</span>])<br>            offset = random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<br>            pair.append(<span class="hljs-string">f&quot;sw <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br><br>        <span class="hljs-keyword">return</span> pair<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_control_flow</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成控制流指令&quot;&quot;&quot;</span><br>        control_code = []<br><br>        control_type = random.choice([<span class="hljs-string">&#x27;beq&#x27;</span>, <span class="hljs-string">&#x27;jal&#x27;</span>, <span class="hljs-string">&#x27;jr_safe&#x27;</span>])<br><br>        <span class="hljs-keyword">if</span> control_type == <span class="hljs-string">&#x27;beq&#x27;</span>:<br>            reg1 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>            reg2 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>            <span class="hljs-comment"># 有限的分支偏移</span><br>            offset = random.choice([<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, -<span class="hljs-number">4</span>, -<span class="hljs-number">8</span>, -<span class="hljs-number">12</span>])<br>            label = <span class="hljs-string">f&quot;label_<span class="hljs-subst">&#123;self.label_count&#125;</span>&quot;</span><br>            <span class="hljs-variable language_">self</span>.label_count += <span class="hljs-number">1</span><br>            control_code.append(<span class="hljs-string">f&quot;beq <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;label&#125;</span>&quot;</span>)<br>            control_code.append(<span class="hljs-string">&quot;nop&quot;</span>)  <span class="hljs-comment"># 延迟槽</span><br>            control_code.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;label&#125;</span>:&quot;</span>)<br><br>        <span class="hljs-keyword">elif</span> control_type == <span class="hljs-string">&#x27;jal&#x27;</span>:<br>            func_label = <span class="hljs-string">f&quot;func_<span class="hljs-subst">&#123;self.func_count&#125;</span>&quot;</span><br>            <span class="hljs-variable language_">self</span>.func_count += <span class="hljs-number">1</span><br><br>            <span class="hljs-comment"># 记录函数开始位置</span><br>            func_start = <span class="hljs-variable language_">self</span>.generated_count + <span class="hljs-built_in">len</span>(control_code)<br><br>            control_code.append(<span class="hljs-string">f&quot;jal <span class="hljs-subst">&#123;func_label&#125;</span>&quot;</span>)<br>            control_code.append(<span class="hljs-string">&quot;nop&quot;</span>)  <span class="hljs-comment"># 延迟槽</span><br>            control_code.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;func_label&#125;</span>:&quot;</span>)<br><br>            <span class="hljs-comment"># 简化的函数体</span><br>            func_body_size = random.randint(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(func_body_size):<br>                <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.generated_count + <span class="hljs-built_in">len</span>(control_code) &gt;= <span class="hljs-variable language_">self</span>.max_instructions - <span class="hljs-number">3</span>:<br>                    <span class="hljs-keyword">break</span><br><br>                instr_type = random.choice([<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;sub&#x27;</span>, <span class="hljs-string">&#x27;ori&#x27;</span>, <span class="hljs-string">&#x27;lw&#x27;</span>, <span class="hljs-string">&#x27;sw&#x27;</span>, <span class="hljs-string">&#x27;nop&#x27;</span>])<br>                <span class="hljs-keyword">if</span> instr_type == <span class="hljs-string">&#x27;add&#x27;</span>:<br>                    reg1 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    reg2 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    reg3 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    control_code.append(<span class="hljs-string">f&quot;add <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;reg3&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">elif</span> instr_type == <span class="hljs-string">&#x27;sub&#x27;</span>:<br>                    reg1 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    reg2 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    reg3 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    control_code.append(<span class="hljs-string">f&quot;sub <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;reg3&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">elif</span> instr_type == <span class="hljs-string">&#x27;ori&#x27;</span>:<br>                    reg1 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    reg2 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>                    control_code.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">elif</span> instr_type == <span class="hljs-string">&#x27;lw&#x27;</span>:<br>                    base_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">5</span>])<br>                    dest_reg = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    offset = random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<br>                    control_code.append(<span class="hljs-string">f&quot;lw <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br>                <span class="hljs-keyword">elif</span> instr_type == <span class="hljs-string">&#x27;sw&#x27;</span>:<br>                    base_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">5</span>])<br>                    src_reg = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    offset = random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<br>                    control_code.append(<span class="hljs-string">f&quot;sw <span class="hljs-subst">&#123;src_reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    control_code.append(<span class="hljs-string">&quot;nop&quot;</span>)<br><br>            <span class="hljs-comment"># 记录函数结束位置</span><br>            func_end = <span class="hljs-variable language_">self</span>.generated_count + <span class="hljs-built_in">len</span>(control_code)<br>            <span class="hljs-variable language_">self</span>.func_locations[func_label] = (func_start, func_end)<br><br>            <span class="hljs-comment"># 安全的jr $31返回</span><br>            control_code.append(<span class="hljs-string">&quot;jr $31&quot;</span>)<br>            control_code.append(<span class="hljs-string">&quot;nop&quot;</span>)  <span class="hljs-comment"># 延迟槽</span><br><br>        <span class="hljs-keyword">elif</span> control_type == <span class="hljs-string">&#x27;jr_safe&#x27;</span>:<br>            <span class="hljs-comment"># 安全的jr生成方式</span><br>            jr_type = random.choice([<span class="hljs-string">&#x27;jal_pair&#x27;</span>, <span class="hljs-string">&#x27;calc_addr&#x27;</span>])<br><br>            <span class="hljs-keyword">if</span> jr_type == <span class="hljs-string">&#x27;jal_pair&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.func_locations:<br>                <span class="hljs-comment"># 方式1: 与jal配对，在函数内部使用jr $31</span><br>                <span class="hljs-comment"># 这里我们已经在jal部分处理了，所以这种情况不需要额外生成</span><br>                <span class="hljs-comment"># 改为生成一个简单的控制流</span><br>                reg1 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>                reg2 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>                label = <span class="hljs-string">f&quot;label_<span class="hljs-subst">&#123;self.label_count&#125;</span>&quot;</span><br>                <span class="hljs-variable language_">self</span>.label_count += <span class="hljs-number">1</span><br>                control_code.append(<span class="hljs-string">f&quot;beq <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;label&#125;</span>&quot;</span>)<br>                control_code.append(<span class="hljs-string">&quot;nop&quot;</span>)<br>                control_code.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;label&#125;</span>:&quot;</span>)<br><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 方式2: 与赋值语句配对，计算合法地址</span><br>                jr_reg = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br><br>                <span class="hljs-comment"># 计算一个合法的跳转地址</span><br>                <span class="hljs-comment"># 当前指令位置（估算）</span><br>                current_pos = <span class="hljs-variable language_">self</span>.generated_count + <span class="hljs-built_in">len</span>(control_code)<br>                <span class="hljs-comment"># 合法的跳转目标范围（在当前指令附近）</span><br>                target_range_start = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, current_pos - <span class="hljs-number">20</span>)<br>                target_range_end = <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.max_instructions - <span class="hljs-number">1</span>, current_pos + <span class="hljs-number">20</span>)<br><br>                <span class="hljs-keyword">if</span> target_range_end &gt; target_range_start:<br>                    target_pos = random.randint(target_range_start, target_range_end)<br>                    <span class="hljs-comment"># 转换为字节地址</span><br>                    target_addr = <span class="hljs-number">0x3000</span> + target_pos * <span class="hljs-number">4</span><br><br>                    <span class="hljs-comment"># 使用lui和ori计算地址</span><br>                    upper = (target_addr &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFFFF</span><br>                    lower = target_addr &amp; <span class="hljs-number">0xFFFF</span><br><br>                    control_code.append(<span class="hljs-string">f&quot;lui <span class="hljs-subst">&#123;jr_reg&#125;</span>, <span class="hljs-subst">&#123;upper&#125;</span>&quot;</span>)<br>                    control_code.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;jr_reg&#125;</span>, <span class="hljs-subst">&#123;jr_reg&#125;</span>, <span class="hljs-subst">&#123;lower&#125;</span>&quot;</span>)<br>                    control_code.append(<span class="hljs-string">f&quot;jr <span class="hljs-subst">&#123;jr_reg&#125;</span>&quot;</span>)<br>                    control_code.append(<span class="hljs-string">&quot;nop&quot;</span>)  <span class="hljs-comment"># 延迟槽</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 如果无法计算合法地址，生成一个简单的指令</span><br>                    control_code.append(<span class="hljs-string">&quot;nop&quot;</span>)<br><br>        <span class="hljs-keyword">return</span> control_code<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_memory_access</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成内存访问指令序列&quot;&quot;&quot;</span><br>        memory_code = []<br><br>        access_type = random.choice([<span class="hljs-string">&#x27;lw_sw_sequence&#x27;</span>, <span class="hljs-string">&#x27;multiple_access&#x27;</span>, <span class="hljs-string">&#x27;simple&#x27;</span>])<br><br>        <span class="hljs-keyword">if</span> access_type == <span class="hljs-string">&#x27;lw_sw_sequence&#x27;</span>:<br>            <span class="hljs-comment"># lw后接使用数据的指令</span><br>            base_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">5</span>])<br>            dest_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>            offset = random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<br><br>            memory_code.append(<span class="hljs-string">f&quot;lw <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br><br>            <span class="hljs-comment"># 插入0-2条指令</span><br>            nop_count = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nop_count):<br>                memory_code.append(<span class="hljs-string">&quot;nop&quot;</span>)<br><br>            <span class="hljs-comment"># 使用加载的数据</span><br>            use_type = random.choice([<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;ori&#x27;</span>, <span class="hljs-string">&#x27;sw&#x27;</span>])<br>            <span class="hljs-keyword">if</span> use_type == <span class="hljs-string">&#x27;add&#x27;</span>:<br>                temp_reg = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                memory_code.append(<span class="hljs-string">f&quot;add <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;dest_reg&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">elif</span> use_type == <span class="hljs-string">&#x27;ori&#x27;</span>:<br>                temp_reg = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>                memory_code.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                memory_code.append(<span class="hljs-string">f&quot;sw <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br><br>        <span class="hljs-keyword">elif</span> access_type == <span class="hljs-string">&#x27;multiple_access&#x27;</span>:<br>            base_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">5</span>])<br>            reg1 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>            reg2 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br><br>            offsets = random.sample([<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>], <span class="hljs-number">2</span>)<br>            memory_code.append(<span class="hljs-string">f&quot;lw <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;offsets[<span class="hljs-number">0</span>]&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br>            memory_code.append(<span class="hljs-string">f&quot;lw <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;offsets[<span class="hljs-number">1</span>]&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br>            memory_code.append(<span class="hljs-string">f&quot;add <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>&quot;</span>)<br>            memory_code.append(<span class="hljs-string">f&quot;sw <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;offsets[<span class="hljs-number">0</span>]&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># simple</span><br>            base_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">5</span>])<br>            reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>            offset = random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<br>            <span class="hljs-keyword">if</span> random.choice([<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>]):<br>                memory_code.append(<span class="hljs-string">f&quot;lw <span class="hljs-subst">&#123;reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                memory_code.append(<span class="hljs-string">f&quot;sw <span class="hljs-subst">&#123;reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br><br>        <span class="hljs-keyword">return</span> memory_code<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_final_code</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成程序结束代码&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> [<br>            <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;# 程序结束&quot;</span>,<br>            <span class="hljs-string">&quot;end_loop:&quot;</span>,<br>            <span class="hljs-string">&quot;nop&quot;</span>,<br>            <span class="hljs-string">&quot;beq $0, $0, end_loop&quot;</span>,<br>            <span class="hljs-string">&quot;nop&quot;</span><br>        ]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_hex_file</span>(<span class="hljs-params">self, assembly_code, filename</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成十六进制文件&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 由于我们无法直接生成正确的机器码，这里只生成占位符</span><br>        <span class="hljs-comment"># 实际使用时应该用Mars进行汇编</span><br><br>        <span class="hljs-comment"># 计算实际指令数量（排除标签和注释）</span><br>        actual_instructions = []<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> assembly_code:<br>            line = line.strip()<br>            <span class="hljs-keyword">if</span> line <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> line.startswith(<span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> line.endswith(<span class="hljs-string">&#x27;:&#x27;</span>):<br>                actual_instructions.append(line)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;实际指令数量: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(actual_instructions)&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># 写入简单的十六进制占位文件</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(<span class="hljs-string">&quot;v2.0 raw\n&quot;</span>)<br>            <span class="hljs-comment"># 每条指令用0占位，实际应由Mars生成</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(actual_instructions)):<br>                f.write(<span class="hljs-string">&quot;00000000\n&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_test_program</span>(<span class="hljs-params">self, output_asm=<span class="hljs-string">&quot;test_program.s&quot;</span>, output_hex=<span class="hljs-string">&quot;test_program.hex&quot;</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成完整的测试程序&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;生成流水线测试程序...&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;目标指令数量: <span class="hljs-subst">&#123;self.max_instructions&#125;</span> 条&quot;</span>)<br><br>        <span class="hljs-comment"># 重置计数器</span><br>        <span class="hljs-variable language_">self</span>.generated_count = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.label_count = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.func_count = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.func_locations = &#123;&#125;<br>        <span class="hljs-variable language_">self</span>.instruction_positions = []<br><br>        <span class="hljs-comment"># 生成汇编代码</span><br>        assembly_code = <span class="hljs-variable language_">self</span>.generate_instruction_sequence()<br><br>        <span class="hljs-comment"># 保存汇编文件</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_asm, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> assembly_code:<br>                f.write(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;line&#125;</span>\n&quot;</span>)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;汇编代码已保存到: <span class="hljs-subst">&#123;output_asm&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># 统计实际指令数量</span><br>        actual_count = <span class="hljs-built_in">len</span>([l <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> assembly_code <span class="hljs-keyword">if</span> l.strip() <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> l.startswith(<span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> l.endswith(<span class="hljs-string">&#x27;:&#x27;</span>)])<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;实际生成的指令数量: <span class="hljs-subst">&#123;actual_count&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># 生成十六进制文件</span><br>        <span class="hljs-variable language_">self</span>.generate_hex_file(assembly_code, output_hex)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;十六进制占位文件已保存到: <span class="hljs-subst">&#123;output_hex&#125;</span>&quot;</span>)<br><br>        <span class="hljs-keyword">return</span> assembly_code<br><br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 创建测试生成器</span><br>    generator = PipelineTestGenerator()<br><br>    <span class="hljs-comment"># 生成测试程序</span><br>    test_program = generator.generate_test_program(<span class="hljs-string">&quot;mips_code.asm&quot;</span>, <span class="hljs-string">&quot;mips_code.hex&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n测试程序特性:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 指令集: add, sub, ori, lw, sw, beq, lui, jal, jr, nop&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;- 指令数量: <span class="hljs-subst">&#123;generator.generated_count&#125;</span> 条 (在800-1000条之间随机)&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 数据地址范围: 0x0000-0x00FF (提高lw/sw命中概率)&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 包含数据相关指令对测试转发&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 包含控制流指令测试分支预测和跳转&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 包含内存访问序列测试load-use相关&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 安全的jr指令生成:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  * 与jal配对，在函数内使用jr $31返回&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  * 与赋值语句配对，计算合法跳转地址&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 所有地址和数值都在合法范围内&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 确保不超过1024条指令限制&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="思考题1"><a href="#思考题1" class="headerlink" title="思考题1"></a>思考题1</h3><blockquote><p>为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？</p></blockquote><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><ul><li><strong>单独乘除法部件 (MDU) 的原因：</strong><ol><li><strong>时延差异（关键路径）：</strong> ALU 中的加减与逻辑运算通常可以在单周期内通过组合逻辑完成。而乘法和除法（尤其是除法）极其复杂，如果使用组合逻辑实现，会产生极大的延迟，从而严重拖慢整个 CPU 的时钟周期（Critical Path）。将其独立并在流水线中视为多周期部件，可以保持 CPU 主频在一个较高的水平。</li><li><strong>并行性：</strong> 现代流水线 CPU 中，乘除法部件可以独立于 ALU 工作。当 MDU 在计算耗时的除法时，后续不相关的指令（如 add, sub）可以继续流过 ALU 执行，提高了流水线的吞吐率。</li></ol></li><li><strong>独立 HI、LO 寄存器的原因：</strong><ol><li><strong>位宽需求：</strong> 两个 32 位整数相乘，结果可能达到 64 位；32 位整数除法会产生 32 位商和 32 位余数（共 64 位）。而 MIPS 的通用寄存器（GRF）仅为 32 位，无法一次性存储运算结果。</li><li><strong>避免占用 GRF 端口：</strong> 如果将 64 位结果写入 GRF，需要占用两个寄存器号（如 $t0 和 $t1），且写入需要两个周期（或增加写端口）。使用专用的 HI/LO 寄存器可以简化 GRF 的设计，且不干扰通用寄存器的读写调度。</li></ol></li></ul><h3 id="思考题2"><a href="#思考题2" class="headerlink" title="思考题2"></a>思考题2</h3><blockquote><p>真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。</p></blockquote><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><p>在真实的现代高性能 CPU 中，乘除法的实现比本实验更复杂：</p><ul><li><strong>硬件乘法器：</strong> 通常采用 <strong>Wallace Tree</strong> 或 <strong>Dadda Tree</strong> 等压缩树结构配合 <strong>Booth 编码</strong>，并设计成流水线结构。这意味着虽然乘法延迟可能是 3-5 个周期，但吞吐量可以达到 1（即每个周期都能发射一条新的乘法指令）。</li><li><strong>硬件除法器：</strong> 除法较难流水线化，通常使用 <strong>SRT 算法</strong> 或 <strong>Newton-Raphson 迭代法</strong>。现代 CPU 的除法延迟仍然较高（可能 10-20+ 周期），且通常是非流水线的或部分流水线的。</li><li><strong>乱序执行：</strong> 遇到乘除法时，CPU 不会单纯阻塞，而是利用保留站（Reservation Station）或重排序缓冲区（ROB），让后续无关指令乱序执行，掩盖乘除法的长延迟。</li></ul><h3 id="思考题3"><a href="#思考题3" class="headerlink" title="思考题3"></a>思考题3</h3><blockquote><p>请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？</p></blockquote><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><p>在我的代码中，Busy 信号的处理主要体现在 MDU 模块的状态机和 Stall 模块的阻塞逻辑中：</p><ol><li><p><strong>Busy 的产生 (MDU.v)：</strong><br>当 start 信号有效时，MDU 内部的计数器 count 被置位（乘法 5 周期，除法 10 周期）。只要 count != 0，busy 信号就持续输出高电平 1’b1。</p></li><li><p><strong>阻塞逻辑 (Stall.v)：</strong><br>我在 Stall 模块中添加了针对 MDU 的逻辑：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> D_Stall = ... | (D_ismult &amp; (E_start | E_busy));<br></code></pre></td></tr></table></figure><p>这里的 <code>D_ismult</code> 标识当前 D 级是否为乘除法相关指令（<code>mult</code>, <code>div</code>, <code>mfhi</code>, <code>mflo</code> 等）。<br>逻辑含义是：如果 <strong>D 级是乘除法指令</strong> 且 <strong>(E 级刚开始乘除法 OR MDU 正忙)</strong>，则拉高 D_Stall。</p></li><li><p><strong>效果：</strong><br>这会冻结 PC 和 F/D 级流水线寄存器，并清空 D/E 级流水线寄存器（插入 NOP）。直到 MDU 计算完成，busy 变低，D 级的指令才被允许进入 E 级。这有效地防止了后续指令在 MDU 运算未完成时错误地读取 HI/LO 或打断运算</p></li></ol><h3 id="思考题4"><a href="#思考题4" class="headerlink" title="思考题4"></a>思考题4</h3><blockquote><p>请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）</p></blockquote><h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><ol><li><strong>接口统一与规范性：</strong> 无论是 sw（写字）、sh（写半字）还是 sb（写字节），CPU 与数据存储器（DM）的交互接口都保持一致（32位数据线 + 4位使能线）。不需要针对不同的写宽度设计不同的写信号（如 we_byte, we_half 等）。</li><li><strong>简化 CPU 逻辑（清晰性）：</strong> CPU 不需要先从内存“读出旧字”，修改部分字节后再“写回新字”（Read-Modify-Write）。CPU 只需要通过 BE 模块将数据放置在正确的数据线上，并根据地址低两位生成正确的 byteen 掩码。实际的字节写入控制权交给了存储器控制器或 TB，降低了 CPU 内部逻辑的耦合度。</li><li><strong>硬件映射自然：</strong> 在 FPGA 或实际电路中，Block RAM 通常就带有字节写使能端口（Byte Write Enable），这种设计直接对应物理硬件的特性。</li></ol><h3 id="思考题5"><a href="#思考题5" class="headerlink" title="思考题5"></a>思考题5</h3><blockquote><p>请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？</p></blockquote><h3 id="解答-4"><a href="#解答-4" class="headerlink" title="解答"></a>解答</h3><ul><li><strong>实际数据大小：</strong><ul><li><strong>从 DM 获得的数据：</strong> 实际上是从存储器读出的<strong>一整个字（32位）</strong>。因为内存通常是按字对齐组织的。我们需要通过 DE (Data Extension) 模块根据地址低两位从中截取所需的字节，并进行符号扩展。</li><li><strong>向 DM 写入的数据：</strong> 实际上也是<strong>32位数据</strong>。虽然我们只想改写一个字节，但在 <code>m_data_wdata</code> 线上，我们将该字节复制到了对应的位置（在 BE 模块中处理），并利用 <code>byte_en</code> 告诉存储器只更新那一部分。</li></ul></li><li><strong>效率比较：</strong><ul><li>在我们的 MIPS 架构中，按字节读写（<code>lb</code>/<code>sb</code>）和按字读写（<code>lw</code>/<code>sw</code>）的<strong>时钟周期数是一样的</strong>（都是 5 级流水），因此速度上没有区别。</li><li><strong>效率高于按字读写的情况：</strong> 这种效率优势主要体现在<strong>空间利用率</strong>和<strong>处理非对齐数据</strong>上。例如处理字符串（<code>char</code>数组）或网络数据包时，如果强制用 <code>lw/sw</code>，需要大量的移位和掩码运算来打包/解包数据。使用 <code>lb/sb</code> 可以直接操作最小单元，代码密度更高，处理打包数据（Packed Data）时指令数更少，从这个角度看效率更高。</li></ul></li></ul><h3 id="思考题6"><a href="#思考题6" class="headerlink" title="思考题6"></a>思考题6</h3><blockquote><p>为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</p></blockquote><h3 id="解答-5"><a href="#解答-5" class="headerlink" title="解答"></a>解答</h3><p>在代码中，我采取了以下手段：</p><ol><li><strong>模块化设计（高内聚低耦合）：</strong><ul><li>将乘除法独立为 MDU 模块。</li><li>将内存写入掩码生成独立为 BE 模块。</li><li>将内存读取扩展独立为 DE 模块。</li><li>这使得 mips.v 顶层只负责连线，逻辑清晰。</li></ul></li><li><strong>控制信号的抽象（译码器分类）：</strong><ul><li>在 CTRL.v 中，我没有直接输出分散的控制位，而是定义了 loadop[3:0]（区分 lb, lh, lw）和 saveop[3:0]（区分 sb, sh, sw）。</li><li>这使得 ALU、BE、DE 模块只需要判断操作类型，而不需要知道具体指令是哪一条。</li></ul></li><li><strong>T_use / T_new 时间模型：</strong><ul><li>这是解决冲突最核心的抽象。我没有针对每一对 add-sub 或 lw-add 写特判，而是给每条指令定义了生成数据的时间 (T_new) 和使用数据的时间 (T_use)。</li><li>在 Stall.v 和转发逻辑中，只需要比较数值大小 (T_use &lt; T_new) 即可自动覆盖所有指令组合的冒险情况。</li></ul></li></ol><h3 id="思考题7"><a href="#思考题7" class="headerlink" title="思考题7"></a>思考题7</h3><blockquote><p>在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p></blockquote><h3 id="解答-6"><a href="#解答-6" class="headerlink" title="解答"></a>解答</h3><p>普通的数据冲突和结构冲突已经在P5都解决了；</p><p>对于P6的话，主要是乘除单元导致的后续指令需要阻塞D级。样例如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mult $1, $2<br>mfhi $3   # 应在此处阻塞直到乘法结束<br></code></pre></td></tr></table></figure><h3 id="思考题8"><a href="#思考题8" class="headerlink" title="思考题8"></a>思考题8</h3><blockquote><p>如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证<strong>覆盖</strong>了所有需要测试的情况；如果你是<strong>完全随机</strong>生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了<strong>特殊的策略</strong>，比如构造连续数据冒险序列，请你描述一下你使用的策略如何<strong>结合了随机性</strong>达到强测的效果。</p></blockquote><h3 id="解答-7"><a href="#解答-7" class="headerlink" title="解答"></a>解答</h3><p><strong>我的测试策略：受限随机测试 (Constrained Random Testing)</strong></p><p>我的测试程序并不是“完全随机”的，而是基于<strong>约束</strong>和<strong>状态反馈</strong>的随机生成策略。完全随机生成的二进制码或汇编代码在流水线 CPU 测试中效率极低，因为大概率会产生无效指令、除以零异常或死循环，且很难触发生僻的流水线冲突逻辑。</p><p>为了保证覆盖率并达到强测效果，我采用了以下策略结合随机性：</p><ol><li><p><strong>寄存器池约束（构造数据冒险）：</strong></p><ul><li><strong>策略：</strong> 我没有从 0-31 号寄存器中均匀随机选择，而是维护了一个较小的<strong>“测试寄存器池”</strong>（<code>self.__test_regs</code>，例如只包含 14 个常用寄存器）。</li><li><strong>效果：</strong> 在生成指令（如 <code>add $t1, $t2, $t3</code>）时，源寄存器（rs, rt）和目的寄存器（rd）都从这个小池子里随机选取。这极大地提高了<strong>“读后写”（RAW）</strong>相关发生的概率。因为寄存器数量少，上一条指令刚写过的寄存器，很大概率会被紧接着的下一条或下下一条指令读取，从而高频触发 <strong>E级转发、M级转发</strong> 以及 <strong>Load-Use 暂停</strong> 逻辑。</li></ul></li><li><p><strong>指令模板与权重（覆盖功能部件）：</strong></p><ul><li><strong>策略：</strong> 我将指令分为 <code>cal_r</code> (算术), <code>load</code>, <code>store</code>, <code>branch</code>, <code>md</code> (乘除) 等类别。测试生成器会按类别随机选择，确保 ALU、DM、MDU 等部件都能被均匀覆盖，而不是随机生成一堆 <code>nop</code> 或全是 <code>add</code>。</li><li><strong>效果：</strong> 保证了每种类型的指令组合（如 <code>乘法</code> 后接 <code>mflo</code>，<code>load</code> 后接 <code>alu</code>）都能出现。</li></ul></li><li><p><strong>内存地址约束（防止访存越界）：</strong></p><ul><li><strong>策略：</strong> 在生成 <code>load/store</code> 指令时，不是随机生成 base 和 offset，而是先在 Python 内部维护一个 <code>grf</code> 镜像模型，根据基址寄存器当前的值，反向计算出一个合法的 <code>offset</code>，使得最终地址 <code>base + offset</code> 落在合法的数据存储区（0x0000-0x3000）内。</li><li><strong>效果：</strong> 避免了随机测试中常见的“地址越界”导致的评测失败，使得测试能专注于 CPU 的读写逻辑是否正确。</li></ul></li><li><p><strong>边界数据注入（ALU 鲁棒性）：</strong></p><ul><li><strong>策略：</strong> 专门设计了 <code>__set_inf_32bits</code> 等函数，在随机操作数中混入 <strong>0、最大正数、最小负数、-1</strong> 等特殊边界值。</li><li><strong>效果：</strong> 强测 ALU 的加法器溢出处理（虽然 P6 忽略溢出，但结果需正确截断）、符号扩展逻辑以及乘除法的特殊情况。</li></ul></li></ol><p><strong>总结：</strong><br>通过缩小寄存器选择范围来<strong>人为制造冲突</strong>，通过数学计算约束立即数来<strong>保证合法性</strong>，结合大规模的随机迭代（Test Times），既保证了测试的<strong>合法性</strong>，又最大化了<strong>流水线冲突</strong>的覆盖率。</p><h3 id="思考题9"><a href="#思考题9" class="headerlink" title="思考题9"></a>思考题9</h3><blockquote><p>[P5、P6 选做] 请评估我们给出的覆盖率分析模型的合理性，如有更好的方案，可一并提出。</p></blockquote><h3 id="解答-8"><a href="#解答-8" class="headerlink" title="解答"></a>解答</h3><h3 id="一、-覆盖率分析模型的合理性评估"><a href="#一、-覆盖率分析模型的合理性评估" class="headerlink" title="一、 覆盖率分析模型的合理性评估"></a>一、 覆盖率分析模型的合理性评估</h3><h4 id="1-优点与亮点"><a href="#1-优点与亮点" class="headerlink" title="1. 优点与亮点"></a>1. 优点与亮点</h4><ul><li><p><strong>指令分类（Abstraction）极其高效</strong></p><ul><li><strong>合理性：</strong> MIPS指令集很大，如果枚举所有 <code>add -&gt; sub</code>、<code>add -&gt; ori</code> 等具体指令对，组合空间将爆炸（$N^2$）。模型将指令按功能和数据通路特征归类（如 <code>cal_rr</code>, <code>load</code>, <code>store</code>），将 $N^2$ 的复杂度降低到了 $13 \times 13$ 的类别矩阵。</li><li><strong>意义：</strong> 这种抽象抓住了流水线冲突的本质：冲突取决于<strong>写入哪个寄存器、在哪个阶段写入、以及后序指令在哪个阶段读取</strong>，而不太取决于具体是 <code>add</code> 还是 <code>sub</code>。</li></ul></li><li><p><strong>“转发测试有效性”的引入是点睛之笔</strong></p><ul><li><strong>合理性：</strong> 仅仅构造出转发路径（如 E-&gt;D）是不够的。如果寄存器旧值（GRF中）和新值（转发值）相同，即使硬件转发功能损坏（导致读了旧值），测试程序也能跑通。模型明确要求“新旧值必须不同”，这有效防止了<strong>假阳性（False Positive）</strong>测试通过。</li><li><strong>意义：</strong> 强迫测试数据必须动态变化，不能全 0 或全 1，提高了对数据通路多路选择器（MUX）故障的检测能力。</li></ul></li><li><p><strong>元组化描述（Forwarding Quadruple / Blocking Triple）精确定义了冲突</strong></p><ul><li><strong>合理性：</strong><ul><li>转发四元组 <code>&lt;产, 消, 产级, 消级&gt;</code> 覆盖了所有可能的旁路路径。</li><li>阻塞三元组 <code>&lt;D指令, 阻塞源, 间隔&gt;</code> 覆盖了 Load-Use 冒险的不同距离（间隔 0 或 1 条指令）。</li></ul></li><li><strong>意义：</strong> 这种定义方式直接对应硬件设计中的 <code>Stall</code> 逻辑判断条件（<code>Tuse</code> vs <code>Tnew</code>）和转发逻辑判断条件（寄存器号相等且写使能），非常贴合硬件实现的物理本质。</li></ul></li><li><p><strong>评分公式设计的导向性很好</strong></p><ul><li><strong>合理性：</strong> 公式 $60 + 40 \times (k / K_{max})$ 是一个阶跃函数。只要覆盖了该类别（$k&gt;0$），起步就是 60 分。</li><li><strong>意义：</strong> 这鼓励学生优先进行<strong>广度优先搜索</strong>（覆盖所有冲突类型），而不是在某一种简单的冲突上（如 <code>add-&gt;add</code>）死磕。这符合验证工程的原则：先确保存在这个逻辑，再追求逻辑的完备性。</li></ul></li></ul><h4 id="2-潜在的不足与局限性"><a href="#2-潜在的不足与局限性" class="headerlink" title="2. 潜在的不足与局限性"></a>2. 潜在的不足与局限性</h4><ul><li><p><strong>数据值的覆盖率缺失（Data Value Coverage）</strong></p><ul><li><strong>问题：</strong> 该模型只关注“指令序列结构”，不关注“操作数的值”。例如，测试程序可能全是用正数运算，却没测试负数、0、最大整数等边界情况。</li><li><strong>后果：</strong> 无法检测 ALU 的功能错误（如符号扩展错误、溢出逻辑错误、特定算术操作错误）。</li></ul></li><li><p><strong>具体操作码的覆盖不足（Opcode Coverage）</strong></p><ul><li><strong>问题：</strong> <code>cal_rr</code> 包含了 <code>add</code>, <code>sub</code>, <code>and</code> 等。如果测试集只测了 <code>add -&gt; sub</code>，虽然覆盖了 <code>cal_rr -&gt; cal_rr</code> 这个类别，但可能 <code>xor</code> 指令的转发逻辑（比如 ALU Opcode 选择信号）有问题却没被测出来。</li><li><strong>后果：</strong> 可能会漏掉特定指令独有的控制信号 bug。</li></ul></li><li><p><strong>MDU 忙信号（Busy）阻塞的考量不足</strong></p><ul><li><strong>问题：</strong> 阻塞三元组定义中似乎主要针对 Load-Use 阻塞。P6 中 <code>mult/div</code> 引起的 Busy 阻塞（结构冒险/控制逻辑阻塞）是非常关键的。如果模型忽略了 MDU 的 Start/Busy 信号冲突覆盖，是不完整的。</li></ul></li><li><p><strong>按字节访存（P6 特性）的粒度不够</strong></p><ul><li><strong>问题：</strong> <code>store</code> 类包含了 <code>sw, sh, sb</code>。在 P6 中，<code>sb</code> 和 <code>sh</code> 涉及复杂的 <code>BE</code>（Byte Enable）逻辑和 <code>DE</code>（Data Extension）逻辑。仅覆盖 <code>sw</code> 的转发可能无法发现 <code>lb</code> 转发逻辑中的位截断错误。</li></ul></li></ul><hr><h3 id="二、-更好的方案与改进建议"><a href="#二、-更好的方案与改进建议" class="headerlink" title="二、 更好的方案与改进建议"></a>二、 更好的方案与改进建议</h3><p>针对上述不足，提出以下改进或补充方案：</p><h4 id="1-引入“数据翻转覆盖率”-Toggle-Coverage-Corner-Case"><a href="#1-引入“数据翻转覆盖率”-Toggle-Coverage-Corner-Case" class="headerlink" title="1. 引入“数据翻转覆盖率” (Toggle Coverage / Corner Case)"></a>1. 引入“数据翻转覆盖率” (Toggle Coverage / Corner Case)</h4><ul><li><strong>方案：</strong> 在评估有效转发时，不仅要求新旧值不同，还建议增加对数据位的监控。</li><li><strong>具体指标：</strong><ul><li><strong>全0/全1覆盖：</strong> 确保操作数出现过 <code>0x00000000</code> 和 <code>0xFFFFFFFF</code>。</li><li><strong>位翻转覆盖：</strong> 确保 32 位数据线上的每一位都在转发过程中发生过 <code>0-&gt;1</code> 和 <code>1-&gt;0</code> 的跳变。这能检测总线粘连故障。</li></ul></li></ul><h4 id="2-细化指令子类与-MDU-专项覆盖"><a href="#2-细化指令子类与-MDU-专项覆盖" class="headerlink" title="2. 细化指令子类与 MDU 专项覆盖"></a>2. 细化指令子类与 MDU 专项覆盖</h4><ul><li><strong>方案：</strong><ul><li><strong>Load/Store 细分：</strong> 将 <code>load</code> 分为 <code>load_word</code> (lw) 和 <code>load_subword</code> (lb/lh)，因为后者的转发/扩展逻辑更易出错。</li><li><strong>MDU 状态覆盖：</strong> 增加一种“MDU 阻塞元组”，专门统计 <code>&lt;乘除指令, 读/写HI_LO指令, 间隔时间&gt;</code>。</li><li><strong>评测标准：</strong> 必须覆盖 <code>Busy</code> 信号拉高时尝试读取 HI/LO 寄存器的情况，以及连续乘除法指令的覆盖。</li></ul></li></ul><h4 id="3-增强“指令组合”的颗粒度-Cross-Coverage"><a href="#3-增强“指令组合”的颗粒度-Cross-Coverage" class="headerlink" title="3. 增强“指令组合”的颗粒度 (Cross-Coverage)"></a>3. 增强“指令组合”的颗粒度 (Cross-Coverage)</h4><ul><li><strong>方案：</strong> 在现有的类别得分基础上，增加“操作码遍历要求”。</li><li><strong>具体规则：</strong> 对于类别 <code>&lt;cal_rr, cal_rr&gt;</code>，虽然不要求 $12 \times 12$ 种全排列，但要求类别内的<strong>每一个操作码</strong>（如 <code>add</code>, <code>sub</code>…）至少作为生产者出现一次，且至少作为消费者出现一次。</li><li><strong>修正公式：</strong> 如果某类指令未被遍历完全，即使 $k$ 值很高，也给予一定的分数惩罚。</li></ul><h4 id="4-增加“连续冲突”检测-Chain-Hazards"><a href="#4-增加“连续冲突”检测-Chain-Hazards" class="headerlink" title="4. 增加“连续冲突”检测 (Chain Hazards)"></a>4. 增加“连续冲突”检测 (Chain Hazards)</h4><ul><li><strong>方案：</strong> 目前的模型主要关注“一对一”的冲突。建议增加对 <strong>Forwarding Chain</strong> 的评估。</li><li><strong>场景：</strong> <code>A -&gt; B -&gt; C</code>。<ul><li>指令 A 产生数据。</li><li>指令 B 使用 A 的数据（转发 1），产生新数据。</li><li>指令 C 使用 B 的数据（转发 2）。</li></ul></li><li><strong>意义：</strong> 这种连续紧密的转发对流水线寄存器的时序压力最大，也是验证转发逻辑优先级（如 EX 级转发优于 MEM 级转发）的关键场景。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CO课下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>CO课下</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P5课下-Verilog五级全速流水线CPU</title>
    <link href="/posts/P5%E8%AF%BE%E4%B8%8B-Verilog%E4%BA%94%E7%BA%A7%E5%85%A8%E9%80%9F%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/"/>
    <url>/posts/P5%E8%AF%BE%E4%B8%8B-Verilog%E4%BA%94%E7%BA%A7%E5%85%A8%E9%80%9F%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/</url>
    
    <content type="html"><![CDATA[<h1 id="CO设计文档—Verilog五级全速流水线CPU"><a href="#CO设计文档—Verilog五级全速流水线CPU" class="headerlink" title="CO设计文档—Verilog五级全速流水线CPU"></a>CO设计文档—Verilog五级全速流水线CPU</h1><h2 id="总体设计概述"><a href="#总体设计概述" class="headerlink" title="总体设计概述"></a>总体设计概述</h2><p>要求实现的指令集为<code>add, sub, ori, lw, sw, beq, lui, jal, jr, nop</code>。<strong>支持延迟槽</strong>。</p><p>整体结构如下图所示：</p><img src="/posts/P5%E8%AF%BE%E4%B8%8B-Verilog%E4%BA%94%E7%BA%A7%E5%85%A8%E9%80%9F%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/P5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="P5示意图"><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li>对于元件的文件命名，均为<code>元件英文简称</code>，例如<code>GRF.v</code>，<code>ALU.v</code>等，实例化时命名为<code>_小写英文名</code>，例如<code>_alu</code>，<code>_grf</code>等</li><li>对于流水线寄存器文件命名为<code>两边的流水线层级reg</code>，例如<code>FDreg.v</code>，<code>DEreg.v</code>，实例化时命名相同。</li><li>每一级的控制信号和临时的<code>wire</code>均以本级的名称开头，如<code>E_ALUOp</code>，<code>M_DMwr</code>等</li><li>在流水线中参与流水的信息遵从以下约定（以D级为例）<ul><li><code>PC</code>和<code>Instr</code>命名以流水线层级开头，如<code>D_PC</code>，<code>D_Instr</code></li><li>寄存器地址分别为<code>D_A1</code>，<code>D_A3</code>，读出数据为<code>D_RD1</code>，<code>D_RD2</code></li><li>转发后得到的修复的寄存器数据（直接读取也视为一种转发）记作<code>D_fixedRD1</code>，<code>D_fixedRD2</code></li><li>即将写入的寄存器地址为<code>W_A3</code>，即将写入的数据记作<code>W_WD</code>，选择信号为<code>W_WDSel</code></li></ul></li></ul><p>下面将按照流水线层级逐一分析各个单元</p><h3 id="F级-Fetch-取指令"><a href="#F级-Fetch-取指令" class="headerlink" title="F级(Fetch/取指令)"></a>F级(Fetch/取指令)</h3><ul><li>本级没有转发，阻塞时需要取消<code>PC</code>写使能</li><li>本级的输入有来自D级的<code>NPC</code>，本级的输出是<code>F_PC</code>和<code>F_Instr</code>，两者需要参与流水线流水</li></ul><h4 id="IFU（取指单元）"><a href="#IFU（取指单元）" class="headerlink" title="IFU（取指单元）"></a>IFU（取指单元）</h4><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>NPC[31:0]</td><td>输入</td><td>待写入PC的指令地址</td></tr><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>PC_en</td><td>输入</td><td>PC的写使能</td></tr><tr><td>PC[31:0]</td><td>输出</td><td>当前指令地址</td></tr><tr><td>Instr[31:0]</td><td>输出</td><td>32位的指令值</td></tr></tbody></table></div><h4 id="NPC（次地址计算单元）"><a href="#NPC（次地址计算单元）" class="headerlink" title="NPC（次地址计算单元）"></a>NPC（次地址计算单元）</h4><p>把<code>beq</code>是否执行的判断交给了D级的<code>CMP</code>，根据输入信号<code>zero</code>和控制信号<code>NPCop</code>判断是否跳转</p><p>其实<code>NPC</code>横跨了F级和D级两级，我们只输入<code>F_PC</code>即可，因为事实上<code>F_PC=D_PC+4</code>，<code>beq</code>转发的<code>D_PC+4+offset=F_PC+offset</code>。<code>F_PC+8</code>则用于流水<code>PC</code>值，后面<code>jal</code>转发的时候用</p><p>我们一路携带<code>PC+8</code>到各级，便于转发。</p><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>F_PC[31:0]</td><td>输入</td><td>32位输入当前F级地址</td></tr><tr><td>zero</td><td>输入</td><td>指示b类型指令是否跳转</td></tr><tr><td>NPCop[2:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>grf[31:0]</td><td>输入</td><td><strong>处理完转发后</strong><code>$rs</code>寄存器保存的32位地址</td></tr><tr><td>NPC[31:0]</td><td>输出</td><td>32位输出次地址</td></tr></tbody></table></div><h5 id="控制信号说明"><a href="#控制信号说明" class="headerlink" title="控制信号说明"></a>控制信号说明</h5><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>000</td><td><code>NPC=PC+4</code></td></tr><tr><td>001</td><td>执行<code>beq</code>等b类指令</td></tr><tr><td>110</td><td>执行<code>j</code>，<code>jal</code>指令</td></tr><tr><td>111</td><td>执行<code>jalr</code>，<code>jr</code>指令</td></tr></tbody></table></div><h3 id="D级-Decode-译码"><a href="#D级-Decode-译码" class="headerlink" title="D级(Decode/译码)"></a>D级(Decode/译码)</h3><ul><li>本级需要处理来自E, M, W级的转发，转发信号为<code>EPCplus8</code>，<code>MPCplus8</code>，<code>M_ALUans</code>，<code>W_WD</code>，优先级按顺序排列，最低为原寄存器读出的值<code>D_RD1</code>，<code>D_RD2</code>。</li><li>本级的输入是来自F级的<code>PC</code>和<code>Instr</code>，输出是<code>D_fixedRD1</code>，<code>D_fixedRD2</code>，<code>D_ext32</code>，<code>D_PC</code>和<code>D_Instr</code>，还有输出到F级的<code>NPC</code>，<code>A3</code>和<code>PCplus8</code>记得一路带着。</li><li>本级元件较多，比较复杂</li></ul><h4 id="FD-REG（F-D级流水线寄存器）"><a href="#FD-REG（F-D级流水线寄存器）" class="headerlink" title="FD_REG（F/D级流水线寄存器）"></a>FD_REG（F/D级流水线寄存器）</h4><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>FD_clear</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>F_PC</td><td>输入</td><td>F级PC的指令地址</td></tr><tr><td>F_Instr[31:0]</td><td>输入</td><td>32位的指令值</td></tr><tr><td>FPCplus8</td><td>输入</td><td>F_PC+8</td></tr><tr><td>D_PC</td><td>输出</td><td>D级PC的指令地址</td></tr><tr><td>D_Instr[31:0]</td><td>输出</td><td>32位的指令值</td></tr><tr><td>DPCplus8</td><td>输出</td><td><code>jal</code>指令要存入<code>$ra</code>的值</td></tr></tbody></table></div><h4 id="D-GRF（寄存器堆）"><a href="#D-GRF（寄存器堆）" class="headerlink" title="D_GRF（寄存器堆）"></a>D_GRF（寄存器堆）</h4><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A1[4:0]</td><td>输入</td><td>5位地址输入信号，将其储存的数据读出到RD1</td></tr><tr><td>A2[4:0]</td><td>输入</td><td>5位地址输入信号，将其储存的数据读出到RD2</td></tr><tr><td>A3[4:0]</td><td>输入</td><td>5位地址输入信号，将其作为写入数据的目标寄存器</td></tr><tr><td>RD1[31:0]</td><td>输出</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr><td>RD2[31:0]</td><td>输出</td><td>输出A2指定的寄存器中的32位数据</td></tr><tr><td>WD[31:0]</td><td>输入</td><td>32位数据输入信号</td></tr><tr><td>GRFwe</td><td>输入</td><td>写使能</td></tr><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>异步复位信号，将32个寄存器中的数据清零；1：复位；0：无效</td></tr></tbody></table></div><h5 id="控制信号说明-1"><a href="#控制信号说明-1" class="headerlink" title="控制信号说明"></a>控制信号说明</h5><p><strong><code>D_A3slt</code></strong></p><p>从<code>rt</code>字段，<code>rd</code>字段，0𝑥1𝑓中进行选择，与P4相同，但与P4不同的是，我们A3信号需要一直带着走到W级才写寄存器。寄存器所有与<strong>写入</strong>有关的端口都应连<strong>W级信号</strong>！包括<code>W_GRFwe</code>，<code>W_A3</code>，<code>W_WD</code>。P5采用分布式译码，<code>D_A3slt</code>在<code>D_ctrl</code>模块译出，<code>W_GRFwe</code>在W级译出，<code>W_A3</code>从D级选出<code>D_A3</code>后一路跟着流水，<code>W_WD</code>是在W级通过选择而得到的。</p><h4 id="D-EXT（位扩展）"><a href="#D-EXT（位扩展）" class="headerlink" title="D_EXT（位扩展）"></a>D_EXT（位扩展）</h4><p>将16位二进制数进行零扩展或符号扩展到32位</p><p><strong>控制信号说明</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>0</td><td>零扩展</td></tr><tr><td>1</td><td>符号扩展</td></tr></tbody></table></div><h4 id="D-CMP（比较器）"><a href="#D-CMP（比较器）" class="headerlink" title="D_CMP（比较器）"></a>D_CMP（比较器）</h4><p>把原来ALU中比较值是否相等的运算移到了CMP里面，去指导<code>beq</code>这一类型的指令是否跳转</p><p>控制信号目前只有<code>CMP_beq=0</code>，未来可以扩展</p><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>rs[31:0]</td><td>输入</td><td><strong>处理完转发后</strong><code>$rs</code>寄存器的值</td></tr><tr><td>rt[31:0]</td><td>输入</td><td><strong>处理完转发后</strong><code>$rt</code>寄存器的值</td></tr><tr><td>CMPOp[2:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>zero</td><td>输出</td><td>指示是否跳转，输入<code>NPC</code></td></tr></tbody></table></div><h3 id="E级-Execute-执行"><a href="#E级-Execute-执行" class="headerlink" title="E级(Execute/执行)"></a>E级(Execute/执行)</h3><h4 id="DE-REG（D-E级流水线寄存器）"><a href="#DE-REG（D-E级流水线寄存器）" class="headerlink" title="DE_REG（D/E级流水线寄存器）"></a>DE_REG（D/E级流水线寄存器）</h4><ul><li>输入<code>D_PC,D_Instr,D_ext32</code>，此外上一级修正后的<code>D_fixedRD1</code>和<code>D_fixedRD2</code>的值也要参与流水，，<strong>这是由于指令序列<code>sw, nop, add</code>的存在，<code>sw</code>在M级需要使用<code>$rt</code>的数据，但是在E级不会再进行转发（因为在D级已经转发过了），因此需要让正确的<code>$rt</code>值参与流水</strong></li><li>输出<code>E_PC,E_Instr,E_ext32,E_RD1,E_RD2</code>，<code>ALU</code>需要这些信息</li></ul><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>DE_clear</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>D_PC[31:0]</td><td>输入</td><td>D级PC的指令地址</td></tr><tr><td>D_Instr[31:0]</td><td>输入</td><td>32位的指令值</td></tr><tr><td>D_ext32[31:0]</td><td>输入</td><td>16位立即数经<code>EXT</code>扩展的结果</td></tr><tr><td>D_RD1[31:0]</td><td>输入</td><td>32位的寄存器数据</td></tr><tr><td>D_RD2[31:0]</td><td>输入</td><td>32位的寄存器数据</td></tr><tr><td>DPCplus8</td><td>输入</td><td>PC+8</td></tr><tr><td>E_PC[31:0]</td><td>输出</td><td>E级PC的指令地址</td></tr><tr><td>E_Instr[31:0]</td><td>输出</td><td>32位的指令值</td></tr><tr><td>E_ext32[31:0]</td><td>输出</td><td>16位立即数经<code>EXT</code>扩展的结果</td></tr><tr><td>E_RD1[31:0]</td><td>输出</td><td>32位的寄存器数据</td></tr><tr><td>E_RD2[31:0]</td><td>输出</td><td>32位的寄存器数据</td></tr><tr><td>EPCplus8</td><td>输出</td><td>PC+8</td></tr></tbody></table></div><h4 id="E-ALU（算术逻辑单元）"><a href="#E-ALU（算术逻辑单元）" class="headerlink" title="E_ALU（算术逻辑单元）"></a>E_ALU（算术逻辑单元）</h4><ul><li>相比于P4，ALU变化不大，仅仅是去掉了𝑧𝑒𝑟𝑜输出，给了<code>CMP</code>模块。</li></ul><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>输入</td><td>32位输入运算数A</td></tr><tr><td>B[31:0]</td><td>输入</td><td>32位输入运算数B</td></tr><tr><td>ALUOp[4:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>C[31:0]</td><td>输出</td><td>32位输出运算结果</td></tr></tbody></table></div><p><strong>控制信号说明</strong></p><p><strong>1. ALUOp</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>000</td><td>执行加法运算</td></tr><tr><td>001</td><td>执行减法运算</td></tr><tr><td>010</td><td>执行逻辑与运算</td></tr><tr><td>011</td><td>执行逻辑或运算</td></tr><tr><td>100</td><td>执行<code>lui</code>指令</td></tr></tbody></table></div><p><strong>2. ALUASel</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>0</td><td>选修正后的<code>E_fixedRD1</code></td></tr><tr><td>1</td><td>保留</td></tr></tbody></table></div><p><strong>3. ALUBSel</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>0</td><td>选修正后的<code>E_fixedRD2</code></td></tr><tr><td>1</td><td>选择立即数进行运算</td></tr></tbody></table></div><h3 id="M级-Memory-储存"><a href="#M级-Memory-储存" class="headerlink" title="M级(Memory/储存)"></a>M级(Memory/储存)</h3><ul><li>输入<code>E_PC,E_Instr</code>，此外上一级的<code>E_ALUAns</code>参与流水，即<code>E_ALUAns</code>需要参与流水，<strong>这是因为<code>ALUAns</code>是待写入或读取的内存地址</strong>，<strong>另外，上一级的修正后的rt值需要参与流水</strong>，因此还需要输入<code>E_fixedRD2</code>，<strong>这是因为<code>sw</code>指令会向内存中写入<code>$rt</code>的数据</strong></li><li>输出<code>M_PC,M_Instr,M_ALUAns,M_DMrd</code></li></ul><h4 id="EM-REG（E-M级流水线寄存器）"><a href="#EM-REG（E-M级流水线寄存器）" class="headerlink" title="EM_REG（E/M级流水线寄存器）"></a>EM_REG（E/M级流水线寄存器）</h4><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>EM_clear</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>E_PC[31:0]</td><td>输入</td><td>E级PC的指令地址</td></tr><tr><td>E_Instr[31:0]</td><td>输入</td><td>32位的指令值</td></tr><tr><td>E_fixedRD2[31:0]</td><td>输入</td><td>32位的寄存器数据</td></tr><tr><td>E_ALUAns[31:0]</td><td>输入</td><td>32位的ALU运算结果</td></tr><tr><td>EPCplus8</td><td>输入</td><td>PC+8</td></tr><tr><td>M_PC[31:0]</td><td>输出</td><td>M级PC的指令地址</td></tr><tr><td>M_Instr[31:0]</td><td>输出</td><td>32位的指令值</td></tr><tr><td>M_ALUAns[31:0]</td><td>输出</td><td>32位的ALU运算结果</td></tr><tr><td>M_RD2[31:0]</td><td>输出</td><td>32位的寄存器数据</td></tr><tr><td>MPCplus8</td><td>输出</td><td>PC+8</td></tr></tbody></table></div><h4 id="M-DM（数据储存器）"><a href="#M-DM（数据储存器）" class="headerlink" title="M_DM（数据储存器）"></a>M_DM（数据储存器）</h4><ul><li><code>DM</code>与P4基本相同</li></ul><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>Addr[31:0]</td><td>输入</td><td>待操作的内存地址</td></tr><tr><td>WD[31:0]</td><td>输入</td><td>待写入内存的值</td></tr><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>异步复位信号</td></tr><tr><td>DMwr</td><td>输入</td><td>写使能信号；1：写入有效；0：写入无效</td></tr><tr><td>RD[31:0]</td><td>输出</td><td>输入地址指向的内存中储存的值</td></tr></tbody></table></div><h3 id="W级-Write-回写"><a href="#W级-Write-回写" class="headerlink" title="W级(Write/回写)"></a>W级(Write/回写)</h3><ul><li>W级事实上与D级重合了，但是仍然需要处理向E,M级的转发</li></ul><h4 id="MW-REG（M-W级流水线寄存器）"><a href="#MW-REG（M-W级流水线寄存器）" class="headerlink" title="MW_REG（M/W级流水线寄存器）"></a>MW_REG（M/W级流水线寄存器）</h4><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>MW_clear</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>M_PC[31:0]</td><td>输入</td><td>M级PC的指令地址</td></tr><tr><td>M_Instr[31:0]</td><td>输入</td><td>32位的指令值</td></tr><tr><td>M_DMRD[31:0]</td><td>输入</td><td>从内存中读取的值</td></tr><tr><td>M_ALUAns[31:0]</td><td>输入</td><td>32位的ALU运算结果</td></tr><tr><td>MPCplus8</td><td>输入</td><td>PC+8</td></tr><tr><td>W_PC[31:0]</td><td>输出</td><td>W级PC的指令地址</td></tr><tr><td>W_Instr[31:0]</td><td>输出</td><td>32位的指令值</td></tr><tr><td>W_DMrd[31:0]</td><td>输出</td><td>从内存中读取的值</td></tr><tr><td>W_ALUAns[31:0]</td><td>输出</td><td>32位的ALU运算结果</td></tr><tr><td>WPCplus8</td><td>输出</td><td>PC+8</td></tr></tbody></table></div><h3 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h3><p>我采用分布式译码，每一级实例化一个控制器，对于所有<code>CTRL</code>均有：</p><div class="table-container"><table><thead><tr><th>指令</th><th>opcode</th><th>funct</th><th>NPCOp</th><th>WRA3Sel</th><th>WDSel</th><th>EXTOp</th><th>WE</th><th>ALUASel</th><th>ALUBSel</th><th>ALUOp</th><th>DMWr</th></tr></thead><tbody><tr><td><strong>add</strong></td><td>000000</td><td>100000</td><td>000</td><td>01</td><td>00</td><td>X</td><td>1</td><td>0</td><td>0</td><td>000</td><td>0</td></tr><tr><td><strong>sub</strong></td><td>000000</td><td>100010</td><td>000</td><td>01</td><td>00</td><td>X</td><td>1</td><td>0</td><td>0</td><td>001</td><td>0</td></tr><tr><td><strong>ori</strong></td><td>001101</td><td></td><td>000</td><td>00</td><td>00</td><td>0</td><td>1</td><td>0</td><td>1</td><td>011</td><td>0</td></tr><tr><td><strong>lw</strong></td><td>100011</td><td></td><td>000</td><td>00</td><td>01</td><td>1</td><td>1</td><td>0</td><td>1</td><td>000</td><td>0</td></tr><tr><td><strong>sw</strong></td><td>101011</td><td></td><td>000</td><td>00</td><td>01</td><td>1</td><td>0</td><td>0</td><td>1</td><td>000</td><td>1</td></tr><tr><td><strong>beq</strong></td><td>000100</td><td></td><td>001</td><td>X</td><td>X</td><td>1</td><td>0</td><td>0</td><td>0</td><td>001</td><td>0</td></tr><tr><td><strong>lui</strong></td><td>001111</td><td></td><td>000</td><td>00</td><td>00</td><td>X</td><td>1</td><td>0</td><td>1</td><td>100</td><td>0</td></tr><tr><td><strong>jal</strong></td><td>000011</td><td></td><td>110</td><td>10</td><td>10</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td><strong>jr</strong></td><td>000000</td><td>001000</td><td>111</td><td>00</td><td>00</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><p>对于不同级的<code>CTRL</code>，我们只需连出那一级所需控制信号即可。</p><p>D级：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] D_A3slt;<br><span class="hljs-attribute">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] D_NPCop;<br><span class="hljs-attribute">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] D_CMPop;<br><span class="hljs-attribute">wire</span> D_EXTop;<br><span class="hljs-attribute">wire</span> D_GRFwe;<br><span class="hljs-attribute">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] D_t_use_rs;<br><span class="hljs-attribute">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] D_t_use_rt;<br><span class="hljs-attribute">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] D_t_new;<br></code></pre></td></tr></table></figure><p>E级：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">wire</span> E_ALUAslt;<br><span class="hljs-keyword">wire</span> E_ALUBslt;<br><span class="hljs-keyword">wire</span> E_GRFwe;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] E_ALUop;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] E_t_use_rs;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] E_t_use_rt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] E_t_new;<br></code></pre></td></tr></table></figure><p>M级：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">wire</span> M_DMwr;<br><span class="hljs-keyword">wire</span> M_GRFwe;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] M_t_use_rs;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] M_t_use_rt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] M_t_new;<br></code></pre></td></tr></table></figure><p>W级：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] W_WDslt;<br><span class="hljs-keyword">wire</span> W_GRFwe;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] W_t_use_rs;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] W_t_use_rt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] W_t_new;<br></code></pre></td></tr></table></figure><h2 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h2><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>采用暴力转发和AT模型，注意由于T_new和在哪一级有关，我们得让这一级的CTRL知道它处在哪一级，于是我给控制模块传入一个𝑡，𝑡=0,1,2,3分别代表D,E,M,W级。这样，以add的T_new为例，就可以如下计算：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">T_new</span>=(t&lt;=<span class="hljs-number">4</span><span class="hljs-string">&#x27;h2)? (4&#x27;</span>h2-t) : <span class="hljs-number">0</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><img src="/posts/P5%E8%AF%BE%E4%B8%8B-Verilog%E4%BA%94%E7%BA%A7%E5%85%A8%E9%80%9F%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/e27b5c863cead7f2912b8885e7d38375.png" class="" title="e27b5c863cead7f2912b8885e7d38375"><img src="/posts/P5%E8%AF%BE%E4%B8%8B-Verilog%E4%BA%94%E7%BA%A7%E5%85%A8%E9%80%9F%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/d722038c84b1b2f3eabc92416978bb1b.png" class="" title="d722038c84b1b2f3eabc92416978bb1b"><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p><code>T_use&lt;T_new</code>时阻塞。需要以下这些条件同时成立：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">A3 !<span class="hljs-punctuation">=</span> <span class="hljs-number">5</span>&#x27;b<span class="hljs-number">0000</span>0 &amp; rs == A3 &amp; T_use_rs != 4&#x27;hf <span class="hljs-meta">&amp; T_new != 4&#x27;h0 &amp; D_T_use_rs &lt; E_T_new</span><br></code></pre></td></tr></table></figure><p>对于每一级，就加上级号，如<code>D_A3</code>。</p><p>得到阻塞信号后，<code>PC</code>，<code>FDreg</code>写使能赋0，<code>DEreg</code>清空。</p><h3 id="有关加指令"><a href="#有关加指令" class="headerlink" title="有关加指令"></a>有关加指令</h3><p>加指令有几种类型，一般是一道R型的普通运算，一道<code>beq</code>类并清空延迟槽，一道<code>lw</code>类并卡时间。</p><h4 id="1-R型运算指令"><a href="#1-R型运算指令" class="headerlink" title="1.R型运算指令"></a>1.R型运算指令</h4><p>和P4单周期CPU没有什么本质区别，主要改动Ctrl模块和ALU模块即可。</p><h4 id="2-类beq型清空延迟槽指令"><a href="#2-类beq型清空延迟槽指令" class="headerlink" title="2.类beq型清空延迟槽指令"></a>2.类<code>beq</code>型清空延迟槽指令</h4><p>以P5_L2_2022的<code>bonall</code>指令为例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">I:<br><br>target_offset ← <span class="hljs-built_in">sign_extend</span>(<span class="hljs-attribute">offset</span>||<span class="hljs-number">02</span>)<br><br>Condition ← GPR<span class="hljs-selector-attr">[rs]</span> + GPR<span class="hljs-selector-attr">[rt]</span> = <span class="hljs-number">032</span><br><br>GPR<span class="hljs-selector-attr">[31]</span> ← PC + <span class="hljs-number">8</span><br><br>I+<span class="hljs-number">1</span>:<br><br>If condition then<br><br>    PC ← PC + target_offset<br><br><span class="hljs-keyword">else</span><br><br>    <span class="hljs-built_in">NullifyCurrentInstruction</span>()<br><br>endif<br></code></pre></td></tr></table></figure><p>需要按如下步骤修改：</p><ol><li><p>修改CMP模块，加上一个输出端口（如<code>opposite</code>)示意现在是否满足跳转条件；同时应用上<code>CMPop</code>，虽然理论上这是一个冗余设计，因为你并不需要用<code>CMPop</code>作为MUX，是输出到一个新的端口，但这是一种保护性的设计，对于长期维护可能很乱，但是课上只要加一条指令，就非常让人安心。</p></li><li><p>在CTRL模块中加入该指令。指令驱动型的最大优势在此处一览无余。一般而言，我们直接将<code>beq</code>指令下的信号复制过来即可，再扫一遍有没有需要变化的，比如如果这个指令需要写入，<code>A3slt</code>，<code>WDslt</code>，<code>GRFwe</code>就都得变。</p></li><li><p>在<code>NPCop</code>中添加<code>input opposite</code>，并在assign语句的三目运算符下增加判断，一般形如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">(<span class="hljs-attribute">NPCop</span>==3&#x27;b010 &amp;&amp; !opposite) ? PC4:<br>(<span class="hljs-attribute">NPCop</span>==3&#x27;b010 &amp;&amp; opposite) ? F_PC+offsetbeq:<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>在顶层连线。将1中端口加上流水线级别设出来（如<code>D_opposite</code>），连入<code>NPC</code>，<code>CMP</code>。有的时候是否写入寄存器、写入哪个寄存器和这个判断信号有关，那么还需连入CTRL</p></li><li><p>最重要也是最容易忘的一步！！！加入<code>PC+8</code>硬编码！否则不会转发！</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> E_isPCplus8 = (E_Instr[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] === <span class="hljs-number">6&#x27;b000011</span> || E_Instr[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>]==<span class="hljs-number">6&#x27;b011001</span>);<br><span class="hljs-keyword">assign</span> M_isPCplus8 = (M_Instr[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] === <span class="hljs-number">6&#x27;b000011</span> || M_Instr[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>]==<span class="hljs-number">6&#x27;b011001</span>);<br></code></pre></td></tr></table></figure></li><li><p>如果需要增加寄存器接口（如<code>D_RD2</code>)，请务必接入转发后的数据，如<code>D_fixedRD2</code>.</p></li><li><p>如果需要作为<code>input</code>传入各级CTRL，可能要把这个<code>condition</code>信号流水。一般出现于<code>GRFwe</code>不定的时候。</p></li></ol><h4 id="3-类lw型指令与时间优化"><a href="#3-类lw型指令与时间优化" class="headerlink" title="3.类lw型指令与时间优化"></a>3.类<code>lw</code>型指令与时间优化</h4><p>这是最困难的一类题！我们以推荐题中最难的L5_2022为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">vAddr ← sign_extend(offset) + GPR[base]<br><br>pAddr ← vAddr31...2 || 02<br><br>memword ← memory[pAddr]<br><br>bit ← vAddr1<br><br>def:<br><br>countOne(x): x 中 1 的个数<br><br>countZero(x): x 中 0 的个数<br><br>memHalf ← memword15+16*bit ..16*bit<br><br>Condition ← countZero(memHalf) ≤ countOne(memHalf)<br><br>if Condition:<br><br>GPR[rt] ← sign_extend(memHalf)<br><br>else:<br><br>GPR[31] ← PC + 4<br><br>end if<br></code></pre></td></tr></table></figure><p>首先，因为它是取出字（半字、字节）进行操作，那么我们得到操作数至少在<code>dm</code>模块才能出来。于是我们有两个选择，要么在<code>dm</code>模块加一个输出端口，在<code>dm</code>内部算出需要的结果；要么在顶层直接计算。</p><ol><li>如果使用前者，我们将新结果放入<code>DMans</code>，0数是否小于1数放入<code>condition</code>端口，相当于给dm模块加了两个输出。</li><li>将<code>DMans</code>，<code>condition</code>从M级开始参与流水。</li><li>在CTRL模块内增加该指令，先默认其选用rt寄存器，并写入DMans，即<code>`A3slt=0</code>，<code>WDslt=3</code>，注意WD是多加了一个接口的。</li><li>在顶层连线后，修正M级的A3和W级的WD，并将所有用到<code>M_A3</code>的地方修正。</li><li>阻塞模块，遇到E级是该指令且<code>D_rs</code>或<code>D_rt</code>等于<code>E_A3</code>或31号寄存器时阻塞</li></ol><p>注意以下可能出bug的地方：</p><ul><li>注意A3在M级就修正，而WD直接在选择端口加一个硬编码即可。</li><li>阻塞是阻塞E级！传入<code>E_islwer</code>之类的</li><li>注意CTRL可能不一定能照抄，比如会用到rt之类的。</li></ul><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a><strong>测试方案</strong></h2><p>本人采用Python自动生成指令程序然后手动复制进MARS汇编再复制进code.txt进行对拍。</p><p>需要注意以下几点：</p><ul><li>指令数不能太多，否则MARS汇编不出来；我选择在800-1000条之间随机；</li><li><code>lw</code>，<code>sw</code>要尽可能缩小存储地址范围，提高命中率，避免“存进去的都取不到”；</li><li><code>jr</code>指令的生成。正常来说，在数据生成的过程中，会出现<code>jr $1</code>这种数据，而$1存了个很大的数，一下就跳到很远的没有指令处了。我使用两种方式生成<code>jr</code>：一种和<code>jal</code>配对，在<code>jal</code>跳完所在的指令后面多少行生成<code>jr $31</code>；第二种是和赋值语句配对，<code>jr $x</code>前绑定<code>add sub lui ori</code>之一算出<code>$x</code>，满足$x在当前指令地址-最后一条指令地址之间。</li><li>注意字对齐</li><li>限制寄存器范围，避免使用编译器需要使用的特殊寄存器，也能提升命中率。</li><li>立即数范围不超过16位（我取的8位），以免被当成伪指令汇编成多条，出现我们没有实现的<code>addu</code>等</li><li>分支测试，生成<code>label_i</code>这种标签供跳转。</li></ul><p>Python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> struct<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PipelineTestGenerator</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 指令集定义</span><br>        <span class="hljs-variable language_">self</span>.instructions = [<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;sub&#x27;</span>, <span class="hljs-string">&#x27;ori&#x27;</span>, <span class="hljs-string">&#x27;lw&#x27;</span>, <span class="hljs-string">&#x27;sw&#x27;</span>, <span class="hljs-string">&#x27;beq&#x27;</span>, <span class="hljs-string">&#x27;lui&#x27;</span>, <span class="hljs-string">&#x27;jal&#x27;</span>, <span class="hljs-string">&#x27;jr&#x27;</span>, <span class="hljs-string">&#x27;nop&#x27;</span>]<br><br>        <span class="hljs-comment"># 存储器限制</span><br>        <span class="hljs-variable language_">self</span>.im_start = <span class="hljs-number">0x00003000</span><br>        <span class="hljs-variable language_">self</span>.im_size = <span class="hljs-number">1024</span>  <span class="hljs-comment"># 限制为1024条指令</span><br>        <span class="hljs-variable language_">self</span>.dm_start = <span class="hljs-number">0x00000000</span><br>        <span class="hljs-variable language_">self</span>.dm_size = <span class="hljs-number">3072</span>  <span class="hljs-comment"># 12KiB</span><br><br>        <span class="hljs-comment"># 寄存器定义</span><br>        <span class="hljs-variable language_">self</span>.registers = [<span class="hljs-string">f&#x27;$<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>)]<br><br>        <span class="hljs-comment"># 限制的寄存器范围（避免使用特殊寄存器）</span><br>        <span class="hljs-variable language_">self</span>.data_regs = [<span class="hljs-string">f&#x27;$<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">26</span>)]  <span class="hljs-comment"># $1-$25</span><br>        <span class="hljs-variable language_">self</span>.temp_regs = [<span class="hljs-string">f&#x27;$<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>, <span class="hljs-number">16</span>)]  <span class="hljs-comment"># $8-$15 作为临时寄存器</span><br><br>        <span class="hljs-comment"># 数据地址范围限制（为了增加lw/sw命中概率）</span><br>        <span class="hljs-variable language_">self</span>.data_addr_range = <span class="hljs-built_in">range</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-number">0x0100</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment"># 限制在256字节范围内</span><br><br>        <span class="hljs-comment"># 分支地址范围</span><br>        <span class="hljs-variable language_">self</span>.branch_range = <span class="hljs-built_in">range</span>(-<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment"># 缩小分支偏移范围</span><br><br>        <span class="hljs-comment"># 立即数范围</span><br>        <span class="hljs-variable language_">self</span>.imm_range = <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>)  <span class="hljs-comment"># 8位立即数</span><br><br>        <span class="hljs-comment"># 测试序列计数器</span><br>        <span class="hljs-variable language_">self</span>.test_count = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.label_count = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.func_count = <span class="hljs-number">0</span><br><br>        <span class="hljs-comment"># 已生成的指令计数</span><br>        <span class="hljs-variable language_">self</span>.generated_count = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.max_instructions = random.randint(<span class="hljs-number">800</span>, <span class="hljs-number">1000</span>)  <span class="hljs-comment"># 在800-1000条之间随机</span><br><br>        <span class="hljs-comment"># 记录函数位置信息</span><br>        <span class="hljs-variable language_">self</span>.func_locations = &#123;&#125;  <span class="hljs-comment"># &#123;func_name: (start_index, end_index)&#125;</span><br>        <span class="hljs-variable language_">self</span>.current_func = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 记录指令位置</span><br>        <span class="hljs-variable language_">self</span>.instruction_positions = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_instruction_sequence</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成指令序列&quot;&quot;&quot;</span><br>        code = []<br><br>        <span class="hljs-comment"># 初始化部分 - 设置寄存器和内存</span><br>        init_code = <span class="hljs-variable language_">self</span>._generate_initialization()<br>        code.extend(init_code)<br>        <span class="hljs-variable language_">self</span>.generated_count += <span class="hljs-built_in">len</span>(init_code)<br>        <span class="hljs-variable language_">self</span>._update_instruction_positions(init_code)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;初始化代码生成完成，共 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(init_code)&#125;</span> 条指令&quot;</span>)<br><br>        <span class="hljs-comment"># 生成测试序列</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-variable language_">self</span>.generated_count &lt; <span class="hljs-variable language_">self</span>.max_instructions:<br>            <span class="hljs-comment"># 随机选择指令类型，增加数据相关指令的概率</span><br>            instr_type = random.choices(<br>                [<span class="hljs-string">&#x27;data_related&#x27;</span>, <span class="hljs-string">&#x27;control&#x27;</span>, <span class="hljs-string">&#x27;memory&#x27;</span>, <span class="hljs-string">&#x27;nop&#x27;</span>],<br>                weights=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.05</span>]<br>            )[<span class="hljs-number">0</span>]<br><br>            new_code = []<br>            <span class="hljs-keyword">if</span> instr_type == <span class="hljs-string">&#x27;data_related&#x27;</span>:<br>                new_code = <span class="hljs-variable language_">self</span>._generate_data_related_pair()<br>            <span class="hljs-keyword">elif</span> instr_type == <span class="hljs-string">&#x27;control&#x27;</span>:<br>                new_code = <span class="hljs-variable language_">self</span>._generate_control_flow()<br>            <span class="hljs-keyword">elif</span> instr_type == <span class="hljs-string">&#x27;memory&#x27;</span>:<br>                new_code = <span class="hljs-variable language_">self</span>._generate_memory_access()<br>            <span class="hljs-keyword">else</span>:<br>                new_code = [<span class="hljs-string">&#x27;nop&#x27;</span>]<br><br>            <span class="hljs-comment"># 检查是否会超出限制</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.generated_count + <span class="hljs-built_in">len</span>(new_code) &gt; <span class="hljs-variable language_">self</span>.max_instructions:<br>                <span class="hljs-comment"># 如果超出，用nop填充剩余空间</span><br>                remaining = <span class="hljs-variable language_">self</span>.max_instructions - <span class="hljs-variable language_">self</span>.generated_count<br>                <span class="hljs-keyword">if</span> remaining &gt; <span class="hljs-number">0</span>:<br>                    new_code = [<span class="hljs-string">&#x27;nop&#x27;</span>] * remaining<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">break</span><br><br>            code.extend(new_code)<br>            <span class="hljs-variable language_">self</span>.generated_count += <span class="hljs-built_in">len</span>(new_code)<br>            <span class="hljs-variable language_">self</span>._update_instruction_positions(new_code)<br><br>            <span class="hljs-comment"># 每生成50条指令输出进度</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.generated_count % <span class="hljs-number">50</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;已生成 <span class="hljs-subst">&#123;self.generated_count&#125;</span> 条指令...&quot;</span>)<br><br>        <span class="hljs-comment"># 添加结束代码</span><br>        final_code = <span class="hljs-variable language_">self</span>._generate_final_code()<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.generated_count + <span class="hljs-built_in">len</span>(final_code) &lt;= <span class="hljs-variable language_">self</span>.max_instructions:<br>            code.extend(final_code)<br>            <span class="hljs-variable language_">self</span>.generated_count += <span class="hljs-built_in">len</span>(final_code)<br>            <span class="hljs-variable language_">self</span>._update_instruction_positions(final_code)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果空间不足，调整结束代码</span><br>            code.append(<span class="hljs-string">&quot;end_loop:&quot;</span>)<br>            code.append(<span class="hljs-string">&quot;nop&quot;</span>)<br>            code.append(<span class="hljs-string">&quot;beq $0, $0, end_loop&quot;</span>)<br>            code.append(<span class="hljs-string">&quot;nop&quot;</span>)<br>            <span class="hljs-variable language_">self</span>.generated_count += <span class="hljs-number">4</span><br>            <span class="hljs-variable language_">self</span>._update_instruction_positions([<span class="hljs-string">&quot;end_loop:&quot;</span>, <span class="hljs-string">&quot;nop&quot;</span>, <span class="hljs-string">&quot;beq $0, $0, end_loop&quot;</span>, <span class="hljs-string">&quot;nop&quot;</span>])<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最终生成 <span class="hljs-subst">&#123;self.generated_count&#125;</span> 条指令&quot;</span>)<br>        <span class="hljs-keyword">return</span> code<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_instruction_positions</span>(<span class="hljs-params">self, instructions</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;更新指令位置信息&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> instr <span class="hljs-keyword">in</span> instructions:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> instr.strip() <span class="hljs-keyword">or</span> instr.startswith(<span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">or</span> instr.endswith(<span class="hljs-string">&#x27;:&#x27;</span>):<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-variable language_">self</span>.instruction_positions.append(<br>                <span class="hljs-variable language_">self</span>.generated_count - <span class="hljs-built_in">len</span>(instructions) + <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.instruction_positions))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_initialization</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成初始化代码&quot;&quot;&quot;</span><br>        init_code = []<br><br>        <span class="hljs-comment"># 添加文件头注释</span><br>        init_code.append(<span class="hljs-string">&quot;# MIPS流水线处理器自动化测试程序&quot;</span>)<br>        init_code.append(<span class="hljs-string">&quot;# 生成的指令序列用于测试转发、暂停和数据相关&quot;</span>)<br>        init_code.append(<span class="hljs-string">&quot;&quot;</span>)<br><br>        <span class="hljs-comment"># 初始化数据寄存器</span><br>        <span class="hljs-keyword">for</span> i, reg <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>]):  <span class="hljs-comment"># 只初始化前8个数据寄存器</span><br>            imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>            init_code.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;reg&#125;</span>, $0, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># 初始化内存区域 - 简化版本</span><br>        base_reg = <span class="hljs-variable language_">self</span>.data_regs[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> offset <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>]:  <span class="hljs-comment"># 只初始化3个内存位置</span><br>            imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>            temp_reg = <span class="hljs-variable language_">self</span>.temp_regs[<span class="hljs-number">0</span>]<br>            init_code.append(<span class="hljs-string">f&quot;lui <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>            init_code.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>            init_code.append(<span class="hljs-string">f&quot;sw <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br><br>        <span class="hljs-keyword">return</span> init_code<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_data_related_pair</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成数据相关指令对（用于测试转发）&quot;&quot;&quot;</span><br>        pair = []<br><br>        <span class="hljs-comment"># 选择指令类型组合</span><br>        producer_types = [<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;sub&#x27;</span>, <span class="hljs-string">&#x27;ori&#x27;</span>, <span class="hljs-string">&#x27;lui&#x27;</span>, <span class="hljs-string">&#x27;lw&#x27;</span>]<br>        consumer_types = [<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;sub&#x27;</span>, <span class="hljs-string">&#x27;ori&#x27;</span>, <span class="hljs-string">&#x27;sw&#x27;</span>]<br><br>        producer = random.choice(producer_types)<br>        consumer = random.choice(consumer_types)<br><br>        <span class="hljs-comment"># 选择寄存器</span><br>        dest_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])  <span class="hljs-comment"># 使用已初始化的寄存器</span><br>        src_reg1 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>        src_reg2 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>        temp_reg = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br><br>        <span class="hljs-comment"># 生成生产者指令</span><br>        <span class="hljs-keyword">if</span> producer == <span class="hljs-string">&#x27;add&#x27;</span>:<br>            pair.append(<span class="hljs-string">f&quot;add <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;src_reg1&#125;</span>, <span class="hljs-subst">&#123;src_reg2&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> producer == <span class="hljs-string">&#x27;sub&#x27;</span>:<br>            pair.append(<span class="hljs-string">f&quot;sub <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;src_reg1&#125;</span>, <span class="hljs-subst">&#123;src_reg2&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> producer == <span class="hljs-string">&#x27;ori&#x27;</span>:<br>            imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>            pair.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;src_reg1&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> producer == <span class="hljs-string">&#x27;lui&#x27;</span>:<br>            imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>            pair.append(<span class="hljs-string">f&quot;lui <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> producer == <span class="hljs-string">&#x27;lw&#x27;</span>:<br>            base_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">5</span>])<br>            offset = random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<br>            pair.append(<span class="hljs-string">f&quot;lw <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br><br>        <span class="hljs-comment"># 插入0-2条无关指令</span><br>        nop_count = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nop_count):<br>            <span class="hljs-comment"># 插入真正无关的指令（不使用目标寄存器）</span><br>            unrelated_instr = random.choice([<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;sub&#x27;</span>, <span class="hljs-string">&#x27;ori&#x27;</span>, <span class="hljs-string">&#x27;nop&#x27;</span>])<br>            <span class="hljs-keyword">if</span> unrelated_instr == <span class="hljs-string">&#x27;nop&#x27;</span>:<br>                pair.append(<span class="hljs-string">&#x27;nop&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                reg1 = random.choice([r <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.temp_regs <span class="hljs-keyword">if</span> r != dest_reg])<br>                reg2 = random.choice([r <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.temp_regs <span class="hljs-keyword">if</span> r != dest_reg])<br>                reg3 = random.choice([r <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.temp_regs <span class="hljs-keyword">if</span> r != dest_reg])<br><br>                <span class="hljs-keyword">if</span> unrelated_instr == <span class="hljs-string">&#x27;add&#x27;</span>:<br>                    pair.append(<span class="hljs-string">f&quot;add <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;reg3&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">elif</span> unrelated_instr == <span class="hljs-string">&#x27;sub&#x27;</span>:<br>                    pair.append(<span class="hljs-string">f&quot;sub <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;reg3&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>                    pair.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># 生成消费者指令（使用生产者产生的数据）</span><br>        <span class="hljs-keyword">if</span> consumer == <span class="hljs-string">&#x27;add&#x27;</span>:<br>            pair.append(<span class="hljs-string">f&quot;add <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;src_reg1&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> consumer == <span class="hljs-string">&#x27;sub&#x27;</span>:<br>            pair.append(<span class="hljs-string">f&quot;sub <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;src_reg1&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> consumer == <span class="hljs-string">&#x27;ori&#x27;</span>:<br>            imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>            pair.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> consumer == <span class="hljs-string">&#x27;sw&#x27;</span>:<br>            base_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">5</span>])<br>            offset = random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<br>            pair.append(<span class="hljs-string">f&quot;sw <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br><br>        <span class="hljs-keyword">return</span> pair<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_control_flow</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成控制流指令&quot;&quot;&quot;</span><br>        control_code = []<br><br>        control_type = random.choice([<span class="hljs-string">&#x27;beq&#x27;</span>, <span class="hljs-string">&#x27;jal&#x27;</span>, <span class="hljs-string">&#x27;jr_safe&#x27;</span>])<br><br>        <span class="hljs-keyword">if</span> control_type == <span class="hljs-string">&#x27;beq&#x27;</span>:<br>            reg1 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>            reg2 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>            <span class="hljs-comment"># 有限的分支偏移</span><br>            offset = random.choice([<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, -<span class="hljs-number">4</span>, -<span class="hljs-number">8</span>, -<span class="hljs-number">12</span>])<br>            label = <span class="hljs-string">f&quot;label_<span class="hljs-subst">&#123;self.label_count&#125;</span>&quot;</span><br>            <span class="hljs-variable language_">self</span>.label_count += <span class="hljs-number">1</span><br>            control_code.append(<span class="hljs-string">f&quot;beq <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;label&#125;</span>&quot;</span>)<br>            control_code.append(<span class="hljs-string">&quot;nop&quot;</span>)  <span class="hljs-comment"># 延迟槽</span><br>            control_code.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;label&#125;</span>:&quot;</span>)<br><br>        <span class="hljs-keyword">elif</span> control_type == <span class="hljs-string">&#x27;jal&#x27;</span>:<br>            func_label = <span class="hljs-string">f&quot;func_<span class="hljs-subst">&#123;self.func_count&#125;</span>&quot;</span><br>            <span class="hljs-variable language_">self</span>.func_count += <span class="hljs-number">1</span><br><br>            <span class="hljs-comment"># 记录函数开始位置</span><br>            func_start = <span class="hljs-variable language_">self</span>.generated_count + <span class="hljs-built_in">len</span>(control_code)<br><br>            control_code.append(<span class="hljs-string">f&quot;jal <span class="hljs-subst">&#123;func_label&#125;</span>&quot;</span>)<br>            control_code.append(<span class="hljs-string">&quot;nop&quot;</span>)  <span class="hljs-comment"># 延迟槽</span><br>            control_code.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;func_label&#125;</span>:&quot;</span>)<br><br>            <span class="hljs-comment"># 简化的函数体</span><br>            func_body_size = random.randint(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(func_body_size):<br>                <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.generated_count + <span class="hljs-built_in">len</span>(control_code) &gt;= <span class="hljs-variable language_">self</span>.max_instructions - <span class="hljs-number">3</span>:<br>                    <span class="hljs-keyword">break</span><br><br>                instr_type = random.choice([<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;sub&#x27;</span>, <span class="hljs-string">&#x27;ori&#x27;</span>, <span class="hljs-string">&#x27;lw&#x27;</span>, <span class="hljs-string">&#x27;sw&#x27;</span>, <span class="hljs-string">&#x27;nop&#x27;</span>])<br>                <span class="hljs-keyword">if</span> instr_type == <span class="hljs-string">&#x27;add&#x27;</span>:<br>                    reg1 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    reg2 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    reg3 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    control_code.append(<span class="hljs-string">f&quot;add <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;reg3&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">elif</span> instr_type == <span class="hljs-string">&#x27;sub&#x27;</span>:<br>                    reg1 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    reg2 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    reg3 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    control_code.append(<span class="hljs-string">f&quot;sub <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;reg3&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">elif</span> instr_type == <span class="hljs-string">&#x27;ori&#x27;</span>:<br>                    reg1 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    reg2 = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>                    control_code.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">elif</span> instr_type == <span class="hljs-string">&#x27;lw&#x27;</span>:<br>                    base_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">5</span>])<br>                    dest_reg = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    offset = random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<br>                    control_code.append(<span class="hljs-string">f&quot;lw <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br>                <span class="hljs-keyword">elif</span> instr_type == <span class="hljs-string">&#x27;sw&#x27;</span>:<br>                    base_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">5</span>])<br>                    src_reg = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                    offset = random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<br>                    control_code.append(<span class="hljs-string">f&quot;sw <span class="hljs-subst">&#123;src_reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    control_code.append(<span class="hljs-string">&quot;nop&quot;</span>)<br><br>            <span class="hljs-comment"># 记录函数结束位置</span><br>            func_end = <span class="hljs-variable language_">self</span>.generated_count + <span class="hljs-built_in">len</span>(control_code)<br>            <span class="hljs-variable language_">self</span>.func_locations[func_label] = (func_start, func_end)<br><br>            <span class="hljs-comment"># 安全的jr $31返回</span><br>            control_code.append(<span class="hljs-string">&quot;jr $31&quot;</span>)<br>            control_code.append(<span class="hljs-string">&quot;nop&quot;</span>)  <span class="hljs-comment"># 延迟槽</span><br><br>        <span class="hljs-keyword">elif</span> control_type == <span class="hljs-string">&#x27;jr_safe&#x27;</span>:<br>            <span class="hljs-comment"># 安全的jr生成方式</span><br>            jr_type = random.choice([<span class="hljs-string">&#x27;jal_pair&#x27;</span>, <span class="hljs-string">&#x27;calc_addr&#x27;</span>])<br><br>            <span class="hljs-keyword">if</span> jr_type == <span class="hljs-string">&#x27;jal_pair&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.func_locations:<br>                <span class="hljs-comment"># 方式1: 与jal配对，在函数内部使用jr $31</span><br>                <span class="hljs-comment"># 这里我们已经在jal部分处理了，所以这种情况不需要额外生成</span><br>                <span class="hljs-comment"># 改为生成一个简单的控制流</span><br>                reg1 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>                reg2 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>                label = <span class="hljs-string">f&quot;label_<span class="hljs-subst">&#123;self.label_count&#125;</span>&quot;</span><br>                <span class="hljs-variable language_">self</span>.label_count += <span class="hljs-number">1</span><br>                control_code.append(<span class="hljs-string">f&quot;beq <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;label&#125;</span>&quot;</span>)<br>                control_code.append(<span class="hljs-string">&quot;nop&quot;</span>)<br>                control_code.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;label&#125;</span>:&quot;</span>)<br><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 方式2: 与赋值语句配对，计算合法地址</span><br>                jr_reg = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br><br>                <span class="hljs-comment"># 计算一个合法的跳转地址</span><br>                <span class="hljs-comment"># 当前指令位置（估算）</span><br>                current_pos = <span class="hljs-variable language_">self</span>.generated_count + <span class="hljs-built_in">len</span>(control_code)<br>                <span class="hljs-comment"># 合法的跳转目标范围（在当前指令附近）</span><br>                target_range_start = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, current_pos - <span class="hljs-number">20</span>)<br>                target_range_end = <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.max_instructions - <span class="hljs-number">1</span>, current_pos + <span class="hljs-number">20</span>)<br><br>                <span class="hljs-keyword">if</span> target_range_end &gt; target_range_start:<br>                    target_pos = random.randint(target_range_start, target_range_end)<br>                    <span class="hljs-comment"># 转换为字节地址</span><br>                    target_addr = <span class="hljs-number">0x3000</span> + target_pos * <span class="hljs-number">4</span><br><br>                    <span class="hljs-comment"># 使用lui和ori计算地址</span><br>                    upper = (target_addr &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFFFF</span><br>                    lower = target_addr &amp; <span class="hljs-number">0xFFFF</span><br><br>                    control_code.append(<span class="hljs-string">f&quot;lui <span class="hljs-subst">&#123;jr_reg&#125;</span>, <span class="hljs-subst">&#123;upper&#125;</span>&quot;</span>)<br>                    control_code.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;jr_reg&#125;</span>, <span class="hljs-subst">&#123;jr_reg&#125;</span>, <span class="hljs-subst">&#123;lower&#125;</span>&quot;</span>)<br>                    control_code.append(<span class="hljs-string">f&quot;jr <span class="hljs-subst">&#123;jr_reg&#125;</span>&quot;</span>)<br>                    control_code.append(<span class="hljs-string">&quot;nop&quot;</span>)  <span class="hljs-comment"># 延迟槽</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 如果无法计算合法地址，生成一个简单的指令</span><br>                    control_code.append(<span class="hljs-string">&quot;nop&quot;</span>)<br><br>        <span class="hljs-keyword">return</span> control_code<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_memory_access</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成内存访问指令序列&quot;&quot;&quot;</span><br>        memory_code = []<br><br>        access_type = random.choice([<span class="hljs-string">&#x27;lw_sw_sequence&#x27;</span>, <span class="hljs-string">&#x27;multiple_access&#x27;</span>, <span class="hljs-string">&#x27;simple&#x27;</span>])<br><br>        <span class="hljs-keyword">if</span> access_type == <span class="hljs-string">&#x27;lw_sw_sequence&#x27;</span>:<br>            <span class="hljs-comment"># lw后接使用数据的指令</span><br>            base_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">5</span>])<br>            dest_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>            offset = random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<br><br>            memory_code.append(<span class="hljs-string">f&quot;lw <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br><br>            <span class="hljs-comment"># 插入0-2条指令</span><br>            nop_count = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nop_count):<br>                memory_code.append(<span class="hljs-string">&quot;nop&quot;</span>)<br><br>            <span class="hljs-comment"># 使用加载的数据</span><br>            use_type = random.choice([<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;ori&#x27;</span>, <span class="hljs-string">&#x27;sw&#x27;</span>])<br>            <span class="hljs-keyword">if</span> use_type == <span class="hljs-string">&#x27;add&#x27;</span>:<br>                temp_reg = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                memory_code.append(<span class="hljs-string">f&quot;add <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;dest_reg&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">elif</span> use_type == <span class="hljs-string">&#x27;ori&#x27;</span>:<br>                temp_reg = random.choice(<span class="hljs-variable language_">self</span>.temp_regs)<br>                imm = random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.imm_range))<br>                memory_code.append(<span class="hljs-string">f&quot;ori <span class="hljs-subst">&#123;temp_reg&#125;</span>, <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                memory_code.append(<span class="hljs-string">f&quot;sw <span class="hljs-subst">&#123;dest_reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br><br>        <span class="hljs-keyword">elif</span> access_type == <span class="hljs-string">&#x27;multiple_access&#x27;</span>:<br>            base_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">5</span>])<br>            reg1 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>            reg2 = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br><br>            offsets = random.sample([<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>], <span class="hljs-number">2</span>)<br>            memory_code.append(<span class="hljs-string">f&quot;lw <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;offsets[<span class="hljs-number">0</span>]&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br>            memory_code.append(<span class="hljs-string">f&quot;lw <span class="hljs-subst">&#123;reg2&#125;</span>, <span class="hljs-subst">&#123;offsets[<span class="hljs-number">1</span>]&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br>            memory_code.append(<span class="hljs-string">f&quot;add <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;reg2&#125;</span>&quot;</span>)<br>            memory_code.append(<span class="hljs-string">f&quot;sw <span class="hljs-subst">&#123;reg1&#125;</span>, <span class="hljs-subst">&#123;offsets[<span class="hljs-number">0</span>]&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># simple</span><br>            base_reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">5</span>])<br>            reg = random.choice(<span class="hljs-variable language_">self</span>.data_regs[:<span class="hljs-number">8</span>])<br>            offset = random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<br>            <span class="hljs-keyword">if</span> random.choice([<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>]):<br>                memory_code.append(<span class="hljs-string">f&quot;lw <span class="hljs-subst">&#123;reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                memory_code.append(<span class="hljs-string">f&quot;sw <span class="hljs-subst">&#123;reg&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>(<span class="hljs-subst">&#123;base_reg&#125;</span>)&quot;</span>)<br><br>        <span class="hljs-keyword">return</span> memory_code<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_final_code</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成程序结束代码&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> [<br>            <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;# 程序结束&quot;</span>,<br>            <span class="hljs-string">&quot;end_loop:&quot;</span>,<br>            <span class="hljs-string">&quot;nop&quot;</span>,<br>            <span class="hljs-string">&quot;beq $0, $0, end_loop&quot;</span>,<br>            <span class="hljs-string">&quot;nop&quot;</span><br>        ]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_hex_file</span>(<span class="hljs-params">self, assembly_code, filename</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成十六进制文件&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 由于我们无法直接生成正确的机器码，这里只生成占位符</span><br>        <span class="hljs-comment"># 实际使用时应该用Mars进行汇编</span><br><br>        <span class="hljs-comment"># 计算实际指令数量（排除标签和注释）</span><br>        actual_instructions = []<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> assembly_code:<br>            line = line.strip()<br>            <span class="hljs-keyword">if</span> line <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> line.startswith(<span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> line.endswith(<span class="hljs-string">&#x27;:&#x27;</span>):<br>                actual_instructions.append(line)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;实际指令数量: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(actual_instructions)&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># 写入简单的十六进制占位文件</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(<span class="hljs-string">&quot;v2.0 raw\n&quot;</span>)<br>            <span class="hljs-comment"># 每条指令用0占位，实际应由Mars生成</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(actual_instructions)):<br>                f.write(<span class="hljs-string">&quot;00000000\n&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_test_program</span>(<span class="hljs-params">self, output_asm=<span class="hljs-string">&quot;test_program.s&quot;</span>, output_hex=<span class="hljs-string">&quot;test_program.hex&quot;</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成完整的测试程序&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;生成流水线测试程序...&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;目标指令数量: <span class="hljs-subst">&#123;self.max_instructions&#125;</span> 条&quot;</span>)<br><br>        <span class="hljs-comment"># 重置计数器</span><br>        <span class="hljs-variable language_">self</span>.generated_count = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.label_count = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.func_count = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.func_locations = &#123;&#125;<br>        <span class="hljs-variable language_">self</span>.instruction_positions = []<br><br>        <span class="hljs-comment"># 生成汇编代码</span><br>        assembly_code = <span class="hljs-variable language_">self</span>.generate_instruction_sequence()<br><br>        <span class="hljs-comment"># 保存汇编文件</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_asm, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> assembly_code:<br>                f.write(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;line&#125;</span>\n&quot;</span>)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;汇编代码已保存到: <span class="hljs-subst">&#123;output_asm&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># 统计实际指令数量</span><br>        actual_count = <span class="hljs-built_in">len</span>([l <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> assembly_code <span class="hljs-keyword">if</span> l.strip() <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> l.startswith(<span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> l.endswith(<span class="hljs-string">&#x27;:&#x27;</span>)])<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;实际生成的指令数量: <span class="hljs-subst">&#123;actual_count&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># 生成十六进制文件</span><br>        <span class="hljs-variable language_">self</span>.generate_hex_file(assembly_code, output_hex)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;十六进制占位文件已保存到: <span class="hljs-subst">&#123;output_hex&#125;</span>&quot;</span>)<br><br>        <span class="hljs-keyword">return</span> assembly_code<br><br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 创建测试生成器</span><br>    generator = PipelineTestGenerator()<br><br>    <span class="hljs-comment"># 生成测试程序</span><br>    test_program = generator.generate_test_program(<span class="hljs-string">&quot;mips_code.asm&quot;</span>, <span class="hljs-string">&quot;mips_code.hex&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n测试程序特性:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 指令集: add, sub, ori, lw, sw, beq, lui, jal, jr, nop&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;- 指令数量: <span class="hljs-subst">&#123;generator.generated_count&#125;</span> 条 (在800-1000条之间随机)&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 数据地址范围: 0x0000-0x00FF (提高lw/sw命中概率)&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 包含数据相关指令对测试转发&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 包含控制流指令测试分支预测和跳转&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 包含内存访问序列测试load-use相关&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 安全的jr指令生成:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  * 与jal配对，在函数内使用jr $31返回&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  * 与赋值语句配对，计算合法跳转地址&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 所有地址和数值都在合法范围内&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- 确保不超过1024条指令限制&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="思考题1"><a href="#思考题1" class="headerlink" title="思考题1"></a>思考题1</h3><blockquote><p>我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。</p></blockquote><p>从流水线冒险的角度来看，提前分支判断（即在D级就决定分支是否跳转）旨在减少控制冒险带来的停顿，但这种方法并非总能提高效率，主要是因为分支判断可能依赖于尚未就绪的数据，从而引发数据冒险。具体来说，如果分支指令的条件操作数依赖于前面指令的计算结果，而该结果还在流水线中未写回寄存器文件，那么提前分支判断就无法获得正确的数据，导致流水线仍需停顿等待数据可用，从而无法避免性能损失。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add $3,$2,$1<br>beq $1,$4,label<br></code></pre></td></tr></table></figure><p>原本在E级的<code>ALU</code>判断出是否跳转信号<code>zero</code>，是刚好可以不用阻塞的，现在前提到D级，导致需要阻塞一拍，其实是不划算的。</p><h3 id="思考题2"><a href="#思考题2" class="headerlink" title="思考题2"></a>思考题2</h3><blockquote><p>因为延迟槽的存在，对于 <code>jal</code> 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？</p></blockquote><p>在 MIPS 架构中，延迟槽（delay slot）的设计是为了优化流水线性能，减少控制冒险带来的停顿。当执行跳转指令（如 <code>jal</code>）时，跳转指令之后的指令（即延迟槽中的指令）总是会被执行，无论跳转是否发生。这是因为在流水线中，跳转指令在译码阶段（D）才能确定目标地址，但此时下一条指令已经进入取指阶段（F），为了保持流水线充满，延迟槽被用于执行一条有用的指令或空操作（<code>nop</code>）。</p><p>对于 <code>jal</code> 指令（跳转并链接），其作用是将返回地址保存到寄存器（如 <code>$ra</code>）中，以便在子程序执行完成后能正确返回。返回地址应当指向子程序调用后应该继续执行的位置。由于延迟槽的存在，<code>jal</code> 指令之后的延迟槽指令会被执行，因此返回地址必须指向延迟槽之后的那条指令，即 <code>PC + 8</code>。</p><h3 id="思考题3"><a href="#思考题3" class="headerlink" title="思考题3"></a>思考题3</h3><blockquote><p>我们要求所有转发数据都来源于流水寄存器而不能是功能部件（如 DM、ALU），请思考为什么？</p></blockquote><p><strong>保证时序稳定与设计简化。</strong></p><ol><li><strong>时序稳定（关键原因）</strong>：功能部件（如 ALU）的输出是组合逻辑的结果，在时钟周期结束前可能是不稳定的。流水线寄存器在时钟边沿捕获数据，能为本时钟周期提供<strong>稳定不变</strong>的数据源。如果直接从 ALU 转发，数据在周期内变化会导致冒险逻辑判断错误和结果不可靠。</li><li><strong>设计简化</strong>：所有转发数据都来自固定的寄存器（如 E/M、M/W），为转发网络提供了统一、干净的接口。如果允许从功能部件直接转发，会引入大量复杂且时序各异的路径，极大地增加了设计和验证的难度。</li></ol><h3 id="思考题4"><a href="#思考题4" class="headerlink" title="思考题4"></a>思考题4</h3><blockquote><p>我们为什么要使用 GPR 内部转发？该如何实现？</p></blockquote><p>为了解决”写后读”（RAW）数据冒险。当连续两条指令对同一寄存器进行写和读时，避免流水线停顿，确保后续指令能立即获取刚写入的值。</p><p>实现实际就是W-&gt;D级的转发通路。</p><h3 id="思考题5"><a href="#思考题5" class="headerlink" title="思考题5"></a>思考题5</h3><blockquote><p>我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？</p></blockquote><p>需求者：<code>DEreg</code>流水线寄存器，E级的ALU，M级的DM_WD。</p><p>供给者：<code>EPCplus8</code>，<code>MPCplus8</code>，<code>M_ALUans</code>，<code>W_WD</code></p><p>一共有3×5=15条数据通路，共用一下一共5个转发MUX。</p><h3 id="思考题6"><a href="#思考题6" class="headerlink" title="思考题6"></a>思考题6</h3><blockquote><p>在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。</p></blockquote><p><strong>新指令的扩展/修改方案：</strong></p><h4 id="1-R型算术逻辑指令（如-and-xor）"><a href="#1-R型算术逻辑指令（如-and-xor）" class="headerlink" title="1. R型算术逻辑指令（如 and, xor）"></a>1. R型算术逻辑指令（如 and, xor）</h4><ul><li><strong>执行阶段</strong>：扩展ALU功能，添加新运算</li><li><strong>控制信号</strong>：更新ALU控制逻辑</li><li><strong>无需修改数据通路结构</strong></li></ul><h4 id="2-I型立即数指令（如-andi-addiu）"><a href="#2-I型立即数指令（如-andi-addiu）" class="headerlink" title="2. I型立即数指令（如 andi, addiu）"></a>2. I型立即数指令（如 andi, addiu）</h4><ul><li><strong>译码阶段</strong>：扩展立即数处理（符号/零扩展选择）</li><li><strong>控制信号</strong>：新增ExtOp信号控制扩展方式</li><li><strong>执行阶段</strong>：确保立即数正确输入ALU</li></ul><h4 id="3-移位指令（如-sllv-sra）"><a href="#3-移位指令（如-sllv-sra）" class="headerlink" title="3. 移位指令（如 sllv, sra）"></a>3. 移位指令（如 sllv, sra）</h4><ul><li><strong>执行阶段</strong>：添加移位器或扩展ALU移位功能</li><li><strong>数据通路</strong>：增加移位数量输入路径（寄存器或立即数）</li><li><strong>控制信号</strong>：新增移位类型控制</li></ul><h4 id="4-访存指令（如-lb-sh）"><a href="#4-访存指令（如-lb-sh）" class="headerlink" title="4. 访存指令（如 lb, sh）"></a>4. 访存指令（如 lb, sh）</h4><ul><li><strong>存储阶段</strong>：扩展DM支持字节/半字访问</li><li><strong>控制信号</strong>：新增MemSize信号</li><li><strong>写回阶段</strong>：添加加载数据扩展逻辑（符号/零扩展）</li></ul><h4 id="5-分支指令（如-bne-blez）"><a href="#5-分支指令（如-bne-blez）" class="headerlink" title="5. 分支指令（如 bne, blez）"></a>5. 分支指令（如 bne, blez）</h4><ul><li><strong>译码阶段</strong>：扩展比较器功能（≠、≤等）</li><li><strong>控制信号</strong>：新增BranchType信号</li><li><strong>PC计算</strong>：可能增加新的目标地址计算路径</li></ul><h4 id="6-特殊指令（如-mul-mfhi）"><a href="#6-特殊指令（如-mul-mfhi）" class="headerlink" title="6. 特殊指令（如 mul, mfhi）"></a>6. 特殊指令（如 mul, mfhi）</h4><ul><li><strong>执行阶段</strong>：可能添加专用功能单元（乘除法器）</li><li><strong>寄存器文件</strong>：可能扩展特殊寄存器（HI/LO）</li><li><strong>数据通路</strong>：新增特殊寄存器读写路径</li></ul><h4 id="7-考场上的神秘指令"><a href="#7-考场上的神秘指令" class="headerlink" title="7.考场上的神秘指令"></a>7.考场上的神秘指令</h4><p>往往需要我们取出什么什么，进行一个怎样的运算，相等则跳转否则存入哪哪哪，那么我们要记住，凡是增加的借口都要考虑转发；要计算出该指令的AT模型表，以便看出是否需要阻塞。</p><h3 id="思考题7"><a href="#思考题7" class="headerlink" title="思考题7"></a>思考题7</h3><blockquote><p>简要描述你的译码器架构，并思考该架构的优势以及不足。</p></blockquote><p>我使用分布式译码，在每一级译出需要的信号。传入𝑡让CTRL知道自己在哪一级，便于译出T_new</p><h4 id="控制信号分类"><a href="#控制信号分类" class="headerlink" title="控制信号分类"></a>控制信号分类</h4><ul><li><strong>NPC控制</strong>：分支跳转类型（NPCop）</li><li><strong>寄存器控制</strong>：写使能（GRFwe）、目标地址选择（A3slt）、写数据选择（WDslt）</li><li><strong>运算控制</strong>：ALU操作（ALUop）、输入选择（ALUAslt、ALUBslt）</li><li><strong>内存控制</strong>：存储器写使能（DMwr）</li><li><strong>立即数控制</strong>：扩展方式（EXTop）</li><li><strong>比较控制</strong>：比较操作（CMPop）</li><li><strong>冒险检测</strong>：输出<code>T_use_rs</code>、<code>T_use_rt</code>、<code>T_new</code>用于流水线冒险检测</li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li><strong>时序优化</strong><ul><li>控制信号与对应流水级同步，减少组合逻辑延迟</li><li>避免了长距离控制信号传输</li></ul></li><li><strong>模块化设计</strong><ul><li>各阶段控制器独立，便于调试和修改</li><li>新指令只需在对应阶段添加控制逻辑</li></ul></li><li><strong>冒险处理完善</strong><ul><li>集成T-use/T-new机制，支持精确的冒险检测</li><li>为转发和停顿提供准确的时间信息</li></ul></li><li><strong>简洁性</strong><ul><li>每个阶段只生成需要的控制信号</li><li>减少不必要的信号传输</li></ul></li></ol><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ol><li><strong>代码冗余</strong><ul><li>相同的指令在不同阶段需要重复译码</li><li>控制逻辑分散，维护成本较高</li></ul></li><li><strong>一致性风险</strong><ul><li>多实例可能导致控制信号不一致</li><li>指令修改需要在所有CTRL实例中同步更新</li></ul></li><li><strong>扩展性限制</strong><ul><li>新指令需要修改多个阶段的控制器</li><li>控制信号数量固定，难以适应复杂指令集</li></ul></li><li><strong>时序分析复杂</strong><ul><li>需要确保所有CTRL实例的时序一致性</li><li>冒险检测逻辑依赖多个阶段的T值同步</li></ul></li><li><strong>资源占用</strong><ul><li>多个CTRL实例增加硬件资源消耗</li><li>控制逻辑重复导致面积开销</li></ul></li></ol><h3 id="思考题8"><a href="#思考题8" class="headerlink" title="思考题8"></a>思考题8</h3><blockquote><p>[P5 选做] 请详细描述你的测试方案及测试数据构造策略。</p></blockquote><p>测试方案见上方<em>测试方案</em>段落。下面给出生成的一组测试样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ori $1, $0, 232<br>ori $2, $0, 176<br>ori $3, $0, 234<br>ori $4, $0, 191<br>ori $5, $0, 224<br>ori $6, $0, 65<br>ori $7, $0, 70<br>ori $8, $0, 100<br>lui $8, 41<br>ori $8, $8, 41<br>sw $8, 0($1)<br>lui $8, 228<br>ori $8, $8, 228<br>sw $8, 4($1)<br>lui $8, 143<br>ori $8, $8, 143<br>sw $8, 8($1)<br>ori $2, $6, 33<br>add $8, $10, $12<br>add $10, $2, $6<br>add $7, $7, $7<br>add $8, $7, $7<br>beq $6, $7, label_0<br>nop<br>label_0:<br>add $4, $5, $5<br>sub $12, $4, $5<br>nop<br>jal func_0<br>nop<br>func_0:<br>sub $9, $10, $10<br>sub $10, $9, $11<br>sub $8, $12, $15<br>add $10, $8, $10<br>sw $11, 8($1)<br>nop<br>nop<br>jr $31<br>nop<br>lui $10, 0<br>ori $10, $10, 12496<br>jr $10<br>nop<br>add $8, $6, $7<br>sub $13, $13, $9<br>ori $14, $8, 7<br>lui $2, 80<br>add $8, $15, $12<br>sub $10, $14, $13<br>sub $14, $2, $4<br>add $3, $8, $2<br>ori $15, $10, 164<br>sw $3, 4($1)<br>jal func_1<br>nop<br>func_1:<br>sw $11, 4($1)<br>sw $9, 8($4)<br>nop<br>sw $15, 4($5)<br>sw $13, 4($1)<br>nop<br>ori $11, $10, 96<br>jr $31<br>nop<br>ori $4, $4, 220<br>add $10, $11, $10<br>sub $10, $13, $15<br>ori $13, $4, 117<br>lw $2, 4($4)<br>lw $5, 8($4)<br>add $2, $2, $5<br>sw $2, 4($4)<br>lw $5, 0($5)<br>lw $3, 8($5)<br>add $5, $5, $3<br>sw $5, 0($5)<br>ori $4, $6, 220<br>sub $10, $4, $6<br>beq $3, $1, label_1<br>nop<br>label_1:<br>lui $3, 130<br>ori $11, $14, 77<br>add $14, $11, $15<br>sub $13, $3, $5<br>lw $5, 8($2)<br>add $15, $5, $2<br>lw $3, 0($4)<br>ori $13, $9, 175<br>add $15, $3, $5<br>nop<br>jal func_2<br>nop<br>func_2:<br>lw $10, 8($4)<br>sub $11, $9, $12<br>sub $11, $10, $11<br>add $8, $11, $14<br>add $14, $11, $8<br>jr $31<br>nop<br>lw $5, 4($2)<br>lw $5, 0($2)<br>add $5, $5, $5<br>sw $5, 4($2)<br>lui $14, 0<br>ori $14, $14, 12720<br>jr $14<br>nop<br>jal func_3<br>nop<br>func_3:<br>lw $11, 0($5)<br>add $15, $12, $10<br>lw $12, 0($1)<br>jr $31<br>nop<br>lw $2, 0($5)<br>nop<br>add $11, $2, $7<br>ori $3, $5, 168<br>ori $14, $12, 193<br>ori $10, $8, 221<br>sw $3, 8($4)<br>lw $1, 0($4)<br>lw $1, 4($4)<br>add $1, $1, $1<br>sw $1, 0($4)<br>sub $7, $4, $4<br>add $9, $14, $8<br>ori $12, $14, 155<br>sub $12, $7, $4<br>nop<br>ori $3, $6, 84<br>sub $10, $3, $6<br>lw $3, 8($4)<br>lw $6, 4($4)<br>add $3, $3, $6<br>sw $3, 8($4)<br>lw $6, 4($1)<br>lui $2, 203<br>sub $14, $12, $11<br>add $13, $13, $8<br>ori $11, $2, 55<br>add $1, $8, $7<br>ori $15, $9, 4<br>nop<br>sw $1, 4($3)<br>jal func_4<br>nop<br>func_4:<br>lw $13, 4($4)<br>ori $12, $14, 83<br>lw $15, 8($5)<br>sw $13, 8($1)<br>jr $31<br>nop<br>nop<br>add $4, $4, $4<br>sw $4, 0($3)<br>add $8, $3, $8<br>add $12, $12, $10<br>add $12, $8, $3<br>lw $1, 4($2)<br>ori $14, $1, 39<br>lw $6, 8($5)<br>lui $11, 0<br>ori $11, $11, 12920<br>jr $11<br>nop<br>lw $8, 0($5)<br>add $13, $10, $12<br>ori $14, $11, 171<br>add $10, $8, $1<br>add $1, $7, $3<br>sub $10, $10, $12<br>add $15, $1, $7<br>lui $7, 224<br>sw $7, 0($2)<br>ori $6, $4, 19<br>ori $9, $10, 254<br>sub $9, $9, $15<br>sub $14, $6, $4<br>lui $3, 115<br>sub $10, $14, $8<br>ori $15, $3, 45<br>nop<br>ori $1, $7, 72<br>nop<br>sw $1, 0($2)<br>add $7, $3, $2<br>add $9, $7, $3<br>beq $7, $8, label_2<br>nop<br>label_2:<br>add $3, $8, $3<br>add $10, $11, $11<br>nop<br>sw $3, 8($1)<br>nop<br>sub $5, $7, $3<br>sub $15, $5, $7<br>beq $8, $1, label_3<br>nop<br>label_3:<br>lw $3, 8($2)<br>sub $3, $7, $5<br>ori $12, $15, 66<br>ori $10, $3, 8<br>add $6, $1, $5<br>sw $6, 0($3)<br>lw $3, 0($5)<br>add $13, $3, $4<br>lw $5, 0($5)<br>nop<br>sub $10, $8, $14<br>add $8, $5, $7<br>lw $7, 8($2)<br>add $13, $15, $8<br>sub $14, $15, $9<br>add $13, $7, $6<br>sub $1, $6, $2<br>sub $15, $8, $11<br>add $11, $1, $6<br>lui $3, 132<br>sub $15, $10, $15<br>sub $14, $12, $11<br>sub $8, $3, $6<br>sub $2, $1, $1<br>sub $13, $9, $14<br>add $8, $12, $15<br>sw $2, 4($3)<br>ori $7, $5, 7<br>add $14, $14, $15<br>add $15, $15, $10<br>ori $9, $7, 50<br>jal func_5<br>nop<br>func_5:<br>add $12, $10, $10<br>sub $14, $15, $14<br>sw $12, 0($2)<br>lw $9, 0($4)<br>lw $13, 0($3)<br>add $14, $14, $9<br>sw $13, 8($2)<br>jr $31<br>nop<br>lw $8, 0($5)<br>add $12, $8, $8<br>lui $2, 181<br>sub $9, $12, $13<br>ori $8, $2, 43<br>lui $8, 65<br>add $9, $14, $15<br>add $14, $8, $1<br>beq $2, $1, label_4<br>nop<br>label_4:<br>ori $1, $7, 108<br>sub $12, $10, $12<br>ori $10, $1, 212<br>nop<br>ori $8, $8, 148<br>add $14, $14, $14<br>sub $10, $10, $14<br>sw $8, 8($5)<br>lw $2, 0($5)<br>nop<br>sw $2, 0($2)<br>beq $3, $5, label_5<br>nop<br>label_5:<br>sub $1, $6, $4<br>sub $8, $1, $6<br>jal func_6<br>nop<br>func_6:<br>nop<br>sw $14, 0($4)<br>nop<br>add $13, $9, $11<br>nop<br>ori $10, $13, 235<br>ori $9, $15, 228<br>jr $31<br>nop<br>lw $3, 8($2)<br>ori $9, $3, 31<br>jal func_7<br>nop<br>func_7:<br>ori $9, $10, 233<br>add $12, $12, $10<br>sub $11, $8, $11<br>nop<br>lw $14, 4($1)<br>ori $13, $9, 229<br>jr $31<br>nop<br>ori $1, $8, 83<br>add $14, $1, $8<br>sub $3, $1, $6<br>sub $11, $14, $13<br>sub $10, $15, $8<br>sub $9, $3, $1<br>lw $7, 0($2)<br>nop<br>nop<br>sw $7, 0($2)<br>beq $2, $4, label_6<br>nop<br>label_6:<br>ori $4, $3, 167<br>sub $12, $15, $8<br>ori $8, $4, 64<br>jal func_8<br>nop<br>func_8:<br>nop<br>lw $10, 4($2)<br>sw $15, 4($2)<br>sw $8, 4($3)<br>ori $9, $14, 55<br>jr $31<br>nop<br>jal func_9<br>nop<br>func_9:<br>ori $10, $12, 30<br>lw $9, 8($2)<br>ori $8, $10, 140<br>lw $13, 0($1)<br>sw $13, 4($1)<br>sub $13, $13, $12<br>jr $31<br>nop<br>lui $7, 149<br>ori $11, $11, 181<br>ori $11, $7, 83<br>add $3, $1, $8<br>ori $14, $8, 108<br>sub $14, $14, $13<br>sw $3, 0($5)<br>ori $5, $3, 120<br>ori $14, $5, 253<br>nop<br>lw $6, 8($2)<br>lw $8, 4($3)<br>nop<br>add $8, $8, $8<br>lui $9, 0<br>ori $9, $9, 13688<br>jr $9<br>nop<br>lui $8, 90<br>nop<br>add $10, $13, $14<br>ori $13, $8, 227<br>nop<br>sw $5, 4($3)<br>add $2, $5, $2<br>nop<br>sub $15, $9, $13<br>add $12, $2, $5<br>ori $8, $6, 130<br>sw $8, 0($1)<br>nop<br>sub $2, $7, $4<br>sub $10, $13, $13<br>sub $14, $2, $7<br>beq $2, $1, label_7<br>nop<br>label_7:<br>lw $7, 8($5)<br>lw $4, 4($5)<br>add $7, $7, $4<br>sw $7, 8($5)<br>jal func_10<br>nop<br>func_10:<br>sub $15, $11, $14<br>add $9, $15, $15<br>nop<br>lw $15, 0($4)<br>ori $9, $13, 36<br>nop<br>nop<br>add $9, $15, $12<br>jr $31<br>nop<br>lw $1, 0($3)<br>nop<br>ori $11, $11, 25<br>sw $1, 8($1)<br>add $1, $2, $2<br>sub $14, $13, $14<br>ori $8, $10, 88<br>add $10, $1, $2<br>beq $1, $8, label_8<br>nop<br>label_8:<br>beq $3, $6, label_9<br>nop<br>label_9:<br>lw $7, 8($5)<br>ori $14, $7, 140<br>sub $6, $1, $2<br>ori $9, $10, 96<br>sub $14, $6, $1<br>lw $5, 8($2)<br>add $3, $8, $7<br>add $13, $9, $12<br>add $14, $12, $13<br>sw $3, 4($3)<br>beq $7, $4, label_10<br>nop<br>label_10:<br>lw $8, 0($2)<br>beq $5, $8, label_11<br>nop<br>label_11:<br>sub $3, $1, $4<br>add $9, $3, $1<br>lw $7, 0($5)<br>ori $14, $7, 108<br>ori $4, $6, 63<br>ori $15, $15, 151<br>add $9, $8, $10<br>sub $13, $4, $6<br>lw $7, 4($5)<br>beq $4, $4, label_12<br>nop<br>label_12:<br>lui $6, 245<br>sw $6, 0($5)<br>lw $8, 4($2)<br>nop<br>add $12, $14, $9<br>sw $8, 8($5)<br>sub $5, $2, $5<br>add $13, $14, $8<br>sub $11, $14, $13<br>sub $15, $5, $2<br>lw $8, 0($1)<br>lw $6, 8($3)<br>nop<br>nop<br>add $15, $6, $6<br>sw $3, 0($5)<br>lui $6, 197<br>sw $6, 4($5)<br>lw $2, 0($4)<br>sub $13, $13, $12<br>sub $11, $2, $8<br>jal func_11<br>nop<br>func_11:<br>add $15, $15, $10<br>sw $10, 0($2)<br>sub $14, $11, $12<br>sw $8, 4($3)<br>sw $8, 0($4)<br>jr $31<br>nop<br>lui $13, 0<br>ori $13, $13, 14232<br>jr $13<br>nop<br>beq $1, $3, label_13<br>nop<br>label_13:<br>sub $7, $2, $8<br>ori $15, $12, 133<br>ori $10, $7, 187<br>sub $1, $4, $3<br>ori $13, $10, 79<br>add $8, $1, $4<br>lui $3, 168<br>add $10, $13, $8<br>ori $15, $3, 228<br>lw $3, 8($4)<br>ori $9, $3, 198<br>lw $3, 8($1)<br>lw $2, 0($1)<br>add $3, $3, $2<br>sw $3, 8($1)<br>jal func_12<br>nop<br>func_12:<br>sw $13, 8($2)<br>ori $13, $9, 36<br>ori $10, $14, 121<br>nop<br>sub $15, $9, $10<br>jr $31<br>nop<br>add $3, $7, $1<br>ori $9, $12, 19<br>nop<br>sub $9, $3, $7<br>lui $1, 131<br>ori $14, $9, 21<br>ori $15, $12, 145<br>add $13, $1, $5<br>lw $6, 8($3)<br>lw $6, 4($3)<br>add $6, $6, $6<br>sw $6, 8($3)<br>nop<br>lui $8, 203<br>nop<br>sw $8, 4($1)<br>lui $10, 0<br>ori $10, $10, 14384<br>jr $10<br>nop<br>sub $3, $4, $6<br>nop<br>ori $13, $3, 143<br>lui $4, 184<br>ori $12, $9, 9<br>sub $9, $4, $3<br>lui $9, 0<br>ori $9, $9, 14376<br>jr $9<br>nop<br>nop<br>lw $8, 0($3)<br>nop<br>ori $10, $12, 99<br>add $10, $8, $5<br>add $3, $2, $2<br>ori $10, $13, 75<br>sub $8, $3, $2<br>lw $8, 0($2)<br>nop<br>add $10, $8, $8<br>add $4, $2, $4<br>sub $10, $8, $9<br>sub $10, $10, $13<br>ori $12, $4, 240<br>lui $4, 55<br>add $13, $14, $14<br>sub $10, $4, $2<br>lw $2, 8($4)<br>lw $7, 0($4)<br>add $2, $2, $7<br>sw $2, 8($4)<br>ori $1, $8, 246<br>ori $10, $11, 228<br>sub $14, $14, $11<br>sw $1, 8($3)<br>beq $7, $1, label_14<br>nop<br>label_14:<br>sub $1, $2, $2<br>nop<br>sw $1, 0($1)<br>lw $1, 0($5)<br>nop<br>nop<br>sw $1, 0($5)<br>lui $9, 0<br>ori $9, $9, 14624<br>jr $9<br>nop<br>add $7, $2, $1<br>add $13, $12, $15<br>ori $8, $8, 21<br>sub $14, $7, $2<br>beq $6, $4, label_15<br>nop<br>label_15:<br>beq $7, $6, label_16<br>nop<br>label_16:<br>beq $5, $8, label_17<br>nop<br>label_17:<br>sub $3, $4, $1<br>ori $13, $12, 155<br>nop<br>add $15, $3, $4<br>lw $2, 0($2)<br>nop<br>nop<br>sw $2, 0($2)<br>beq $3, $4, label_18<br>nop<br>label_18:<br>add $3, $2, $4<br>sub $14, $3, $2<br>ori $4, $5, 56<br>ori $12, $12, 218<br>ori $10, $14, 59<br>sub $10, $4, $5<br>lw $4, 4($5)<br>sub $11, $13, $13<br>sub $8, $4, $5<br>lw $7, 0($5)<br>nop<br>add $12, $7, $6<br>ori $4, $1, 67<br>sub $10, $4, $1<br>lw $3, 0($5)<br>nop<br>sub $12, $3, $5<br>ori $8, $7, 91<br>sub $14, $11, $12<br>add $9, $13, $14<br>ori $8, $8, 43<br>lui $15, 0<br>ori $15, $15, 14736<br>jr $15<br>nop<br>lui $4, 254<br>ori $10, $14, 113<br>sub $14, $4, $8<br>ori $5, $8, 234<br>sub $9, $5, $8<br>lui $7, 116<br>nop<br>ori $10, $12, 5<br>add $12, $7, $6<br>sub $6, $5, $8<br>sw $6, 4($4)<br>lw $2, 0($5)<br>lw $1, 4($5)<br>add $2, $2, $1<br>sw $2, 0($5)<br>beq $4, $6, label_19<br>nop<br>label_19:<br>sub $4, $6, $4<br>add $15, $4, $6<br>ori $4, $2, 142<br>sub $14, $4, $2<br>lw $1, 8($4)<br>sub $8, $1, $4<br>lw $8, 0($1)<br>nop<br>sw $8, 4($3)<br>lw $7, 4($5)<br>sub $15, $9, $14<br>ori $15, $9, 50<br>sub $10, $7, $6<br>nop<br>lw $8, 0($4)<br>lw $7, 4($4)<br>add $8, $8, $7<br>sw $8, 0($4)<br>lw $2, 0($5)<br>beq $6, $8, label_20<br>nop<br>label_20:<br>lw $5, 8($1)<br>sub $10, $15, $8<br>sw $5, 0($3)<br>add $3, $3, $8<br>sub $15, $3, $3<br>beq $4, $5, label_21<br>nop<br>label_21:<br>lw $3, 0($4)<br>sub $7, $5, $3<br>nop<br>sw $7, 8($5)<br>lw $5, 8($2)<br>lw $8, 8($3)<br>add $14, $8, $6<br>ori $3, $1, 178<br>add $11, $12, $15<br>ori $8, $13, 108<br>ori $12, $3, 187<br>sub $8, $5, $4<br>ori $10, $12, 1<br>ori $14, $15, 7<br>sub $13, $8, $5<br>lw $8, 0($2)<br>nop<br>add $12, $8, $8<br>lui $3, 123<br>add $8, $8, $14<br>sw $3, 0($4)<br>beq $8, $1, label_22<br>nop<br>label_22:<br>lui $6, 196<br>add $12, $13, $9<br>add $9, $15, $12<br>sw $6, 8($5)<br>lw $3, 4($5)<br>lui $14, 0<br>ori $14, $14, 15060<br>jr $14<br>nop<br>lw $5, 8($4)<br>ori $15, $8, 26<br>add $15, $11, $15<br>add $10, $5, $3<br>lui $3, 89<br>sw $3, 0($4)<br>lw $1, 4($5)<br>ori $8, $1, 246<br>lw $8, 4($3)<br>nop<br>sub $15, $8, $6<br>add $7, $2, $2<br>sw $7, 4($3)<br>add $7, $1, $1<br>sub $9, $10, $8<br>ori $11, $8, 5<br>add $10, $7, $1<br>jal func_13<br>nop<br>func_13:<br>add $15, $14, $14<br>nop<br>add $12, $8, $9<br>add $14, $11, $8<br>jr $31<br>nop<br>lw $7, 4($4)<br>add $8, $7, $4<br>add $11, $8, $7<br>nop<br>beq $3, $5, label_23<br>nop<br>label_23:<br>nop<br>beq $7, $1, label_24<br>nop<br>label_24:<br>jal func_14<br>nop<br>func_14:<br>add $11, $15, $15<br>sub $15, $15, $9<br>ori $15, $12, 7<br>sub $15, $14, $11<br>jr $31<br>nop<br>lw $7, 4($1)<br>sw $7, 0($1)<br>ori $6, $8, 248<br>sub $15, $8, $10<br>sub $15, $6, $8<br>ori $3, $4, 163<br>add $10, $9, $10<br>add $10, $3, $4<br>lui $9, 0<br>ori $9, $9, 15392<br>jr $9<br>nop<br>lw $5, 4($5)<br>nop<br>nop<br>ori $11, $5, 139<br>nop<br>add $2, $3, $1<br>add $11, $2, $3<br>beq $7, $4, label_25<br>nop<br>label_25:<br>lui $13, 0<br>ori $13, $13, 15416<br>jr $13<br>nop<br>add $5, $7, $7<br>nop<br>add $9, $5, $7<br>add $6, $1, $6<br>nop<br>add $13, $6, $1<br>beq $2, $1, label_26<br>nop<br>label_26:<br>ori $6, $5, 229<br>sub $13, $14, $9<br>ori $13, $14, 138<br>sub $12, $6, $5<br>jal func_15<br>nop<br>func_15:<br>lw $11, 4($5)<br>sw $10, 8($2)<br>ori $11, $15, 99<br>sw $10, 8($2)<br>sub $14, $13, $8<br>jr $31<br>nop<br>lw $1, 4($1)<br>lw $1, 8($1)<br>add $1, $1, $1<br>sw $1, 4($1)<br>add $7, $6, $7<br>sw $7, 4($5)<br>lui $7, 230<br>sub $11, $7, $2<br>sub $8, $7, $5<br>sub $13, $14, $12<br>ori $15, $11, 16<br>sw $8, 8($5)<br>sub $3, $2, $7<br>nop<br>sub $10, $11, $11<br>add $15, $3, $2<br>sub $7, $8, $7<br>sw $7, 8($5)<br>nop<br>lw $4, 4($4)<br>lw $4, 8($4)<br>add $4, $4, $4<br>sw $4, 4($4)<br>sub $8, $5, $6<br>ori $14, $8, 12<br>ori $6, $4, 150<br>nop<br>nop<br>sub $9, $6, $4<br>lui $5, 50<br>ori $10, $11, 20<br>sw $5, 4($2)<br>beq $5, $4, label_27<br>nop<br>label_27:<br>add $4, $8, $6<br>add $8, $4, $8<br>add $7, $3, $4<br>ori $14, $9, 241<br>ori $14, $14, 178<br>sub $10, $7, $3<br>add $5, $2, $2<br>ori $13, $13, 220<br>sub $12, $10, $14<br>sw $5, 0($3)<br>lw $5, 0($5)<br>add $9, $8, $15<br>add $13, $5, $8<br>add $4, $1, $4<br>sw $4, 8($3)<br>lui $1, 129<br>ori $15, $1, 31<br>jal func_16<br>nop<br>func_16:<br>add $8, $11, $10<br>add $15, $10, $10<br>nop<br>jr $31<br>nop<br>add $2, $5, $2<br>add $11, $14, $13<br>add $12, $13, $9<br>sw $2, 0($2)<br>beq $2, $2, label_28<br>nop<br>label_28:<br>sub $8, $7, $1<br>add $12, $8, $7<br>beq $1, $2, label_29<br>nop<br>label_29:<br>beq $8, $1, label_30<br>nop<br>label_30:<br>jal func_17<br>nop<br>func_17:<br>nop<br>sw $12, 0($5)<br>nop<br>sw $9, 0($4)<br>sw $8, 4($3)<br>sw $14, 0($5)<br>jr $31<br>nop<br>lw $8, 4($1)<br>nop<br>sw $8, 4($1)<br>lw $6, 8($5)<br>sw $6, 8($5)<br>lui $6, 45<br>add $10, $10, $9<br>ori $14, $6, 224<br>add $1, $6, $2<br>ori $14, $9, 66<br>sub $15, $1, $6<br>lui $5, 239<br>add $10, $14, $8<br>add $8, $9, $14<br>sub $14, $5, $6<br>ori $2, $3, 239<br>add $8, $2, $3<br>sub $7, $3, $4<br>add $10, $9, $13<br>sub $12, $9, $12<br>ori $11, $7, 119<br>lw $2, 4($5)<br>lw $7, 8($5)<br>add $2, $2, $7<br>sw $2, 4($5)<br>sub $6, $2, $5<br>nop<br>sub $8, $11, $9<br>sub $10, $6, $2<br>beq $5, $3, label_31<br>nop<br>label_31:<br>ori $1, $6, 238<br>nop<br>add $9, $1, $6<br>lw $1, 0($5)<br>ori $13, $1, 150<br>lw $6, 4($3)<br>lw $7, 8($3)<br>add $6, $6, $7<br>sw $6, 4($3)<br>lui $3, 12<br>ori $12, $11, 212<br>sub $12, $15, $15<br>sub $9, $3, $2<br>add $5, $5, $2<br>add $13, $13, $11<br>ori $8, $14, 101<br>sub $13, $5, $5<br>ori $5, $4, 181<br>add $14, $11, $14<br>ori $13, $9, 33<br>ori $10, $5, 232<br>lw $5, 8($4)<br>nop<br>add $15, $5, $5<br>lw $3, 8($2)<br>ori $8, $12, 7<br>ori $11, $3, 190<br>lw $6, 0($5)<br>nop<br>nop<br>add $14, $6, $6<br>lui $5, 3<br>ori $9, $12, 226<br>sub $15, $5, $8<br>beq $4, $8, label_32<br>nop<br>label_32:<br>beq $2, $2, label_33<br>nop<br>label_33:<br>jal func_18<br>nop<br>func_18:<br>ori $13, $10, 192<br>lw $10, 8($3)<br>lw $8, 4($5)<br>sw $13, 4($5)<br>nop<br>jr $31<br>nop<br>beq $1, $6, label_34<br>nop<br>label_34:<br>add $3, $5, $3<br>add $13, $13, $13<br>sw $3, 0($5)<br>sub $5, $3, $1<br>nop<br>sw $5, 0($1)<br>lw $2, 0($4)<br>lw $5, 4($4)<br>add $2, $2, $5<br>sw $2, 0($4)<br>ori $5, $4, 217<br>sub $13, $5, $4<br>ori $6, $3, 27<br>nop<br>ori $9, $6, 239<br>end_loop:<br>nop<br>beq $0, $0, end_loop<br>nop<br></code></pre></td></tr></table></figure><h3 id="思考题9"><a href="#思考题9" class="headerlink" title="思考题9"></a>思考题9</h3><blockquote><p>[P5、P6 选做] 请评估我们给出的覆盖率分析模型的合理性，如有更好的方案，可一并提出。</p></blockquote><p>将于P6完成。</p>]]></content>
    
    
    <categories>
      
      <category>CO课下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>CO课下</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P3上机-问题思路汇总</title>
    <link href="/posts/P3%E4%B8%8A%E6%9C%BA-%E9%97%AE%E9%A2%98%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/"/>
    <url>/posts/P3%E4%B8%8A%E6%9C%BA-%E9%97%AE%E9%A2%98%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="P3上机-问题思路汇总"><a href="#P3上机-问题思路汇总" class="headerlink" title="P3上机-问题思路汇总"></a>P3上机-问题思路汇总</h1><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><p><code>REVI</code>-<code>rs</code>-<code>rt</code>-<code>imm16</code></p><p>I型计算类指令，机器码为<code>101101</code></p><h3 id="指令描述"><a href="#指令描述" class="headerlink" title="指令描述"></a>指令描述</h3><p>将<code>rs</code>中数值高imm16位翻转置于低位，剩余位置不变置于高位，将结果存入<code>rt</code>中。（保证<code>imm16</code>严格小于32）</p><h3 id="RTL语言"><a href="#RTL语言" class="headerlink" title="RTL语言"></a>RTL语言</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">temp &lt;- GRR[rs]<br>result &lt;- temp[31-imm16:0]||reverse(temp[31:32-imm16])<br>GPR[rt] &lt;- result<br></code></pre></td></tr></table></figure><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><h3 id="指令格式-1"><a href="#指令格式-1" class="headerlink" title="指令格式"></a>指令格式</h3><p><code>BLZ</code>-<code>rs</code>-<code>rt</code>-<code>offset</code></p><p>I型跳转类指令+I型计算类指令，机器码为<code>011000</code></p><h3 id="指令描述-1"><a href="#指令描述-1" class="headerlink" title="指令描述"></a>指令描述</h3><p>比较<code>rs</code>、<code>rt</code>中数据先导零的个数，决定跳转方式与存储数据。</p><h3 id="RTL语言-1"><a href="#RTL语言-1" class="headerlink" title="RTL语言"></a>RTL语言</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">temp1 &lt;-count_leading_zeros(GPR[rs])<br>temp2 &lt;-count_leading_zeros(GPR[rt])<br>if (temp1 == temp2) <br>PC &lt;- PC + 4 + sign_ext(offset||00)<br>else if (temp1 &gt; temp2)<br>PC &lt;- PC + 4<br>rs &lt;- temp1<br>else<br>PC &lt;- PC + 4<br>rs &lt;- temp2<br></code></pre></td></tr></table></figure><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><h3 id="指令格式-2"><a href="#指令格式-2" class="headerlink" title="指令格式"></a>指令格式</h3><p><code>LWF</code>-<code>base</code>-<code>rt</code>-<code>offset</code></p><p>I型访存类指令。</p><h3 id="指令描述-2"><a href="#指令描述-2" class="headerlink" title="指令描述"></a>指令描述</h3><p>Load Word with Filter</p><p>根据<code>filter</code>1的个数决定访存所得数据存入<code>rt</code>还是<code>(rt+1)mod32</code>中。</p><h3 id="RTL语言-2"><a href="#RTL语言-2" class="headerlink" title="RTL语言"></a>RTL语言</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">vaddr &lt;- GPR[base] + sign(offset)<br>paddr &lt;- vaddr[31:2]||00<br>memword &lt;- memory[paddr]<br>filter &lt;- memword And GPR[rt]<br>ones &lt;- count_ones(filter)<br>if (ones mod 2 == 0)<br>GPR[rt] &lt;- memword<br>else<br>GPR[(rt+1)mod32] &lt;- memword<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>T1难点在反转，用两个$splitter$序号相反即可，也得点蛮久。</p><p>T2坑点好像是在用$31$减还是$32$，特殊处理找不到$1$的情况。这题想做对有难度，记得当时我卡了很久。</p><p>T3我十分钟一遍过了，只记得过了两道头脑一下清醒了，思路清晰的拿下了这道题。解法好像是只改了顶层，在顶层加点东西就行。</p><h2 id="笔者的话"><a href="#笔者的话" class="headerlink" title="笔者的话"></a>笔者的话</h2><p>如果发现我的解题思路越写越简略，这是正常的，因为实在不记得了555……</p><p>然后讲一讲上机的一些感受，毕竟P3是第一次进入闯关，很多人也会挂在这，我们这届通过率只有百分之三十几，并不高。首先是上机前你会很紧张，真的非常紧张，来回踱步，在机房里等待开始时更是如此，可以尝试深呼吸，想一想其他的事转移一下注意力。如果你在过两题之前发现卡住了，这时候心态包崩的。如果过了两题，那最后一题基本上你的心态会很好，从容优雅的解决最后一道题，因为你心里已经知道自己已经通过了。</p><p>然后是报错信息的问题。相信学长学姐也都教过大家裸交的方法，如果直接裸交自己课下的代码能过两三个点，那基本上就没什么问题，这个基本适用于P5和P7之外的每一关。比如P3，测试点是比较少的，裸交五个点都过了仨，那肯定课下是没问题了。但是你在做加指令题时发现错误信息是课下的指令，比如<code>lw</code>，<code>ori</code>出错，就会怀疑自己的课下。其实这是评测机机制导致的。他只会检测你有<code>GRFwe=1 || DMwe=1</code>的指令，即写寄存器或写内存，这在做P4的过程中就能理解了。可能是新加指令没有写寄存器、写内存，或者你的<code>GRFwe</code>错了、没接线等。</p><p>最后是闯关制的问题。P3-P7一共有三次容错，也就是你可以挂三次P仍然通关计组实验。不用太担心，虽然这个上机贯穿学期始终，花了大量的时间，但是大部分人是可以通关的，可能不是同一批，但几乎不影响分数。</p>]]></content>
    
    
    <categories>
      
      <category>CO上机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>CO上机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P4课下-Verilog单周期CPU</title>
    <link href="/posts/P4%E8%AF%BE%E4%B8%8B-Verilog%E5%8D%95%E5%91%A8%E6%9C%9FCPU/"/>
    <url>/posts/P4%E8%AF%BE%E4%B8%8B-Verilog%E5%8D%95%E5%91%A8%E6%9C%9FCPU/</url>
    
    <content type="html"><![CDATA[<h1 id="CO设计文档—Verilog单周期CPU"><a href="#CO设计文档—Verilog单周期CPU" class="headerlink" title="CO设计文档—Verilog单周期CPU"></a>CO设计文档—Verilog单周期CPU</h1><h2 id="笔者的话"><a href="#笔者的话" class="headerlink" title="笔者的话"></a>笔者的话</h2><p>P4其实和P3类似，不过将P3翻译为Verilog语言，也是对Verilog写出综合性代码的熟悉。从P4开始，课下的详细搭法推荐lmhgg的博客：<a href="https://kamonto.github.io/Kamonto_blog/">Kamonto’s Little Planet</a>，上面讲的非常详细，远比教程好使。越往后教程会越粗糙，到P7教程几乎无法给你任何搭建上的思路，看博客是必要的。大部分同学的博客（包括我的），课下部分都是设计文档直接照搬，一般意义不大，课上部分往往是真题回忆和解题思路等，这些对于上机是极其有用的。</p><h2 id="CPU设计方案综述"><a href="#CPU设计方案综述" class="headerlink" title="CPU设计方案综述"></a>CPU设计方案综述</h2><h3 id="总体设计概述"><a href="#总体设计概述" class="headerlink" title="总体设计概述"></a>总体设计概述</h3><p>整体架构图参考：</p><img src="/posts/P4%E8%AF%BE%E4%B8%8B-Verilog%E5%8D%95%E5%91%A8%E6%9C%9FCPU/%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" class="" title="设计图"><h3 id="设计需求"><a href="#设计需求" class="headerlink" title="设计需求"></a>设计需求</h3><ul><li><p>处理器为 32 位单周期处理器，应支持的指令集为：<strong>add, sub, ori, lw, sw, beq, lui，jal，jr，nop</strong></p><p>，其中：</p><ul><li><code>nop</code> 为空指令，机器码 <code>0x00000000</code>，不进行任何有效行为（修改寄存器等）。</li><li><code>add, sub</code> 按无符号加减法处理（不考虑溢出）。</li></ul></li><li><p>需要采用<strong>模块化</strong>和<strong>层次化</strong>设计。顶层有效的驱动信号要求包括且仅包括<strong>异步复位信号 reset</strong>（$clk$ 使用内置时钟模块）。</p></li></ul><h3 id="关键模块定义"><a href="#关键模块定义" class="headerlink" title="关键模块定义"></a>关键模块定义</h3><h4 id="1-IFU（取址单元）"><a href="#1-IFU（取址单元）" class="headerlink" title="1.IFU（取址单元）"></a>1.IFU（取址单元）</h4><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>异步复位信号</td></tr><tr><td>NPC</td><td>输入</td><td>输入NPC</td></tr><tr><td>PC</td><td>输出</td><td>输出当前指令地址</td></tr><tr><td>Instr</td><td>输出</td><td>输出当前指令码</td></tr></tbody></table></div><p>内含指令储存器IM，将PC中储存的对应地址的指令取出。</p><ul><li>用 ROM 实现，容量为 4096 × 32bit。</li><li><strong>起始地址：0x00003000。</strong></li><li>地址范围：0x00003000 ~ 0x00006FFF。</li><li>ROM 内部的起始地址是从 0 开始的，即 ROM 的 0 位置存储的是 PC 为 0x00003000 的指令，每条指令是一个 32bit 常数。</li><li>经过以上分析，不难发现 ROM 实际地址宽度仅需 $16$ 位，但是<strong>传入的PC地址</strong>是<strong>32位</strong>的，那么我们应该取<code>PC[17:2]</code>接入ROM的输入端</li><li><img src="/posts/P4%E8%AF%BE%E4%B8%8B-Verilog%E5%8D%95%E5%91%A8%E6%9C%9FCPU/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-11-01%20162645-1762473993856-1.png" class="" title="IM"></li></ul><h4 id="2-NPC（次地址计算单元）"><a href="#2-NPC（次地址计算单元）" class="headerlink" title="2.NPC（次地址计算单元）"></a>2.NPC（次地址计算单元）</h4><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>PC[31:0]</td><td>输入</td><td>32位输入当前地址</td></tr><tr><td>Instr[31:0]</td><td>输入</td><td>当前指令</td></tr><tr><td>NPC[31:0]</td><td>输出</td><td>32位输出次地址</td></tr><tr><td>NPCOp[1:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>Rs[31:0]</td><td>输入</td><td><code>$ra</code>寄存器保存的32位地址</td></tr><tr><td>Zero</td><td>输入</td><td><code>$rs</code>与<code>$rt</code>是否相等的标志；1：相等；0：不等</td></tr><tr><td>PC+4[31:0]</td><td>输出</td><td>输出PC+4的值</td></tr></tbody></table></div><h5 id="控制信号说明"><a href="#控制信号说明" class="headerlink" title="控制信号说明"></a>控制信号说明</h5><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>3&#39;b000</code></td><td><code>NPC=PC+4</code></td></tr><tr><td><code>3&#39;b001</code></td><td>执行<code>beq</code>指令</td></tr><tr><td><code>3&#39;b110</code></td><td>执行<code>j</code>，<code>jal</code>指令</td></tr><tr><td><code>3&#39;b111</code></td><td>执行<code>jalr</code>，<code>jr</code>指令</td></tr></tbody></table></div><img src="/posts/P4%E8%AF%BE%E4%B8%8B-Verilog%E5%8D%95%E5%91%A8%E6%9C%9FCPU/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-11-01%20162405.png" class="" title="NPC"><h4 id="3-GRF（寄存器堆）"><a href="#3-GRF（寄存器堆）" class="headerlink" title="3.GRF（寄存器堆）"></a>3.GRF（寄存器堆）</h4><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A1[4:0]</td><td>输入</td><td>5位地址输入信号，将其储存的数据读出到RD1</td></tr><tr><td>A2[4:0]</td><td>输入</td><td>5位地址输入信号，将其储存的数据读出到RD2</td></tr><tr><td>A3[4:0]</td><td>输入</td><td>5位地址输入信号，将其作为写入数据的目标寄存器</td></tr><tr><td>RD1[31:0]</td><td>输出</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr><td>RD2[31:0]</td><td>输出</td><td>输出A2指定的寄存器中的32位数据</td></tr><tr><td>WD[31:0]</td><td>输入</td><td>32位数据输入信号</td></tr><tr><td>WE</td><td>输入</td><td>写使能信号；1：写入有效；0：写入无效</td></tr><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>异步复位信号，将32个寄存器中的数据清零；1：复位；0：无效</td></tr></tbody></table></div><h5 id="控制信号说明-1"><a href="#控制信号说明-1" class="headerlink" title="控制信号说明"></a>控制信号说明</h5><p><strong>1. WRA3Sel</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>2&#39;b00</code></td><td>选择待写入寄存器地址来自<code>Instr[20:16]</code></td></tr><tr><td><code>2&#39;b01</code></td><td>选择待写入寄存器地址来自<code>Instr[15:11]</code></td></tr><tr><td><code>2&#39;b10</code></td><td>选择写入寄存器的地址为31(<code>$ra</code>)</td></tr></tbody></table></div><p><strong>2. WDSel</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>2&#39;b00</code></td><td>选择写入寄存器的数据来自ALU</td></tr><tr><td><code>2&#39;b01</code></td><td>选择写入寄存器的数据来自DM运算结果</td></tr><tr><td><code>2&#39;b10</code></td><td>选择写入寄存器的数据为PC+4</td></tr></tbody></table></div><h4 id="4-EXT（位扩展）"><a href="#4-EXT（位扩展）" class="headerlink" title="4.EXT（位扩展）"></a>4.EXT（位扩展）</h4><p>将16位二进制数进行零扩展或符号扩展到32位</p><p><strong>控制信号说明</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>1&#39;b0</code></td><td>零扩展</td></tr><tr><td><code>1&#39;b1</code></td><td>符号扩展</td></tr></tbody></table></div><img src="/posts/P4%E8%AF%BE%E4%B8%8B-Verilog%E5%8D%95%E5%91%A8%E6%9C%9FCPU/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-11-01%20162755.png" class="" title="EXT"><h4 id="5-ALU（算术逻辑单元）"><a href="#5-ALU（算术逻辑单元）" class="headerlink" title="5.ALU（算术逻辑单元）"></a>5.ALU（算术逻辑单元）</h4><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>输入</td><td>32位输入运算数A</td></tr><tr><td>B[31:0]</td><td>输入</td><td>32位输入运算数B</td></tr><tr><td>C[31:0]</td><td>输出</td><td>32位输出运算结果</td></tr><tr><td>ALUOp[3:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>Zero</td><td>输出</td><td>若$A-B=0$则置为1，否则置为0</td></tr><tr><td>LessZero</td><td>输出</td><td>若$A&lt;B$则置为1，否则置为0</td></tr></tbody></table></div><p><strong>控制信号说明</strong></p><p><strong>1. ALUOp</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>3&#39;b000</code></td><td>执行加法运算</td></tr><tr><td><code>3&#39;b001</code></td><td>执行减法运算</td></tr><tr><td><code>3&#39;b010</code></td><td>执行逻辑与运算</td></tr><tr><td><code>3&#39;b011</code></td><td>执行逻辑或运算</td></tr><tr><td><code>3&#39;b100</code></td><td>执行<code>lui</code>指令</td></tr></tbody></table></div><p><strong>2. ALUBSel</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>1&#39;b0</code></td><td>选择寄存器中的值进行运算</td></tr><tr><td><code>1&#39;b1</code></td><td>选择立即数进行运算</td></tr></tbody></table></div><p><strong>3. ALUASel</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>1&#39;b0</code></td><td>选择寄存器中的值进行运算</td></tr><tr><td><code>1&#39;b1</code></td><td>选择<code>sll</code>指令中移位的位数</td></tr></tbody></table></div><img src="/posts/P4%E8%AF%BE%E4%B8%8B-Verilog%E5%8D%95%E5%91%A8%E6%9C%9FCPU/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-11-01%20162833.png" class="" title="ALU"><h4 id="6-DM（数据储存器）"><a href="#6-DM（数据储存器）" class="headerlink" title="6.DM（数据储存器）"></a>6.DM（数据储存器）</h4><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>Addr[31:0]</td><td>输入</td><td>待操作的内存地址</td></tr><tr><td>WD[31:0]</td><td>输入</td><td>待写入内存的值</td></tr><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>异步复位信号</td></tr><tr><td>DMWr</td><td>输入</td><td>写使能信号；1：写入有效；0：写入无效</td></tr><tr><td>DMOp</td><td>输入</td><td>控制信号</td></tr><tr><td>RD[31:0]</td><td>输出</td><td>输入地址指向的内存中储存的值</td></tr></tbody></table></div><p><strong>控制信号说明</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>2&#39;b00</code></td><td>对应<code>lw</code>和<code>sw</code>指令，写入或读取整个字</td></tr><tr><td><code>2&#39;b01</code></td><td>（保留）对应<code>lh</code>和<code>sh</code>指令，写入或读取半字</td></tr><tr><td><code>2&#39;b10</code></td><td>（保留）对应<code>lb</code>和<code>sb</code>指令，写入或读取整个字</td></tr></tbody></table></div><p>也许对于<code>lbu</code>指令还需要添加额外的控制信号</p><img src="/posts/P4%E8%AF%BE%E4%B8%8B-Verilog%E5%8D%95%E5%91%A8%E6%9C%9FCPU/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-11-01%20163108.png" class="" title="DM"><h3 id="7-Control-控制模块"><a href="#7-Control-控制模块" class="headerlink" title="7.Control-控制模块"></a>7.Control-控制模块</h3><div class="table-container"><table><thead><tr><th>指令</th><th>opcode</th><th>funct</th><th>NPCOp</th><th>WRA3Sel</th><th>WDSel</th><th>EXTOp</th><th>WE</th><th>ALUASel</th><th>ALUBSel</th><th>ALUOp</th><th>DMWr</th><th>DMOp</th></tr></thead><tbody><tr><td><strong>add</strong></td><td>000000</td><td>100000</td><td>000</td><td>01</td><td>00</td><td>X</td><td>1</td><td>0</td><td>0</td><td>000</td><td>0</td><td>X</td></tr><tr><td><strong>sub</strong></td><td>000000</td><td>100010</td><td>000</td><td>01</td><td>00</td><td>X</td><td>1</td><td>0</td><td>0</td><td>001</td><td>0</td><td>X</td></tr><tr><td><strong>ori</strong></td><td>001101</td><td></td><td>000</td><td>00</td><td>00</td><td>0</td><td>1</td><td>0</td><td>1</td><td>011</td><td>0</td><td>X</td></tr><tr><td><strong>lw</strong></td><td>100011</td><td></td><td>000</td><td>00</td><td>01</td><td>1</td><td>1</td><td>0</td><td>1</td><td>000</td><td>0</td><td>00</td></tr><tr><td><strong>sw</strong></td><td>101011</td><td></td><td>000</td><td>00</td><td>01</td><td>1</td><td>0</td><td>0</td><td>1</td><td>000</td><td>1</td><td>00</td></tr><tr><td><strong>beq</strong></td><td>000100</td><td></td><td>001</td><td>X</td><td>X</td><td>1</td><td>0</td><td>0</td><td>0</td><td>001</td><td>0</td><td>X</td></tr><tr><td><strong>lui</strong></td><td>001111</td><td></td><td>000</td><td>00</td><td>00</td><td>X</td><td>1</td><td>0</td><td>1</td><td>100</td><td>0</td><td>X</td></tr><tr><td><strong>jal</strong></td><td>000011</td><td></td><td>110</td><td>10</td><td>10</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td><strong>jr</strong></td><td>000000</td><td>001000</td><td>111</td><td>00</td><td>00</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><h3 id="8-Top-数据通路"><a href="#8-Top-数据通路" class="headerlink" title="8.Top-数据通路"></a>8.Top-数据通路</h3><div class="table-container"><table><thead><tr><th></th><th>取址</th><th>访存</th><th>计算</th><th>存储</th><th>写回</th></tr></thead><tbody><tr><td>$add$</td><td>$PC+4$</td><td>$读出rs$,$rt字段对应的寄存器的值到RD1,RD2$</td><td>$RD1 +RD2 \=ALUans=DMaddr$</td><td>$\textbackslash\DMwr=0$</td><td>$A3=rd\WD=ALUans$</td></tr><tr><td>$sub$</td><td>$PC+4$</td><td>$读出rs,rt字段对应的寄存器的值到RD1,RD2$</td><td>$RD1 - RD2\=ALUans=DMaddr$</td><td>$\textbackslash\DMwr=0$</td><td>$A3=rd\WD=ALUans$</td></tr><tr><td>$ori$</td><td>$PC+4$</td><td>$读出rs字段对应的寄存器的值到RD1,  \ 立即数零扩展$</td><td>$RD1 ~</td><td>~ (zero)imm32\=ALUans=DMaddr$</td><td>$\textbackslash\DMwr=0$</td><td>$A3=rt\WD=ALUans$</td></tr><tr><td>$lw$</td><td>$PC+4$</td><td>$读出rs字段对应的寄存器的值到RD1,  \  立即数符号扩展$</td><td>$RD1+(signed)imm32 \=ALUans=DMaddr$</td><td>$\textbackslash\DMwr=0$</td><td>$A3=rt\WD=DMrd$</td></tr><tr><td>$sw$</td><td>$PC+4$</td><td>$读出rs,rt字段对应的寄存器的值到RD1,RD2        \     立即数符号扩展$</td><td>$RD1+(signed)imm32 \=ALUans=DMaddr$</td><td>$DMWD=RD2\(=grf[rt])$</td><td>$\textbackslash\GRFwe=0$</td></tr><tr><td>$beq$</td><td>$zero=1时:\PC+4+(sign)imm32\zero=0时:PC+4$</td><td>$读出rs,rt字段对应的寄存器的值到RD1,RD2        \     立即数符号扩展$</td><td>$zero=\(RD1-RD2==0)$</td><td>$\textbackslash\DMwr=0$</td><td>$\textbackslash\GRFwe=0$</td></tr><tr><td>$lui$</td><td>$PC+4$</td><td>$立即数零扩展$</td><td>$imm32&lt;&lt;16 \=ALUans=DMaddr$</td><td>$\textbackslash\DMwr=0$</td><td>$A3=rt\WD=ALUans$</td></tr><tr><td>$nop$</td><td>$PC+4$</td><td>$\textbackslash$</td><td>$\textbackslash$</td><td>$\textbackslash\DMwr=0$</td><td>$\textbackslash\GRFwe=0$</td></tr><tr><td>$jal$</td><td>${PC[31:28],Instr[25:0],2’b00}$</td><td>$\textbackslash$</td><td>$\textbackslash$</td><td>$\textbackslash\DMwr=0$</td><td>$A3=1f\WD=PC+4$</td></tr><tr><td>$jr$</td><td>$grf[rs]$</td><td>$读出rs字段对应的寄存器的值到RD1$</td><td>$\textbackslash$</td><td>$\textbackslash\DMwr=0$</td><td>$\textbackslash\GRFwe=0$</td></tr></tbody></table></div><img src="/posts/P4%E8%AF%BE%E4%B8%8B-Verilog%E5%8D%95%E5%91%A8%E6%9C%9FCPU/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-11-01%20163224.png" class="" title="main"><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><p>本次我没有实现一个完整的全自动的评测机，但是实现了半自动的代码生成与对比，仍需手动进行一些操作。</p><p>首先是MIPS汇编代码生成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> grf[<span class="hljs-number">32</span>];<br><span class="hljs-type">int</span> reg[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">31</span>&#125;;<br><span class="hljs-type">int</span> dm[<span class="hljs-number">1024</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R reg[rand() % 5]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I (rand() + rand())</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> B (rand() % 650)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> rt, <span class="hljs-type">int</span> rd)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;add $%d,$%d,$%d\n&quot;</span>, rd, rt, rs);<br>    <span class="hljs-keyword">if</span> (rd)<br>        grf[rd] = grf[rs] + grf[rt];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> rt, <span class="hljs-type">int</span> rd)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sub $%d,$%d,$%d\n&quot;</span>, rd, rt, rs);<br>    <span class="hljs-keyword">if</span> (rd)<br>        grf[rd] = grf[rs] - grf[rt];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ori</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> rt, <span class="hljs-type">int</span> imm)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ori $%d,$%d,%d\n&quot;</span>, rt, rs, imm);<br>    <span class="hljs-keyword">if</span> (rt)<br>        grf[rt] = grf[rs] | imm;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lui</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> rt, <span class="hljs-type">int</span> imm)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;lui $%d,%d\n&quot;</span>, rs, imm);<br>    <span class="hljs-keyword">if</span> (rs)<br>        grf[rs] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)imm &lt;&lt; <span class="hljs-number">16</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lw</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> rt)</span><br>&#123;<br>    <span class="hljs-type">int</span> imm = rand() % <span class="hljs-number">1024</span> * <span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;lw $%d,%d($0)\n&quot;</span>, rt, imm);<br>    grf[rt] = dm[imm / <span class="hljs-number">4</span>];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sw</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> rt)</span><br>&#123;<br>    <span class="hljs-type">int</span> imm = rand() % <span class="hljs-number">1024</span> * <span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sw $%d,%d($0)\n&quot;</span>, rt, imm);<br>    dm[imm / <span class="hljs-number">4</span>] = grf[rt];<br>&#125;<br><br><span class="hljs-type">int</span> jump[<span class="hljs-number">1010</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">beq</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> rt)</span><br>&#123;<br>    <span class="hljs-type">int</span> jaddr = B;<br>    <span class="hljs-keyword">while</span> (jump[jaddr])<br>        jaddr = B;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;beq $%d,$%d,label%d\n&quot;</span>, rs, rt, jaddr);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">jal</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> jaddr = B;<br>    <span class="hljs-keyword">while</span> (jump[jaddr])<br>        jaddr = B;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;jal label%d\n&quot;</span>, jaddr);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">jr</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> rt)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> can[<span class="hljs-number">5</span>];  <span class="hljs-comment">// 替代vector的数组</span><br>    <span class="hljs-type">int</span> can_count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 数组中有效元素的数量</span><br>    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (reg[i] &gt; <span class="hljs-number">0x3000</span> &amp;&amp; reg[i] &lt;= <span class="hljs-number">0x3700</span>) &#123;<br>            can[can_count] = reg[i];<br>            can_count++;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (can_count == <span class="hljs-number">0</span>) &#123;<br>        beq(rs, rt);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    rs = can[rand() % can_count];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;jr $%d\n&quot;</span>, rs);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">nop</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;nop\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    srand(time(<span class="hljs-literal">NULL</span>));<br>    freopen(<span class="hljs-string">&quot;mips_code.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sub $31,$31,$31\n&quot;</span>);<br>    <br>    <span class="hljs-built_in">memset</span>(grf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(grf));<br>    <span class="hljs-built_in">memset</span>(dm, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(dm));<br>    <span class="hljs-built_in">memset</span>(jump, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(jump));<br>    <br>    <span class="hljs-type">int</span> last = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;label%d: &quot;</span>, i);<br>        <span class="hljs-type">int</span> instr = rand() % <span class="hljs-number">10</span>; <br>        <br>        <span class="hljs-keyword">while</span> ((i &lt; <span class="hljs-number">300</span> || last == <span class="hljs-number">1</span>) &amp;&amp; instr &gt;= <span class="hljs-number">6</span> &amp;&amp; instr &lt;= <span class="hljs-number">8</span>)<br>        &#123; <br>            instr = rand() % <span class="hljs-number">10</span>; <br>        &#125;<br>        <br>        <span class="hljs-type">int</span> rs = R, rt = R, rd = R, imm = I;<br>        <br>        <span class="hljs-keyword">if</span> (instr == <span class="hljs-number">0</span>)<br>            add(rs, rt, rd);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instr == <span class="hljs-number">1</span>)<br>            sub(rs, rt, rd);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instr == <span class="hljs-number">2</span>)<br>            ori(rs, rt, imm);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instr == <span class="hljs-number">3</span>)<br>            lui(rs, <span class="hljs-number">0</span>, imm);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instr == <span class="hljs-number">4</span>)<br>            lw(rs, rt);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instr == <span class="hljs-number">5</span>)<br>            sw(rs, rt);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instr == <span class="hljs-number">6</span>)<br>            beq(rs, rt);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instr == <span class="hljs-number">7</span>) <br>            jal();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instr == <span class="hljs-number">8</span>) <br>        &#123;<br>            <span class="hljs-type">int</span> yes = jr(rs, rt);<br>            <span class="hljs-keyword">if</span> (!yes)<br>                instr = <span class="hljs-number">6</span>; <span class="hljs-comment">//beq</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            nop();<br>            <br>        jump[i] = last = (instr &gt;= <span class="hljs-number">6</span> &amp;&amp; instr &lt;= <span class="hljs-number">8</span>); <br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;label:\n beq $0,$0,label\nnop&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时，如果直接将结果导入MARS，会发现<code>add</code>指令出现溢出报错，这是因为我们实现的<code>add</code>是不处理溢出的。所以需要一段字符串匹配代码将<code>add</code>全部替换为<code>addu</code>注入魔改MARS：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LINE_LENGTH 1024</span><br><br><span class="hljs-comment">// 函数：替换字符串中的子串</span><br><span class="hljs-type">char</span>* <span class="hljs-title function_">replace_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* old, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* news)</span> &#123;<br>    <span class="hljs-type">char</span>* result;<br>    <span class="hljs-type">int</span> i, count = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> new_len = <span class="hljs-built_in">strlen</span>(news);<br>    <span class="hljs-type">int</span> old_len = <span class="hljs-built_in">strlen</span>(old);<br>    <br>    <span class="hljs-comment">// 计算需要替换的次数</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; str[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(&amp;str[i], old) == &amp;str[i]) &#123;<br>            count++;<br>            i += old_len - <span class="hljs-number">1</span>; <span class="hljs-comment">// 跳过已匹配的部分</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 分配新字符串的内存</span><br>    result = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(i + count * (new_len - old_len) + <span class="hljs-number">1</span>);<br>    <br>    i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (*str) &#123;<br>        <span class="hljs-comment">// 检查是否找到要替换的子串</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(str, old) == str) &#123;<br>            <span class="hljs-built_in">strcpy</span>(&amp;result[i], news);<br>            i += new_len;<br>            str += old_len;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result[i++] = *str++;<br>        &#125;<br>    &#125;<br>    <br>    result[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    FILE *input_file, *output_file;<br>    <span class="hljs-type">char</span> line[MAX_LINE_LENGTH];<br>    <span class="hljs-type">char</span> *modified_line;<br>    <br>    <span class="hljs-comment">// 打开输入文件</span><br>    input_file = fopen(<span class="hljs-string">&quot;mips_code.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span> (input_file == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;错误：无法打开输入文件 mips_code.txt\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 打开输出文件</span><br>    output_file = fopen(<span class="hljs-string">&quot;mars_code.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-keyword">if</span> (output_file == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;错误：无法创建输出文件 mars_code.txt\n&quot;</span>);<br>        fclose(input_file);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;正在处理文件...\n&quot;</span>);<br>    <br>    <span class="hljs-comment">// 逐行读取输入文件</span><br>    <span class="hljs-keyword">while</span> (fgets(line, <span class="hljs-keyword">sizeof</span>(line), input_file) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// 替换 &quot;add&quot; 为 &quot;addu&quot;</span><br>        modified_line = replace_substring(line, <span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-string">&quot;addu&quot;</span>);<br>        <br>        <span class="hljs-comment">// 写入输出文件</span><br>        <span class="hljs-built_in">fputs</span>(modified_line, output_file);<br>        <br>        <span class="hljs-comment">// 释放内存</span><br>        <span class="hljs-built_in">free</span>(modified_line);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 关闭文件</span><br>    fclose(input_file);<br>    fclose(output_file);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;处理完成！结果已保存到 mars_code.txt\n&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将第一段代码的文件放入MARS汇编后将二进制码<code>Dump to file</code>，让自己的Verilog单周期CPU读入处理，将第二段代码的文件注入魔改MARS运行得到输出日志，使用下方C++对比代码进行文件对比即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">10005</span>;<br><br><span class="hljs-type">char</span> std_ans[MAXN][<span class="hljs-number">40</span>];<br><span class="hljs-type">char</span> src_ans[MAXN][<span class="hljs-number">40</span>];<br><span class="hljs-type">int</span> std_ans_len = <span class="hljs-number">0</span>, src_ans_len = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">comp</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(std_ans_len != src_ans_len) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed at answer length!&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">bool</span> t = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt; std_ans_len; i++) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(std_ans[i], src_ans[i]) != <span class="hljs-number">0</span>) &#123;<br>        t = <span class="hljs-literal">true</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed at line &quot;</span> &lt;&lt; i &lt;&lt; endl;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Your output is &quot;</span>);<span class="hljs-built_in">fputs</span>(src_ans[i], stdout);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The standard output is &quot;</span>);<span class="hljs-built_in">fputs</span>(std_ans[i], stdout);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!t) cout &lt;&lt; <span class="hljs-string">&quot;Passed!&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-comment">//system(&quot;pause&quot;);</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    FILE *std, *src;<br>    std = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;std_out.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    src = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;src_out.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-type">char</span> *temp;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">fgets</span>(std_ans[std_ans_len++], <span class="hljs-number">39</span>, std));<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">fgets</span>(src_ans[src_ans_len++], <span class="hljs-number">39</span>, src));<br>    <span class="hljs-built_in">comp</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样可以实现半自动化的对比。但是，这样的测评仍有缺陷，完全的随机导致难以测到边界条件，以及难以用<code>sw</code>读出已经进行了<code>lw</code>的内存地址，导致总是读出$0$，测试效果不佳。我们可以自行使用魔改MARS写一些边界情形、<code>lw</code>，<code>sw</code>的专门测试等。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asm">ori $t1,$t1,1<br>sw $t1,0($t0)<br>ori $t0,$t0,4<br>ori $t2,$t2,2<br>lui $t1,0x1234<br>sw $t1,0($t0)<br>ori $t1,$t1,2<br>add $t0,$t0,$t0<br>sw $t1,0($t0)<br>lw $s0,-8($t0)<br>lw $s1,-4($t0)<br>lw $t2,0($s2)<br>lui $t3,0xffff<br>ori $t3,$t3,0xffff<br>ori $t4,$t4,1<br>add $t5,$t4,$t3<br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="思考题1"><a href="#思考题1" class="headerlink" title="思考题1"></a>思考题1</h3><blockquote><p>阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？</p></blockquote><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>$addr$信号是从$ALU$的计算结果<code>ALUans</code>来的；DM 的寻址方式是基于<strong>字寻址</strong>而非字节寻址，相当于把$addr$信号左移两位。</p><h3 id="思考题2"><a href="#思考题2" class="headerlink" title="思考题2"></a>思考题2</h3><blockquote><p>思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。</p></blockquote><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><p>“两种方式”指的是直接译码和查表法。即指令$\rightarrow$控制信号与控制信号$\rightarrow$指令的区别。</p><p><strong>方式一：指令 -&gt; 控制信号（正向译码）</strong>：</p><p><strong>思路</strong>：根据指令的操作码，分别生成每条所有控制信号的值。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-keyword">module</span> CTRL(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] Instr,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] NPCop,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] A3slt,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] WDslt,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> GRFwe,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> EXTop,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> ALUAslt,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> ALUBslt,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] ALUop,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> DMWr<br>    );<br> <br><span class="hljs-keyword">parameter</span> R=<span class="hljs-number">6&#x27;b000000</span>;<br><span class="hljs-keyword">parameter</span> add=<span class="hljs-number">6&#x27;b100000</span>;<br><span class="hljs-keyword">parameter</span> sub=<span class="hljs-number">6&#x27;b100010</span>;<br><span class="hljs-keyword">parameter</span> jr=<span class="hljs-number">6&#x27;b001000</span>;<br><span class="hljs-keyword">parameter</span> ori=<span class="hljs-number">6&#x27;b001101</span>;<br><span class="hljs-keyword">parameter</span> lw=<span class="hljs-number">6&#x27;b100011</span>;<br><span class="hljs-keyword">parameter</span> sw=<span class="hljs-number">6&#x27;b101011</span>;<br><span class="hljs-keyword">parameter</span> beq=<span class="hljs-number">6&#x27;b000100</span>;<br><span class="hljs-keyword">parameter</span> lui=<span class="hljs-number">6&#x27;b001111</span>;<br><span class="hljs-keyword">parameter</span> jal=<span class="hljs-number">6&#x27;b000011</span>;<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] opcode,funct;<br><span class="hljs-keyword">assign</span> opcode=Instr[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>];<br><span class="hljs-keyword">assign</span> funct=Instr[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">case</span> (opcode)<br>R: <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">case</span> (funct)<br>add: <span class="hljs-keyword">begin</span><br>NPCop=<span class="hljs-number">3&#x27;b000</span>;<br>A3slt=<span class="hljs-number">1</span>;<span class="hljs-comment">//11-15</span><br>WDslt=<span class="hljs-number">0</span>;<span class="hljs-comment">//ALUans</span><br>GRFwe=<span class="hljs-number">1</span>;<br>EXTop=<span class="hljs-number">0</span>;<br>ALUAslt=<span class="hljs-number">0</span>;<br>ALUBslt=<span class="hljs-number">0</span>;<br>ALUop=<span class="hljs-number">3&#x27;b000</span>;<br>DMWr=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br>sub: <span class="hljs-keyword">begin</span><br>NPCop=<span class="hljs-number">3&#x27;b000</span>;<br>A3slt=<span class="hljs-number">1</span>;<span class="hljs-comment">//11-15</span><br>WDslt=<span class="hljs-number">0</span>;<span class="hljs-comment">//ALUans</span><br>GRFwe=<span class="hljs-number">1</span>;<br>EXTop=<span class="hljs-number">0</span>;<br>ALUAslt=<span class="hljs-number">0</span>;<br>ALUBslt=<span class="hljs-number">0</span>;<br>ALUop=<span class="hljs-number">3&#x27;b001</span>;<br>DMWr=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br>jr: <span class="hljs-keyword">begin</span><br>NPCop=<span class="hljs-number">3&#x27;b111</span>;<br>A3slt=<span class="hljs-number">0</span>;<span class="hljs-comment">//x</span><br>WDslt=<span class="hljs-number">0</span>;<span class="hljs-comment">//x</span><br>GRFwe=<span class="hljs-number">0</span>;<br>EXTop=<span class="hljs-number">0</span>;<br>ALUAslt=<span class="hljs-number">0</span>;<br>ALUBslt=<span class="hljs-number">0</span>;<br>ALUop=<span class="hljs-number">3&#x27;b000</span>;<br>DMWr=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">default</span>: <span class="hljs-keyword">begin</span><span class="hljs-comment">//nop</span><br>NPCop=<span class="hljs-number">3&#x27;b000</span>;<br>A3slt=<span class="hljs-number">0</span>;<span class="hljs-comment">//x</span><br>WDslt=<span class="hljs-number">0</span>;<span class="hljs-comment">//x</span><br>GRFwe=<span class="hljs-number">0</span>;<br>EXTop=<span class="hljs-number">0</span>;<br>ALUAslt=<span class="hljs-number">0</span>;<br>ALUBslt=<span class="hljs-number">0</span>;<br>ALUop=<span class="hljs-number">3&#x27;b000</span>;<br>DMWr=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br>ori: <span class="hljs-keyword">begin</span><br>NPCop=<span class="hljs-number">3&#x27;b000</span>;<br>A3slt=<span class="hljs-number">0</span>;<span class="hljs-comment">//16-20 rt</span><br>WDslt=<span class="hljs-number">0</span>;<span class="hljs-comment">//ALUans</span><br>GRFwe=<span class="hljs-number">1</span>;<br>EXTop=<span class="hljs-number">0</span>;<br>ALUAslt=<span class="hljs-number">0</span>;<br>ALUBslt=<span class="hljs-number">1</span>;<br>ALUop=<span class="hljs-number">3&#x27;b011</span>;<br>DMWr=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br>lw: <span class="hljs-keyword">begin</span><br>NPCop=<span class="hljs-number">3&#x27;b000</span>;<br>A3slt=<span class="hljs-number">0</span>;<span class="hljs-comment">//16-20 rt</span><br>WDslt=<span class="hljs-number">1</span>;<span class="hljs-comment">//DMrd</span><br>GRFwe=<span class="hljs-number">1</span>;<br>EXTop=<span class="hljs-number">1</span>;<br>ALUAslt=<span class="hljs-number">0</span>;<br>ALUBslt=<span class="hljs-number">1</span>;<br>ALUop=<span class="hljs-number">3&#x27;b000</span>;<br>DMWr=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br>sw: <span class="hljs-keyword">begin</span><br>NPCop=<span class="hljs-number">3&#x27;b000</span>;<br>A3slt=<span class="hljs-number">0</span>;<span class="hljs-comment">//x</span><br>WDslt=<span class="hljs-number">0</span>;<span class="hljs-comment">//x</span><br>GRFwe=<span class="hljs-number">0</span>;<br>EXTop=<span class="hljs-number">1</span>;<br>ALUAslt=<span class="hljs-number">0</span>;<br>ALUBslt=<span class="hljs-number">1</span>;<br>ALUop=<span class="hljs-number">3&#x27;b000</span>;<br>DMWr=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">end</span><br>beq: <span class="hljs-keyword">begin</span><br>NPCop=<span class="hljs-number">3&#x27;b001</span>;<br>A3slt=<span class="hljs-number">0</span>;<span class="hljs-comment">//x</span><br>WDslt=<span class="hljs-number">0</span>;<span class="hljs-comment">//x</span><br>GRFwe=<span class="hljs-number">0</span>;<br>EXTop=<span class="hljs-number">1</span>;<br>ALUAslt=<span class="hljs-number">0</span>;<br>ALUBslt=<span class="hljs-number">0</span>;<br>ALUop=<span class="hljs-number">3&#x27;b001</span>;<br>DMWr=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br>lui: <span class="hljs-keyword">begin</span><br>NPCop=<span class="hljs-number">3&#x27;b000</span>;<br>A3slt=<span class="hljs-number">0</span>;<span class="hljs-comment">//16-20 rt</span><br>WDslt=<span class="hljs-number">0</span>;<span class="hljs-comment">//ALUans</span><br>GRFwe=<span class="hljs-number">1</span>;<br>EXTop=<span class="hljs-number">0</span>;<br>ALUAslt=<span class="hljs-number">0</span>;<br>ALUBslt=<span class="hljs-number">1</span>;<br>ALUop=<span class="hljs-number">3&#x27;b100</span>;<br>DMWr=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br>jal: <span class="hljs-keyword">begin</span><br>NPCop=<span class="hljs-number">3&#x27;b110</span>;<br>A3slt=<span class="hljs-number">2&#x27;b10</span>;<span class="hljs-comment">//1f</span><br>WDslt=<span class="hljs-number">2&#x27;b10</span>;<span class="hljs-comment">//PC+4</span><br>GRFwe=<span class="hljs-number">1</span>;<br>EXTop=<span class="hljs-number">0</span>;<br>ALUAslt=<span class="hljs-number">0</span>;<br>ALUBslt=<span class="hljs-number">0</span>;<br>ALUop=<span class="hljs-number">3&#x27;b000</span>;<br>DMWr=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">default</span>: <span class="hljs-keyword">begin</span><br>NPCop=<span class="hljs-number">3&#x27;b000</span>;<br>A3slt=<span class="hljs-number">0</span>;<span class="hljs-comment">//x</span><br>WDslt=<span class="hljs-number">0</span>;<span class="hljs-comment">//x</span><br>GRFwe=<span class="hljs-number">0</span>;<br>EXTop=<span class="hljs-number">0</span>;<br>ALUAslt=<span class="hljs-number">0</span>;<br>ALUBslt=<span class="hljs-number">0</span>;<br>ALUop=<span class="hljs-number">3&#x27;b000</span>;<br>DMWr=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>本人正是使用这种方法。</p><p><strong>方式二：控制信号 -&gt; 指令（反向查表）</strong></p><p><strong>思路</strong>：预先定义好控制信号的组合模式，根据指令查找对应的模式。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">assign</span> EXTop=(lw | sw | beq) ? <span class="hljs-number">1</span>:<span class="hljs-number">0</span><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>上面给出一个示例，这种写起来会简洁一些，但思路并未简单，感觉更容易出错。</p><h4 id="方式一优势："><a href="#方式一优势：" class="headerlink" title="方式一优势："></a>方式一优势：</h4><ol><li><strong>直观易懂</strong>：逻辑流程清晰，易于理解和调试</li><li><strong>灵活性高</strong>：可以方便地添加条件判断和特殊处理</li><li><strong>资源优化</strong>：综合器可能更好地优化逻辑表达式</li><li><strong>适合初学者</strong>：思维模式直接，符合设计直觉</li></ol><h4 id="方式一劣势："><a href="#方式一劣势：" class="headerlink" title="方式一劣势："></a>方式一劣势：</h4><ol><li><strong>维护困难</strong>：指令增多时代码变得冗长</li><li><strong>容易出错</strong>：手动设置每个信号容易遗漏</li><li><strong>扩展性差</strong>：添加新指令需要修改整个case结构</li></ol><h4 id="方式二优势："><a href="#方式二优势：" class="headerlink" title="方式二优势："></a>方式二优势：</h4><ol><li><strong>模块化强</strong>：控制信号模式可复用</li><li><strong>易于维护</strong>：添加新指令只需定义新模式</li><li><strong>代码整洁</strong>：结构清晰，便于团队协作</li><li><strong>可读性好</strong>：信号模式有明确的命名</li></ol><h4 id="方式二劣势："><a href="#方式二劣势：" class="headerlink" title="方式二劣势："></a>方式二劣势：</h4><ol><li><strong>初始设置复杂</strong>：需要预先定义所有模式</li><li><strong>灵活性受限</strong>：特殊处理需要额外逻辑</li><li><strong>可能冗余</strong>：对于简单控制器略显繁琐</li></ol><h3 id="思考题3"><a href="#思考题3" class="headerlink" title="思考题3"></a>思考题3</h3><blockquote><p>在相应的部件中，复位信号的设计都是<strong>同步复位</strong>，这与 P3 中的设计要求不同。请对比<strong>同步复位</strong>与<strong>异步复位</strong>这两种方式的 reset 信号与 clk 信号优先级的关系。</p></blockquote><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><ul><li><strong>同步复位</strong>：<strong><code>clk</code> 信号的优先级高于 <code>reset</code> 信号</strong>。复位信号必须等到时钟的有效边沿到来时，才会被采样并执行复位操作</li><li><strong>异步复位</strong>：<strong><code>reset</code> 信号的优先级高于 <code>clk</code> 信号</strong>。只要复位信号有效，立即进行复位，与时钟边沿无关。</li></ul><p>​    同步复位有延迟、异步复位易受毛刺影响。</p><h3 id="思考题4"><a href="#思考题4" class="headerlink" title="思考题4"></a>思考题4</h3><blockquote><p>C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读<a href="http://cscore.buaa.edu.cn/assets/cscore-assets/MIPS_Vol2_指令集_.pdf">《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》</a>中相关指令的 Operation 部分（详见文档 page 34、page 35）。</p></blockquote><h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><p>在 MIPS 指令集中，<code>addi</code> 和 <code>addiu</code> 以及 <code>add</code> 和 <code>addu</code> 指令在功能上的主要区别在于是否对计算结果进行溢出检查。如果忽略溢出，这些指令在计算结果上是等价的。原因如下：</p><ul><li><strong><code>addi</code> 指令（Add Immediate）</strong>：<br>根据文档第 34 页，<code>addi</code> 指令的操作如下：<ul><li>计算临时值 <code>temp = GPR[rs] + sign_extend(immediate)</code>。</li><li>如果 <code>temp</code> 溢出（即计算结果超出了 32 位有符号整数的范围），则触发整数溢出异常（Integer Overflow Exception）。</li><li>如果没有溢出，则将 <code>temp</code> 写入目标寄存器 <code>GPR[rt]</code>。</li></ul></li><li><strong><code>addiu</code> 指令（Add Immediate Unsigned）</strong>：<br>根据文档第 35 页，<code>addiu</code> 指令的操作如下：<ul><li>计算临时值 <code>temp = GPR[rs] + sign_extend(immediate)</code>。</li><li>直接将 <code>temp</code> 写入目标寄存器 <code>GPR[rt]</code>，不进行溢出检查。</li></ul></li></ul><p>在忽略溢出的前提下，<code>addi</code> 和 <code>addiu</code> 都执行相同的加法操作：将寄存器 <code>rs</code> 的值与符号扩展的立即数相加，并将结果写入寄存器 <code>rt</code>。由于溢出检查被忽略，<code>addi</code> 不会触发异常，因此两者产生的计算结果完全相同。值得注意的是，<code>addiu</code> 中的 “Unsigned” 名称有些误导，因为它实际上使用符号扩展的立即数，操作本身与 <code>addi</code> 在二进制级别是一致的。</p><ul><li><strong><code>add</code> 指令（Add）</strong>：<br>根据文档第 34 页，<code>add</code> 指令的操作如下：<ul><li>计算临时值 <code>temp = GPR[rs] + GPR[rt]</code>。</li><li>如果 <code>temp</code> 溢出（即计算结果超出了 32 位有符号整数的范围），则触发整数溢出异常。</li><li>如果没有溢出，则将 <code>temp</code> 写入目标寄存器 <code>GPR[rd]</code>。</li></ul></li><li><strong><code>addu</code> 指令（Add Unsigned）</strong>：<br>根据文档第 35 页，<code>addu</code> 指令的操作如下：<ul><li>计算临时值 <code>temp = GPR[rs] + GPR[rt]</code>。</li><li>直接将 <code>temp</code> 写入目标寄存器 <code>GPR[rd]</code>，不进行溢出检查。</li></ul></li></ul><p>在忽略溢出的前提下，<code>add</code> 和 <code>addu</code> 都执行相同的加法操作：将寄存器 <code>rs</code> 和 <code>rt</code> 的值相加，并将结果写入寄存器 <code>rd</code>。由于溢出检查被忽略，<code>add</code> 不会触发异常，因此两者产生的计算结果完全相同。同样，<code>addu</code> 的 “Unsigned” 名称并不改变加法操作的本质，在二进制级别，加法器对有符号和无符号数的处理是相同的。</p>]]></content>
    
    
    <categories>
      
      <category>CO课下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>CO课下</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P3课下-logisim单周期CPU</title>
    <link href="/posts/P3%E8%AF%BE%E4%B8%8B-logisim%E5%8D%95%E5%91%A8%E6%9C%9FCPU/"/>
    <url>/posts/P3%E8%AF%BE%E4%B8%8B-logisim%E5%8D%95%E5%91%A8%E6%9C%9FCPU/</url>
    
    <content type="html"><![CDATA[<h1 id="CO设计文档—Logisim单周期CPU"><a href="#CO设计文档—Logisim单周期CPU" class="headerlink" title="CO设计文档—Logisim单周期CPU"></a>CO设计文档—Logisim单周期CPU</h1><h2 id="CPU设计方案综述"><a href="#CPU设计方案综述" class="headerlink" title="CPU设计方案综述"></a>CPU设计方案综述</h2><h3 id="总体设计概述"><a href="#总体设计概述" class="headerlink" title="总体设计概述"></a>总体设计概述</h3><p>整体架构图参考：</p><img src="/posts/P3%E8%AF%BE%E4%B8%8B-logisim%E5%8D%95%E5%91%A8%E6%9C%9FCPU/%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" class="" title="设计图"><h3 id="设计需求"><a href="#设计需求" class="headerlink" title="设计需求"></a>设计需求</h3><ul><li><p>处理器为 32 位单周期处理器，应支持的指令集为：<strong>add, sub, ori, lw, sw, beq, lui, nop</strong></p><p>，其中：</p><ul><li><code>nop</code> 为空指令，机器码 <code>0x00000000</code>，不进行任何有效行为（修改寄存器等）。</li><li><code>add, sub</code> 按无符号加减法处理（不考虑溢出）。</li></ul></li><li><p>需要采用<strong>模块化</strong>和<strong>层次化</strong>设计。顶层有效的驱动信号要求包括且仅包括<strong>异步复位信号 reset</strong>（$clk$ 使用内置时钟模块）。</p></li></ul><h3 id="关键模块定义"><a href="#关键模块定义" class="headerlink" title="关键模块定义"></a>关键模块定义</h3><h4 id="1-PC（程序计数器）"><a href="#1-PC（程序计数器）" class="headerlink" title="1.PC（程序计数器）"></a>1.PC（程序计数器）</h4><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>异步复位信号</td></tr><tr><td>PCIn</td><td>输入</td><td>输入NPC</td></tr><tr><td>PCOut</td><td>输出</td><td>输出当前指令地址</td></tr></tbody></table></div><h4 id="2-NPC（次地址计算单元）"><a href="#2-NPC（次地址计算单元）" class="headerlink" title="2.NPC（次地址计算单元）"></a>2.NPC（次地址计算单元）</h4><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>PC[31:0]</td><td>输入</td><td>32位输入当前地址</td></tr><tr><td>NPC[31:0]</td><td>输出</td><td>32位输出次地址</td></tr><tr><td>NPCOp[1:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>Ra[31:0]</td><td>输入</td><td><code>$ra</code>寄存器保存的32位地址</td></tr><tr><td>Zero</td><td>输入</td><td><code>$rs</code>与<code>$rt</code>是否相等的标志；1：相等；0：不等</td></tr><tr><td>PC+4[31:0]</td><td>输出</td><td>输出PC+4的值</td></tr></tbody></table></div><h5 id="控制信号说明"><a href="#控制信号说明" class="headerlink" title="控制信号说明"></a>控制信号说明</h5><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>3&#39;b000</code></td><td><code>NPC=PC+4</code></td></tr><tr><td><code>3&#39;b001</code></td><td>执行<code>beq</code>指令</td></tr><tr><td><code>3&#39;b110</code></td><td>执行<code>j</code>，<code>jal</code>指令</td></tr><tr><td><code>3&#39;b111</code></td><td>执行<code>jalr</code>，<code>jr</code>指令</td></tr></tbody></table></div><img src="/posts/P3%E8%AF%BE%E4%B8%8B-logisim%E5%8D%95%E5%91%A8%E6%9C%9FCPU/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-11-01%20162405.png" class="" title="NPC"><h4 id="3-IM（指令储存器）"><a href="#3-IM（指令储存器）" class="headerlink" title="3.IM（指令储存器）"></a>3.IM（指令储存器）</h4><p>将PC中储存的对应地址的指令取出。</p><ul><li>I用 ROM 实现，容量为 4096 × 32bit。</li><li><strong>起始地址：0x00003000。</strong></li><li>地址范围：0x00003000 ~ 0x00006FFF。</li><li>ROM 内部的起始地址是从 0 开始的，即 ROM 的 0 位置存储的是 PC 为 0x00003000 的指令，每条指令是一个 32bit 常数。</li><li>经过以上分析，不难发现 ROM 实际地址宽度仅需 12 位，但是<strong>传入的PC地址</strong>是<strong>32位</strong>的，那么我们应该取<code>PC[13:2]</code>接入ROM的输入端</li></ul><img src="/posts/P3%E8%AF%BE%E4%B8%8B-logisim%E5%8D%95%E5%91%A8%E6%9C%9FCPU/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-11-01%20162645.png" class="" title="IM"><h4 id="4-GRF（寄存器堆）"><a href="#4-GRF（寄存器堆）" class="headerlink" title="4.GRF（寄存器堆）"></a>4.GRF（寄存器堆）</h4><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A1[4:0]</td><td>输入</td><td>5位地址输入信号，将其储存的数据读出到RD1</td></tr><tr><td>A2[4:0]</td><td>输入</td><td>5位地址输入信号，将其储存的数据读出到RD2</td></tr><tr><td>A3[4:0]</td><td>输入</td><td>5位地址输入信号，将其作为写入数据的目标寄存器</td></tr><tr><td>RD1[31:0]</td><td>输出</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr><td>RD2[31:0]</td><td>输出</td><td>输出A2指定的寄存器中的32位数据</td></tr><tr><td>WD[31:0]</td><td>输入</td><td>32位数据输入信号</td></tr><tr><td>WE</td><td>输入</td><td>写使能信号；1：写入有效；0：写入无效</td></tr><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>异步复位信号，将32个寄存器中的数据清零；1：复位；0：无效</td></tr></tbody></table></div><h5 id="控制信号说明-1"><a href="#控制信号说明-1" class="headerlink" title="控制信号说明"></a>控制信号说明</h5><p><strong>1. WRA3Sel</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>2&#39;b00</code></td><td>选择待写入寄存器地址来自<code>Instr[20:16]</code></td></tr><tr><td><code>2&#39;b01</code></td><td>选择待写入寄存器地址来自<code>Instr[15:11]</code></td></tr><tr><td><code>2&#39;b10</code></td><td>选择写入寄存器的地址为31(<code>$ra</code>)</td></tr></tbody></table></div><p><strong>2. WDSel</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>2&#39;b00</code></td><td>选择写入寄存器的数据来自ALU</td></tr><tr><td><code>2&#39;b01</code></td><td>选择写入寄存器的数据来自DM运算结果</td></tr><tr><td><code>2&#39;b10</code></td><td>选择写入寄存器的数据为PC+4</td></tr></tbody></table></div><h4 id="5-EXT（位扩展）"><a href="#5-EXT（位扩展）" class="headerlink" title="5.EXT（位扩展）"></a>5.EXT（位扩展）</h4><p>将16位二进制数进行零扩展或符号扩展到32位</p><p><strong>控制信号说明</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>1&#39;b0</code></td><td>零扩展</td></tr><tr><td><code>1&#39;b1</code></td><td>符号扩展</td></tr></tbody></table></div><img src="/posts/P3%E8%AF%BE%E4%B8%8B-logisim%E5%8D%95%E5%91%A8%E6%9C%9FCPU/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-11-01%20162755.png" class="" title="EXT"><h4 id="6-ALU（算术逻辑单元）"><a href="#6-ALU（算术逻辑单元）" class="headerlink" title="6.ALU（算术逻辑单元）"></a>6.ALU（算术逻辑单元）</h4><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>输入</td><td>32位输入运算数A</td></tr><tr><td>B[31:0]</td><td>输入</td><td>32位输入运算数B</td></tr><tr><td>C[31:0]</td><td>输出</td><td>32位输出运算结果</td></tr><tr><td>ALUOp[3:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>Zero</td><td>输出</td><td>若$A-B=0$则置为1，否则置为0</td></tr><tr><td>LessZero</td><td>输出</td><td>若$A&lt;B$则置为1，否则置为0</td></tr></tbody></table></div><p><strong>控制信号说明</strong></p><p><strong>1. ALUOp</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>3&#39;b000</code></td><td>执行加法运算</td></tr><tr><td><code>3&#39;b001</code></td><td>执行减法运算</td></tr><tr><td><code>3&#39;b010</code></td><td>执行逻辑或运算</td></tr><tr><td><code>3&#39;b011</code></td><td>执行<code>sll</code>运算</td></tr><tr><td><code>3&#39;b100</code></td><td>执行<code>lui</code>指令</td></tr></tbody></table></div><p><strong>2. ALUBSel</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>1&#39;b0</code></td><td>选择寄存器中的值进行运算</td></tr><tr><td><code>1&#39;b1</code></td><td>选择立即数进行运算</td></tr></tbody></table></div><p><strong>3. ALUASel</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>1&#39;b0</code></td><td>选择寄存器中的值进行运算</td></tr><tr><td><code>1&#39;b1</code></td><td>选择<code>sll</code>指令中移位的位数</td></tr></tbody></table></div><img src="/posts/P3%E8%AF%BE%E4%B8%8B-logisim%E5%8D%95%E5%91%A8%E6%9C%9FCPU/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-11-01%20162833.png" class="" title="ALU"><h4 id="7-DM（数据储存器）"><a href="#7-DM（数据储存器）" class="headerlink" title="7.DM（数据储存器）"></a>7.DM（数据储存器）</h4><p><strong>端口说明</strong></p><div class="table-container"><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>Addr[31:0]</td><td>输入</td><td>待操作的内存地址</td></tr><tr><td>WD[31:0]</td><td>输入</td><td>待写入内存的值</td></tr><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>异步复位信号</td></tr><tr><td>DMWr</td><td>输入</td><td>写使能信号；1：写入有效；0：写入无效</td></tr><tr><td>DMOp</td><td>输入</td><td>控制信号</td></tr><tr><td>RD[31:0]</td><td>输出</td><td>输入地址指向的内存中储存的值</td></tr></tbody></table></div><p><strong>控制信号说明</strong></p><div class="table-container"><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>2&#39;b00</code></td><td>对应<code>lw</code>和<code>sw</code>指令，写入或读取整个字</td></tr><tr><td><code>2&#39;b01</code></td><td>（保留）对应<code>lh</code>和<code>sh</code>指令，写入或读取半字</td></tr><tr><td><code>2&#39;b10</code></td><td>（保留）对应<code>lb</code>和<code>sb</code>指令，写入或读取整个字</td></tr></tbody></table></div><p>也许对于<code>lbu</code>指令还需要添加额外的控制信号</p><img src="/posts/P3%E8%AF%BE%E4%B8%8B-logisim%E5%8D%95%E5%91%A8%E6%9C%9FCPU/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-11-01%20163108.png" class="" title="DM"><h3 id="8-Control-控制模块"><a href="#8-Control-控制模块" class="headerlink" title="8.Control-控制模块"></a>8.Control-控制模块</h3><div class="table-container"><table><thead><tr><th>指令</th><th>opcode</th><th>funct</th><th>NPCOp</th><th>WRA3Sel</th><th>WDSel</th><th>EXTOp</th><th>WE</th><th>ALUASel</th><th>ALUBSel</th><th>ALUOp</th><th>DMWr</th><th>DMOp</th></tr></thead><tbody><tr><td><strong>add</strong></td><td>000000</td><td>100000</td><td>000</td><td>1</td><td>0</td><td>X</td><td>1</td><td>0</td><td>0</td><td>000</td><td>0</td><td>X</td></tr><tr><td><strong>sub</strong></td><td>000000</td><td>100010</td><td>000</td><td>1</td><td>0</td><td>X</td><td>1</td><td>0</td><td>0</td><td>001</td><td>0</td><td>X</td></tr><tr><td><strong>ori</strong></td><td>001101</td><td></td><td>000</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>011</td><td>0</td><td>X</td></tr><tr><td><strong>lw</strong></td><td>100011</td><td></td><td>000</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>000</td><td>0</td><td>00</td></tr><tr><td><strong>sw</strong></td><td>101011</td><td></td><td>000</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>000</td><td>1</td><td>00</td></tr><tr><td><strong>beq</strong></td><td>000100</td><td></td><td>001</td><td>X</td><td>X</td><td>1</td><td>0</td><td>0</td><td>0</td><td>001</td><td>0</td><td>X</td></tr><tr><td><strong>lui</strong></td><td>001111</td><td></td><td>000</td><td>0</td><td>0</td><td>X</td><td>1</td><td>0</td><td>1</td><td>100</td><td>0</td><td>X</td></tr></tbody></table></div><h3 id="9-Top-数据通路"><a href="#9-Top-数据通路" class="headerlink" title="9.Top-数据通路"></a>9.Top-数据通路</h3><div class="table-container"><table><thead><tr><th></th><th>取址</th><th>访存</th><th>计算</th><th>存储</th><th>写回</th></tr></thead><tbody><tr><td>$add$</td><td>$PC+4$</td><td>$读出rs$,$rt字段对应的寄存器的值到RD1,RD2$</td><td>$RD1 +RD2 \newline =ALUans=DMaddr$</td><td>$DMwr=0$</td><td>$A3=rd\newline WD=ALUans$</td></tr><tr><td>$sub$</td><td>$PC+4$</td><td>$读出rs,rt字段对应的寄存器的值到RD1,RD2$</td><td>$RD1 - RD2\newline =ALUans=DMaddr$</td><td>$DMwr=0$</td><td>$A3=rd\newline WD=ALUans$</td></tr><tr><td>$ori$</td><td>$PC+4$</td><td>$读出rs字段对应的寄存器的值到RD1,  \ 立即数零扩展$</td><td>$RD1 ~</td><td>~ (zero)imm32\newline =ALUans=DMaddr$</td><td>$DMwr=0$</td><td>$A3=rt\newline WD=ALUans$</td></tr><tr><td>$lw$</td><td>$PC+4$</td><td>$读出rs字段对应的寄存器的值到RD1,  \  立即数符号扩展$</td><td>$RD1+(signed)imm32 \newline =ALUans=DMaddr$</td><td>$DMwr=0$</td><td>$A3=rt\newline WD=DMrd$</td></tr><tr><td>$sw$</td><td>$PC+4$</td><td>$读出rs,rt字段对应的寄存器的值到RD1,RD2        \     立即数符号扩展$</td><td>$RD1+(signed)imm32 \newline =ALUans=DMaddr$</td><td>$DMWD=RD2\newline (=grf[rt])$</td><td>$GRFwe=0$</td></tr><tr><td>$beq$</td><td>$zero=1时: \newline PC+4+(sign)imm32\newline zero=0时:PC+4$</td><td>$读出rs,rt字段对应的寄存器的值到RD1,RD2        \     立即数符号扩展$</td><td>$zero=\newline (RD1-RD2==0)$</td><td>$DMwr=0$</td><td>$GRFwe=0$</td></tr><tr><td>$lui$</td><td>$PC+4$</td><td>$立即数零扩展$</td><td>$imm32&lt;&lt;16 \newline =ALUans=DMaddr$</td><td>$DMwr=0$</td><td>$A3=rt\newline WD=ALUans$</td></tr><tr><td>$nop$</td><td>$PC+4$</td><td>\</td><td>\</td><td>$DMwr=0$</td><td>$GRFwe=0$</td></tr></tbody></table></div><img src="/posts/P3%E8%AF%BE%E4%B8%8B-logisim%E5%8D%95%E5%91%A8%E6%9C%9FCPU/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-11-01%20163224.png" class="" title="main"><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><p>本人搭了一整天才初步完成评测机（对拍机），后来又维护修修改改了半天，中间遇到了一些问题，最后直到6.0版本才出完全体。其实代码挺史山的，全部挤在一个文件里。</p><p>我们发现课下数据是很弱的，但即便如此我也卡了好一会儿。首先是$PC$，需要$+3000$输出；其次是$beq$，我第一遍误对其立即数段进行了零扩展，事实上$beq$可能往前跳可能往后跳，所以显然是要进行符号扩展的。</p><p>评测机的构建思路大致是这样：</p><blockquote><ol><li>初始化模块配置环境参数和路径</li><li>用python/C++自己写生成mips代码的，毕竟格式都是固定的，比如add $1,$2,$3这种，把指令字符串放两个集合分别存R型和I型，分别按指令格式用随机数抽取每个字段循环生成拼接在一起，输出到一个asm文件里；</li><li>写一个命令行的字符串，程序运行时自动调用MARS进行汇编</li><li>是注入，用正则表达式匹配ROM，然后命令行写入ROM当中</li><li>使用命令行运行Logisim电路并捕获输出</li><li>等15s跑完后对比结果，手写compare函数进行智能对比</li></ol></blockquote><p>在搭建评测机过程中，我遇到了不少问题，在此做一个小小的汇总：</p><ol><li>无法将机器码注入ROM，可能是正则表达式匹配错误，不知道正则表达式怎么写可以把$logisim$用记事本打开，喂给ai让它帮你写这一部分；</li><li>$nop$与$beq$信号每个人处理得不同。当指令为$nop$，$beq$时，会有很多无用的信号，比如$grf$的$WD$，$DM$的$Addr$等。这就意味着我们比对的时候不能直接使用$Python$内置的文件比较方法，而是要自己手写，提取出每个字段是哪个信号，并特殊处理选择性匹配。</li><li>如果对拍过程中出现有人仅输出一行全是$0$，可能是他没有把$main$设为主电路导致的。原理不明。</li><li>要想电路能停下来，可以使用计数器<code>counter</code>并连出一个输出端口<code>halt</code>，当这个端口置为1时，Logisim会自动检测到，停止仿真模拟，你的评测机就能正常返回继续下一步比对了。</li><li>$lw$指令后面的立即数不能太大，是有范围要求的。生成随机数据时进行限制。</li></ol><p>下面给出一部分代码，评测机可在此处下载：</p><a class="btn" href="/files/P3Judger.zip"  title="fas fa-download" target="_blank">P3Judger</a><p>$MIPS$汇编代码生成（这段亦可用C++实现）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_mips_code</span>(<span class="hljs-params">self, num_instructions, test_id</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    生成随机的MIPS汇编代码，考虑地址限制</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 使用测试ID和时间作为随机种子，确保每次测试生成不同的代码</span><br>    random.seed(time.time() + test_id)<br><br>    instructions = []<br>    labels = &#123;&#125;  <span class="hljs-comment"># 用于beq跳转的标签</span><br>    data_segment = []  <span class="hljs-comment"># 数据段</span><br><br>    <span class="hljs-comment"># 初始化当前PC（假设从0开始）</span><br>    <span class="hljs-variable language_">self</span>.current_pc = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 生成一些标签用于beq跳转，确保在PC范围内</span><br>    label_count = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, num_instructions // <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(label_count):<br>        <span class="hljs-comment"># 标签位置在当前PC范围内</span><br>        label_pos = random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">min</span>(num_instructions - <span class="hljs-number">1</span>, (<span class="hljs-variable language_">self</span>.max_pc - <span class="hljs-variable language_">self</span>.current_pc) // <span class="hljs-number">4</span>))<br>        labels[<span class="hljs-string">f&quot;label_<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>] = label_pos<br><br>    <span class="hljs-comment"># 添加数据段（在代码之前）</span><br>    data_size = <span class="hljs-built_in">min</span>(<span class="hljs-number">32</span>, num_instructions // <span class="hljs-number">3</span>)  <span class="hljs-comment"># 数据大小限制</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(data_size):<br>        data_value = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">0xFFFFFFFF</span>)<br>        data_segment.append(<span class="hljs-string">f&quot;data_<span class="hljs-subst">&#123;i&#125;</span>: .word <span class="hljs-subst">&#123;data_value&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 添加数据段声明</span><br>    <span class="hljs-keyword">if</span> data_segment:<br>        instructions.append(<span class="hljs-string">&quot;.data&quot;</span>)<br>        instructions.extend(data_segment)<br>        instructions.append(<span class="hljs-string">&quot;&quot;</span>)  <span class="hljs-comment"># 空行分隔</span><br><br>    <span class="hljs-comment"># 添加代码段</span><br>    instructions.append(<span class="hljs-string">&quot;.text&quot;</span>)<br><br>    <span class="hljs-comment"># 初始化一些寄存器，避免未定义行为</span><br>    instructions.append(<span class="hljs-string">&quot;ori $1, $0, 0&quot;</span>)  <span class="hljs-comment"># 初始化$1为0</span><br>    instructions.append(<span class="hljs-string">&quot;ori $2, $0, 0&quot;</span>)  <span class="hljs-comment"># 初始化$2为0</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_instructions):<br>        <span class="hljs-comment"># 更新当前PC（每条指令4字节）</span><br>        <span class="hljs-variable language_">self</span>.current_pc = (i + <span class="hljs-number">2</span>) * <span class="hljs-number">4</span>  <span class="hljs-comment"># 加上初始化的2条指令</span><br><br>        <span class="hljs-comment"># 随机决定是否在当前指令前插入标签</span><br>        <span class="hljs-keyword">for</span> label_name, label_pos <span class="hljs-keyword">in</span> labels.items():<br>            <span class="hljs-keyword">if</span> label_pos == i:<br>                instructions.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;label_name&#125;</span>:&quot;</span>)<br><br>        instr_type = random.choice([<span class="hljs-string">&#x27;r_type&#x27;</span>, <span class="hljs-string">&#x27;i_type&#x27;</span>, <span class="hljs-string">&#x27;other&#x27;</span>])<br><br>        <span class="hljs-keyword">if</span> instr_type == <span class="hljs-string">&#x27;r_type&#x27;</span>:<br>            <span class="hljs-comment"># R-type指令: add, sub</span><br>            op = random.choice(<span class="hljs-variable language_">self</span>.r_type_ops)<br>            rd, rs, rt = random.sample(<span class="hljs-variable language_">self</span>.registers, <span class="hljs-number">3</span>)<br>            instructions.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;op&#125;</span> $<span class="hljs-subst">&#123;rd&#125;</span>, $<span class="hljs-subst">&#123;rs&#125;</span>, $<span class="hljs-subst">&#123;rt&#125;</span>&quot;</span>)<br><br>        <span class="hljs-keyword">elif</span> instr_type == <span class="hljs-string">&#x27;i_type&#x27;</span>:<br>            <span class="hljs-comment"># I-type指令: ori, lw, sw, beq, lui</span><br>            op = random.choice(<span class="hljs-variable language_">self</span>.i_type_ops)<br><br>            <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;lui&#x27;</span>:<br>                <span class="hljs-comment"># lui指令: lui rt, immediate</span><br>                rt = random.choice(<span class="hljs-variable language_">self</span>.registers)<br>                imm = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">65535</span>)<br>                instructions.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;op&#125;</span> $<span class="hljs-subst">&#123;rt&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;beq&#x27;</span>:<br>                <span class="hljs-comment"># beq需要跳转标签，确保在PC范围内</span><br>                rs, rt = random.sample(<span class="hljs-variable language_">self</span>.registers, <span class="hljs-number">2</span>)<br>                <span class="hljs-keyword">if</span> labels:<br>                    <span class="hljs-comment"># 只选择在当前指令之前的标签，避免向前跳转太远</span><br>                    available_labels = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> labels.items() <span class="hljs-keyword">if</span> v &lt; i&#125;<br>                    <span class="hljs-keyword">if</span> available_labels:<br>                        target_label = random.choice(<span class="hljs-built_in">list</span>(available_labels.keys()))<br>                        instructions.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;op&#125;</span> $<span class="hljs-subst">&#123;rs&#125;</span>, $<span class="hljs-subst">&#123;rt&#125;</span>, <span class="hljs-subst">&#123;target_label&#125;</span>&quot;</span>)<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-comment"># 如果没有合适的标签，使用nop</span><br>                        instructions.append(<span class="hljs-string">&quot;nop&quot;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 如果没有标签，生成一个相对跳转，限制范围</span><br>                    max_offset = <span class="hljs-built_in">min</span>(<span class="hljs-number">127</span>, (<span class="hljs-variable language_">self</span>.max_pc - <span class="hljs-variable language_">self</span>.current_pc) // <span class="hljs-number">4</span> - <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">if</span> max_offset &gt; <span class="hljs-number">0</span>:<br>                        offset = random.randint(<span class="hljs-number">1</span>, max_offset)<br>                        instructions.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;op&#125;</span> $<span class="hljs-subst">&#123;rs&#125;</span>, $<span class="hljs-subst">&#123;rt&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>&quot;</span>)<br>                    <span class="hljs-keyword">else</span>:<br>                        instructions.append(<span class="hljs-string">&quot;nop&quot;</span>)<br><br>            <span class="hljs-keyword">elif</span> op <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;lw&#x27;</span>, <span class="hljs-string">&#x27;sw&#x27;</span>]:<br>                <span class="hljs-comment"># 内存访问指令，确保在DM范围内</span><br>                rs, rt = random.sample(<span class="hljs-variable language_">self</span>.registers, <span class="hljs-number">2</span>)<br>                <span class="hljs-comment"># 使用小偏移量，避免需要多条指令</span><br>                max_offset = <span class="hljs-built_in">min</span>(<span class="hljs-number">124</span>, <span class="hljs-variable language_">self</span>.max_dm) &amp; <span class="hljs-number">0xFFFC</span>  <span class="hljs-comment"># 确保是4的倍数且不超过范围</span><br>                <span class="hljs-keyword">if</span> max_offset &gt;= <span class="hljs-number">4</span>:<br>                    offset = random.randint(<span class="hljs-number">0</span>, max_offset // <span class="hljs-number">4</span>) * <span class="hljs-number">4</span><br>                    instructions.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;op&#125;</span> $<span class="hljs-subst">&#123;rt&#125;</span>, <span class="hljs-subst">&#123;offset&#125;</span>($<span class="hljs-subst">&#123;rs&#125;</span>)&quot;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 如果偏移量太小，使用ori替代</span><br>                    imm = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">65535</span>)<br>                    instructions.append(<span class="hljs-string">f&quot;ori $<span class="hljs-subst">&#123;rt&#125;</span>, $<span class="hljs-subst">&#123;rs&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># ori指令</span><br>                rs, rt = random.sample(<span class="hljs-variable language_">self</span>.registers, <span class="hljs-number">2</span>)<br>                imm = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">65535</span>)<br>                instructions.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;op&#125;</span> $<span class="hljs-subst">&#123;rt&#125;</span>, $<span class="hljs-subst">&#123;rs&#125;</span>, <span class="hljs-subst">&#123;imm&#125;</span>&quot;</span>)<br><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 其他指令: nop</span><br>            instructions.append(<span class="hljs-string">&quot;nop&quot;</span>)<br><br>        <span class="hljs-comment"># 检查PC是否超出范围</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.current_pc &gt; <span class="hljs-variable language_">self</span>.max_pc - <span class="hljs-number">8</span>:  <span class="hljs-comment"># 留出空间给结束指令</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;  ! PC接近上限，提前结束指令生成&quot;</span>)<br>            <span class="hljs-keyword">break</span><br><br>    <span class="hljs-comment"># 在代码末尾添加停机指令 - 使用更可靠的停机方式 - 实现j指令后可用</span><br>    <span class="hljs-comment">#instructions.append(&quot;end_loop:&quot;)</span><br>    <span class="hljs-comment">#instructions.append(&quot;ori $1, $0, 1&quot;)  # 设置$1=1</span><br>    <span class="hljs-comment">#instructions.append(&quot;beq $1, $0, end_loop&quot;)  # 条件永远不成立，继续执行</span><br>    <span class="hljs-comment">#instructions.append(&quot;j end_loop&quot;)  # 无条件跳转到循环开始</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n&quot;</span>.join(instructions)<br><br></code></pre></td></tr></table></figure><p>调用Mars生成机器码的cmd指令格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">cmd = [<br>    <span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;-jar&#x27;</span>, <span class="hljs-variable language_">self</span>.mars_path,<br>    <span class="hljs-variable language_">self</span>.asm_file,<br>    <span class="hljs-string">&#x27;nc&#x27;</span>, <span class="hljs-string">&#x27;mc&#x27;</span>, <span class="hljs-string">&#x27;CompactDataAtZero&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,<br>    <span class="hljs-string">&#x27;dump&#x27;</span>, <span class="hljs-string">&#x27;.text&#x27;</span>, <span class="hljs-string">&#x27;HexText&#x27;</span>, <span class="hljs-variable language_">self</span>.machine_code_file<br>]<br></code></pre></td></tr></table></figure><p>匹配ROM的正则表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">r&#x27;(addr/data: 12 32\n).*?(&lt;/a&gt;)&#x27;</span><br></code></pre></td></tr></table></figure><p>比较函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compare_outputs</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    比较两个CPU的输出结果，考虑使能信号</span><br><span class="hljs-string">    输出顺序: Instr, pc, RegWrite, RegAddr, RegData, MemWrite, MemAddr, MemData</span><br><span class="hljs-string">    每个32位信号被分成8个4位字段</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 读取输出文件</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-variable language_">self</span>.my_output, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            my_output = f.readlines()<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-variable language_">self</span>.ref_output, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            ref_output = f.readlines()<br><br>        <span class="hljs-comment"># 比较行数</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(my_output) != <span class="hljs-built_in">len</span>(ref_output):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;  我的CPU输出行数: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(my_output)&#125;</span>&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;  参考CPU输出行数: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(ref_output)&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>, <span class="hljs-string">f&quot;输出行数不同: 我的输出<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(my_output)&#125;</span>行, 参考输出<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(ref_output)&#125;</span>行&quot;</span><br><br>        <span class="hljs-comment"># 逐行比较</span><br>        <span class="hljs-keyword">for</span> i, (my_line, ref_line) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(my_output, ref_output)):<br>            my_parts = my_line.strip().split()<br>            ref_parts = ref_line.strip().split()<br><br>            <span class="hljs-comment"># 检查行格式是否一致</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(my_parts) != <span class="hljs-built_in">len</span>(ref_parts):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>, <span class="hljs-string">f&quot;第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>行字段数不同:\n我的输出: <span class="hljs-subst">&#123;my_line.strip()&#125;</span> (字段数: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(my_parts)&#125;</span>)\n参考输出: <span class="hljs-subst">&#123;ref_line.strip()&#125;</span> (字段数: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(ref_parts)&#125;</span>)&quot;</span><br><br>            <span class="hljs-comment"># 根据输出顺序解析信号</span><br>            <span class="hljs-comment"># 每个32位信号被分成8个4位字段</span><br>            <span class="hljs-comment"># 计算每个信号的字段范围</span><br>            <span class="hljs-comment"># Instr: 字段 0-7 (8个字段，32位)</span><br>            <span class="hljs-comment"># pc: 字段 8-15 (8个字段，32位)</span><br>            <span class="hljs-comment"># RegWrite: 字段 16 (1个字段，1位)</span><br>            <span class="hljs-comment"># RegAddr: 字段 17-18 (2个字段，5位)</span><br>            <span class="hljs-comment"># RegData: 字段 19-26 (8个字段，32位)</span><br>            <span class="hljs-comment"># MemWrite: 字段 27 (1个字段，1位)</span><br>            <span class="hljs-comment"># MemAddr: 字段 28-35 (8个字段，32位)</span><br>            <span class="hljs-comment"># MemData: 字段 36-43 (8个字段，32位)</span><br><br>            <span class="hljs-comment"># 提取使能信号</span><br>            my_reg_write = my_parts[<span class="hljs-number">16</span>].lower()<br>            ref_reg_write = ref_parts[<span class="hljs-number">16</span>].lower()<br>            my_mem_write = my_parts[<span class="hljs-number">27</span>].lower()<br>            ref_mem_write = ref_parts[<span class="hljs-number">27</span>].lower()<br><br>            <span class="hljs-comment"># 检查是否为nop指令</span><br>            <span class="hljs-comment"># nop指令的机器码是0x00000000</span><br>            my_instr = <span class="hljs-string">&#x27;&#x27;</span>.join(my_parts[<span class="hljs-number">0</span>:<span class="hljs-number">8</span>])  <span class="hljs-comment"># 合并Instr字段</span><br>            ref_instr = <span class="hljs-string">&#x27;&#x27;</span>.join(ref_parts[<span class="hljs-number">0</span>:<span class="hljs-number">8</span>])  <span class="hljs-comment"># 合并Instr字段</span><br><br>            is_nop = (my_instr == <span class="hljs-string">&#x27;00000000000000000000000000000000&#x27;</span> <span class="hljs-keyword">and</span><br>                      ref_instr == <span class="hljs-string">&#x27;00000000000000000000000000000000&#x27;</span>)<br><br>            <span class="hljs-comment"># 比较所有信号，但根据使能信号忽略不重要的信号</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(my_parts)):<br>                skip_comparison = <span class="hljs-literal">False</span><br>                signal_name = <span class="hljs-string">&quot;&quot;</span><br><br>                <span class="hljs-comment"># 确定信号名称和范围</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= j &lt;= <span class="hljs-number">7</span>:<br>                    signal_name = <span class="hljs-string">&quot;Instr&quot;</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-number">8</span> &lt;= j &lt;= <span class="hljs-number">15</span>:<br>                    signal_name = <span class="hljs-string">&quot;PC&quot;</span><br>                <span class="hljs-keyword">elif</span> j == <span class="hljs-number">16</span>:<br>                    signal_name = <span class="hljs-string">&quot;RegWrite&quot;</span><br>                    <span class="hljs-comment"># 如果是nop指令，允许RegWrite不同</span><br>                    <span class="hljs-keyword">if</span> is_nop <span class="hljs-keyword">and</span> my_reg_write != ref_reg_write:<br>                        <span class="hljs-comment"># 检查是否一方为0，另一方为1但RegAddr为0</span><br>                        my_reg_addr = <span class="hljs-string">&#x27;&#x27;</span>.join(my_parts[<span class="hljs-number">17</span>:<span class="hljs-number">19</span>])  <span class="hljs-comment"># 合并RegAddr字段</span><br>                        ref_reg_addr = <span class="hljs-string">&#x27;&#x27;</span>.join(ref_parts[<span class="hljs-number">17</span>:<span class="hljs-number">19</span>])  <span class="hljs-comment"># 合并RegAddr字段</span><br><br>                        <span class="hljs-comment"># 如果一方为0，另一方为1且RegAddr为0，允许</span><br>                        <span class="hljs-keyword">if</span> ((my_reg_write == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ref_reg_write == <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> ref_reg_addr == <span class="hljs-string">&#x27;00000&#x27;</span>) <span class="hljs-keyword">or</span><br>                                (my_reg_write == <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> ref_reg_write == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> my_reg_addr == <span class="hljs-string">&#x27;00000&#x27;</span>)):<br>                            skip_comparison = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-number">17</span> &lt;= j &lt;= <span class="hljs-number">18</span>:<br>                    signal_name = <span class="hljs-string">&quot;RegAddr&quot;</span><br>                    <span class="hljs-comment"># 如果RegWrite=0，跳过RegAddr比较</span><br>                    <span class="hljs-keyword">if</span> my_reg_write == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ref_reg_write == <span class="hljs-string">&#x27;0&#x27;</span>:<br>                        skip_comparison = <span class="hljs-literal">True</span><br>                    <span class="hljs-comment"># 如果是nop指令且RegWrite不同，跳过比较</span><br>                    <span class="hljs-keyword">elif</span> is_nop <span class="hljs-keyword">and</span> my_reg_write != ref_reg_write:<br>                        skip_comparison = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-number">19</span> &lt;= j &lt;= <span class="hljs-number">26</span>:<br>                    signal_name = <span class="hljs-string">&quot;RegData&quot;</span><br>                    <span class="hljs-comment"># 如果RegWrite=0，跳过RegData比较</span><br>                    <span class="hljs-keyword">if</span> my_reg_write == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ref_reg_write == <span class="hljs-string">&#x27;0&#x27;</span>:<br>                        skip_comparison = <span class="hljs-literal">True</span><br>                    <span class="hljs-comment"># 如果是nop指令且RegWrite不同，跳过比较</span><br>                    <span class="hljs-keyword">elif</span> is_nop <span class="hljs-keyword">and</span> my_reg_write != ref_reg_write:<br>                        skip_comparison = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">elif</span> j == <span class="hljs-number">27</span>:<br>                    signal_name = <span class="hljs-string">&quot;MemWrite&quot;</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-number">28</span> &lt;= j &lt;= <span class="hljs-number">35</span>:<br>                    signal_name = <span class="hljs-string">&quot;MemAddr&quot;</span><br>                    <span class="hljs-comment"># 如果MemWrite=0，跳过MemAddr比较</span><br>                    <span class="hljs-keyword">if</span> my_mem_write == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ref_mem_write == <span class="hljs-string">&#x27;0&#x27;</span>:<br>                        skip_comparison = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-number">36</span> &lt;= j &lt;= <span class="hljs-number">43</span>:<br>                    signal_name = <span class="hljs-string">&quot;MemData&quot;</span><br>                    <span class="hljs-comment"># 如果MemWrite=0，跳过MemData比较</span><br>                    <span class="hljs-keyword">if</span> my_mem_write == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> ref_mem_write == <span class="hljs-string">&#x27;0&#x27;</span>:<br>                        skip_comparison = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 未知字段，跳过比较</span><br>                    <span class="hljs-keyword">continue</span><br><br>                <span class="hljs-comment"># 跳过比较或在需要时比较</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> skip_comparison <span class="hljs-keyword">and</span> my_parts[j] != ref_parts[j]:<br>                    <span class="hljs-comment"># 检查是否是因为使能信号不同导致的</span><br>                    <span class="hljs-keyword">if</span> signal_name <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;RegAddr&quot;</span>, <span class="hljs-string">&quot;RegData&quot;</span>] <span class="hljs-keyword">and</span> (my_reg_write != ref_reg_write):<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>, <span class="hljs-string">f&quot;第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>行<span class="hljs-subst">&#123;signal_name&#125;</span>[字段<span class="hljs-subst">&#123;j&#125;</span>]不同且RegWrite使能信号也不同:\n我的RegWrite: <span class="hljs-subst">&#123;my_reg_write&#125;</span>, 参考RegWrite: <span class="hljs-subst">&#123;ref_reg_write&#125;</span>\n我的<span class="hljs-subst">&#123;signal_name&#125;</span>: <span class="hljs-subst">&#123;my_parts[j]&#125;</span>\n参考<span class="hljs-subst">&#123;signal_name&#125;</span>: <span class="hljs-subst">&#123;ref_parts[j]&#125;</span>&quot;</span><br>                    <span class="hljs-keyword">elif</span> signal_name <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;MemAddr&quot;</span>, <span class="hljs-string">&quot;MemData&quot;</span>] <span class="hljs-keyword">and</span> (my_mem_write != ref_mem_write):<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>, <span class="hljs-string">f&quot;第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>行<span class="hljs-subst">&#123;signal_name&#125;</span>[字段<span class="hljs-subst">&#123;j&#125;</span>]不同且MemWrite使能信号也不同:\n我的MemWrite: <span class="hljs-subst">&#123;my_mem_write&#125;</span>, 参考MemWrite: <span class="hljs-subst">&#123;ref_mem_write&#125;</span>\n我的<span class="hljs-subst">&#123;signal_name&#125;</span>: <span class="hljs-subst">&#123;my_parts[j]&#125;</span>\n参考<span class="hljs-subst">&#123;signal_name&#125;</span>: <span class="hljs-subst">&#123;ref_parts[j]&#125;</span>&quot;</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>, <span class="hljs-string">f&quot;第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>行<span class="hljs-subst">&#123;signal_name&#125;</span>[字段<span class="hljs-subst">&#123;j&#125;</span>]不同:\n我的输出: <span class="hljs-subst">&#123;my_parts[j]&#125;</span>\n参考输出: <span class="hljs-subst">&#123;ref_parts[j]&#125;</span>&quot;</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>, <span class="hljs-string">&quot;所有输出完全匹配&quot;</span><br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>, <span class="hljs-string">f&quot;比较输出时出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="思考题1"><a href="#思考题1" class="headerlink" title="思考题1"></a>思考题1</h3><blockquote><p>上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</p></blockquote><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="状态存储模块"><a href="#状态存储模块" class="headerlink" title="状态存储模块"></a>状态存储模块</h4><ul><li><strong>grf</strong>（通用寄存器文件）：存储 CPU 的寄存器值，是数据状态的核心存储部分。</li><li><strong>DM</strong>（数据存储器）：存储数据，用于加载和存储操作，是内存状态的一部分。</li><li><strong>IM</strong>（指令存储器）：存储程序指令，虽然通常为只读，但作为指令的存储，它保存了 CPU 的程序状态。</li><li><strong>PC</strong>（程序计数器）：存当前指令地址</li></ul><h4 id="状态转移模块"><a href="#状态转移模块" class="headerlink" title="状态转移模块"></a>状态转移模块</h4><ul><li><strong>Ctrl</strong>（控制单元）：根据当前指令生成控制信号，指导其他模块的操作，实现状态转移的控制。</li><li><strong>NPC</strong>（下一个程序计数器）：计算下一条指令的地址，通过增量或跳转改变程序流程，实现程序状态的转移。</li><li><strong>ALU</strong>（算术逻辑单元）：执行算术和逻辑运算，改变数据值，实现数据状态的转移。</li><li><strong>EXT</strong>（扩展单元）：对立即数进行符号扩展或零扩展，改变数据格式，实现数据状态的转移。</li></ul><h3 id="思考题2"><a href="#思考题2" class="headerlink" title="思考题2"></a>思考题2</h3><blockquote><p>现在我们的模块中 IM 使用 ROM，DM 使用 RAM，GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。</p></blockquote><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><p>合理；IM只需被读取，ROM只有读取功能；DM既要进行读取，又要进行写入，但是一个周期只会进行读取和写入之一，RAM的单一地址和各一个的读写端口满足了这种要求。用寄存器也能实现DM，但是DM需要较大的空间，使用寄存器太“浪费”；GRF需要读写，且其与ALU直接连接，需要高速地读写，故使用寄存器堆搭建合理。</p><p>改进的话，在单周期CPU这应该已经是最佳方案了，在流水线CPU可以将DM改为同步读存储器。</p><p>在查阅资料后，我发现有一种将IM与DM合并，使用统一的、可读可写的主存储器的结构，也就是所谓的“冯·诺依曼架构”，但对CPU核心而言，它看到的应该仍然是分开的指令流和数据流。</p><p>对 GRF 的改进，可能需要考虑读写同步的问题，可能要规定在同一时钟边沿，读操作看到的是写操作之前的值，如果读出新值可能需要设计旁路。</p><h3 id="思考题3"><a href="#思考题3" class="headerlink" title="思考题3"></a>思考题3</h3><blockquote><p>在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。</p></blockquote><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><p>我将IFU模块拆开来，设计了IM，NPC两个模块，PC就是一个寄存器，直接置于顶层电路中了。IM要注意取指令的[13:2]位，NPC分为四块，为将来可能的J类指令保留出来。首先是直接输出$PC+4$，然后是$beq$指令判断$zero$是否为$1$决定取$PC+4$还是$PC+4+(signed)imm32$，再是$jal/j$指令拼接$PC[31:28]$，$imm26$，和<code>2&#39;b00</code>，最后是$jr$直接将寄存器$RD1$的输出接上来。使用$MUX$和<code>NPCop</code>进行选择即可。</p><h3 id="思考题4"><a href="#思考题4" class="headerlink" title="思考题4"></a>思考题4</h3><blockquote><p>事实上，实现 <code>nop</code> 空指令，我们并不需要将它加入控制信号真值表，为什么？</p></blockquote><h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><p><code>sll $0, $0, 0</code> 对应的指令码是 <code>0x0000_0000</code>，也被认为是 <code>nop</code>(空操作指令)。如果实现了$sll$，自然也就实现了$nop$。如果没有实现，那么$nop$指令输入进来电路也不会有任何变化，恰好是我们想要的。</p><h3 id="思考题5"><a href="#思考题5" class="headerlink" title="思考题5"></a>思考题5</h3><blockquote><p>阅读 Pre 的<a href="https://d.buaa.edu.cn/http/77726476706e69737468656265737421f3e44293353526526b0988e29d51367b9787/tutorial/mips/mips-6/mips6-1/">“MIPS 指令集及汇编语言”</a>一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</p></blockquote><p>测试样例覆盖了部分核心指令，包括逻辑操作、数据传送、算术运算和控制流指令。这对于基本功能验证有一定作用。但是指令有很多方面没有覆盖到：</p><ul><li><strong><code>ori</code> 指令</strong>：<ul><li>没有测试负数立即数（虽然<code>ori</code>是零扩展，但立即数字段本身可能被解释为有符号值，测试负数立即数可以验证零扩展的正确性）、立即数为0的情况，以及与其他寄存器值的交互（如所有位为0或1的寄存器）。</li></ul></li><li><strong><code>lui</code> 指令</strong>：<ul><li>没有测试立即数为0的情况，也没有验证加载后下半部分是否为0（通过<code>lui</code>和<code>ori</code>组合测试了，但单独<code>lui</code>的行为未充分测试）。</li></ul></li><li><strong><code>add</code> 指令</strong>：<ul><li>没有测试溢出情况（如两个正数相加导致负数，或两个负数相加导致正数），也没有测试0作为操作数的情况。溢出是CPU异常处理的关键，但在这个测试中被忽略。</li></ul></li><li><strong><code>sw</code> 和 <code>lw</code> 指令</strong>：<ul><li>没有测试非对齐地址访问（虽然MIPS要求字对齐，但测试边界情况是重要的）、内存映射的边界地址（如地址0x00000000或0x00002ffc）、存储和加载相同地址的数据竞争，以及不同数据模式（如全0、全1）。</li></ul></li><li><strong><code>beq</code> 指令</strong>：<ul><li>只测试了一个分支目标（<code>loop2</code>），另一个目标（<code>loop1</code>）未被访问；没有测试其他分支条件（如<code>bne</code>）；也没有测试分支与其他指令的交互；没有测试向前跳转。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>CO课下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>CO课下</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P2上机-问题反思</title>
    <link href="/posts/P2%E4%B8%8A%E6%9C%BA-%E9%97%AE%E9%A2%98%E5%8F%8D%E6%80%9D/"/>
    <url>/posts/P2%E4%B8%8A%E6%9C%BA-%E9%97%AE%E9%A2%98%E5%8F%8D%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="题面复原"><a href="#题面复原" class="headerlink" title="题面复原"></a>题面复原</h2><h3 id="T1-Factory"><a href="#T1-Factory" class="headerlink" title="T1.Factory"></a>T1.Factory</h3><p><strong>任务</strong><br>假设你正在为一款城市规划软件编写核心功能。软件中，城市设施被表示为地图上的坐标点 $(x, y)$。现在需要实现一个功能：在给出的被考察坐标中选择一个点，用于建造新的工厂。该点需要满足：</p><ol><li>位于地图的<strong>第二象限内或第四象限内</strong>（不含坐标轴）。</li><li>过该点分别向两坐标轴作垂线，与坐标轴原点 $(0,0)$ 所构成的矩形面积是最大的。</li></ol><p><strong>输入格式</strong></p><ol><li>第一行，输入一个整数 $n$，代表被考察坐标的总个数。</li><li>随后的 $2n$ 行，表示被考察坐标的信息。第 $2i$ 行和第 $2i+1$ 行分别输入两个整数 $x_i$ 和 $y_i$，共同构成第 $i$ 个坐标。</li></ol><p><strong>约束条件</strong></p><ul><li>$n \le 1000$</li><li>$0 \le |x_i|, |y_i| \le 10^9$</li><li><strong>注意</strong>：不保证输入的坐标都位于第二象限内或第四象限内，当遇到位于坐标轴上、第一象限内或第三象限内的点时，忽略即可。</li></ul><p><strong>输出格式</strong></p><ul><li>输出所选坐标，用一个空格分隔。</li><li>保证被考察坐标中存在满足题意的点。如果有多个点产生相同的最大面积，输出第一组满足题意的坐标。</li></ul><p><strong>示例</strong></p><ul><li><p><strong>输入</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">4<br>16<br>-4<br>7<br>-9<br>-1<br>1<br>8<br>-8<br></code></pre></td></tr></table></figure></li><li><p><strong>输出</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">16 -4<br></code></pre></td></tr></table></figure></li></ul><p><strong>提交要求</strong></p><ul><li>请勿使用 <code>.globl main</code></li><li>不考虑延迟槽</li><li>只需要提交 <code>.asm</code> 文件</li></ul><p><strong>C语言代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> best_area = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> best_x = <span class="hljs-number">0</span>, best_y = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);<br><br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> || y == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> ((x &gt; <span class="hljs-number">0</span> &amp;&amp; y &gt; <span class="hljs-number">0</span>) || (x &lt; <span class="hljs-number">0</span> &amp;&amp; y &lt; <span class="hljs-number">0</span>)) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-type">int</span> ax = x &gt;= <span class="hljs-number">0</span> ? x : -x;<br>        <span class="hljs-type">int</span> ay = y &gt;= <span class="hljs-number">0</span> ? y : -y;<br>        <br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> area = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) ax * ay;<br><br>        <span class="hljs-keyword">if</span> (area &gt; best_area) &#123;<br>            best_area = area;<br>            best_x = x;<br>            best_y = y;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, best_x, best_y);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="T2-K-Increasing"><a href="#T2-K-Increasing" class="headerlink" title="T2.K_Increasing"></a>T2.K_Increasing</h3><p><strong>任务</strong><br>使用 MIPS 汇编语言编写程序，计算使数组成为 K 递增数组所需的最少操作次数（不考虑延迟槽）。</p><p><strong>K 递增定义</strong><br>给定一个下标从 0 开始包含 $n$ 个正整数的数组 <code>arr</code>，和一个正整数 $k$。<br>如果对于每个满足 $k \le i \le n-1$ 的下标 $i$，都有 $arr[i-k] \le arr[i]$，那么我们称 <code>arr</code> 是 K 递增 的。</p><ul><li>例如，<code>arr = [4, 1, 5, 2, 6, 2]</code> 对于 $k=2$ 是 K 递增的。</li></ul><p><strong>输入格式</strong></p><ol><li>第 1 行输入一个整数 $n$，为数组 <code>arr</code> 的大小 ($1 \le n \le 20$)。</li><li>第 2 行至第 $n+1$ 行，每行输入一个数字，为数组 <code>arr</code> 的一个元素。</li><li>第 $n+2$ 行输入一个整数 $k$，为 K 递增的参数值 ($1 \le k \le n-1$)。</li></ol><p><strong>输出格式</strong></p><ul><li>输出使数组成为 K 递增数组所需的最少操作次数（一次操作指修改数组中一个元素的值）。</li></ul><p><strong>规定</strong></p><ul><li>步数限制为 200,000</li><li>使用 <code>syscall 10</code> 结束程序</li><li>程序的初始地址设置 (Mars-&gt;Settings-&gt;Memory Configuration) 为 <strong>Compact, Data at Address 0</strong>。</li></ul><p><strong>示例 1</strong></p><ul><li><p><strong>输入</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">5<br>5<br>4<br>3<br>2<br>1<br>1<br></code></pre></td></tr></table></figure></li><li><p><strong>期望输出</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">4<br></code></pre></td></tr></table></figure></li></ul><p><strong>示例 2</strong></p><ul><li><p><strong>输入</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">6<br>5<br>3<br>4<br>2<br>6<br>1<br>2<br></code></pre></td></tr></table></figure></li><li><p><strong>期望输出</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">3<br></code></pre></td></tr></table></figure></li></ul><p><strong>C语言代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_N 20</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">computeLIS</span><span class="hljs-params">(<span class="hljs-type">int</span> *subseq, <span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> dp[MAX_N];<br>    <span class="hljs-type">int</span> maxLen = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        dp[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (subseq[i] &gt;= subseq[j]) &#123;<br>                <span class="hljs-keyword">if</span> (dp[j] + <span class="hljs-number">1</span> &gt; dp[i]) &#123;<br>                    dp[i] = dp[j] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        maxLen = maxLen &gt; dp[i] ? maxLen : dp[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxLen;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kIncreasing</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> arrSize, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-type">int</span> subseq[MAX_N];<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; arrSize; j += k) &#123;<br>            subseq[m++] = arr[j];<br>        &#125;<br>        <span class="hljs-type">int</span> lisLen = computeLIS(subseq, m);<br>        ans += (m - lisLen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n, k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-type">int</span> arr[MAX_N];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, kIncreasing(arr, n, k));<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="T3-Folder-Size"><a href="#T3-Folder-Size" class="headerlink" title="T3.Folder Size"></a>T3.Folder Size</h3><p><strong>任务</strong><br>给定一个项目的目录树，每个节点要么是文件，要么是文件夹。请实现一个 MIPS 程序，支持多次查询：对给定的节点编号，输出其“子树总大小”（该文件夹内所有文件大小之和，包含所有子文件夹内的文件）。</p><p><strong>输入格式</strong></p><ol><li>第一行：整数 $n$，表示节点总数（节点编号为 $1, 2, \dots, n$）。</li><li>接下来 $n$ 段节点描述（按编号顺序从小到大给出，即第 $i$ 段节点描述对应第 $i$ 个节点）：<ul><li><strong>若为文件</strong>：第一行为 <code>0</code>，第二行一个整数 <code>size</code>，表示文件大小。</li><li><strong>若为文件夹</strong>：第一行为 <code>1</code>，第二行一个整数 <code>k</code>。接下来依次给出 $k$ 个整数，为该文件夹的子节点编号。</li></ul></li><li>然后一行输入一个整数 $q$，表示查询次数。</li><li>接下来 $q$ 行：每行一个整数 $id$，表示查询该节点为根的子树总大小（保证 $id$ 合法）。</li></ol><p><strong>约束条件</strong></p><ul><li>$1 \le n \le 150$</li><li>文件大小 $size$ 满足 $0 \le size \le 10^6$</li><li>所有文件大小总和 $\le 10^9$</li><li>输入保证形成一个或多个有根树（无环）</li><li>总边数 $\le 800$</li><li>查询次数 $\le 60$</li></ul><p><strong>输出格式</strong><br>对每个查询输出一行：若查询的节点为文件，直接输出其大小；若为文件夹，输出其子树总大小（目录本身大小视为零）。</p><p><strong>示例</strong></p><ul><li><p><strong>输入</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">5<br>1<br>2<br>2<br>3<br>0<br>100<br>1<br>1<br>4<br>0<br>20<br>0<br>1<br>3<br>1<br>3<br>5<br></code></pre></td></tr></table></figure><p><em>(解释：节点1是文件夹有子节点2和3；节点2是文件大小100；节点3是文件夹有子节点4；节点4是文件大小20；节点5是文件大小1)</em></p></li><li><p><strong>输出</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">120<br>20<br>1<br></code></pre></td></tr></table></figure></li></ul><p><strong>提交要求</strong></p><ul><li>请勿使用 <code>.globl main</code></li><li>不考虑延迟槽</li><li>只需要提交 <code>.asm</code> 文件</li><li>程序的初始地址设置 (Mars-&gt;Settings-&gt;Memory Configuration) 为 <strong>Compact, Data at Address 0</strong>。</li></ul><p><strong>C语言代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 155</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXE 805</span><br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> nodeType[MAXN];     <span class="hljs-comment">// 0: 文件, 1: 文件夹</span><br><span class="hljs-type">int</span> fileSizeVal[MAXN];  <span class="hljs-comment">// 文件大小(文件夹为0)</span><br><span class="hljs-type">int</span> headAdj[MAXN];      <span class="hljs-comment">// 邻接表头</span><br><span class="hljs-type">int</span> toEdge[MAXE], nextEdge[MAXE];<br><span class="hljs-type">int</span> edgeCnt;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> &#123;<br>    toEdge[edgeCnt] = v;<br>    nextEdge[edgeCnt] = headAdj[u];<br>    headAdj[u] = edgeCnt++;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">dfs_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nodeType[u] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> fileSizeVal[u];<br>    &#125;<br><br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = headAdj[u]; e != <span class="hljs-number">-1</span>; e = nextEdge[e]) &#123;<br>        <span class="hljs-type">int</span> v = toEdge[e];<br>        size += dfs_sum(v);<br>    &#125;<br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;MAXN; i++) headAdj[i] = <span class="hljs-number">-1</span>; <br>    <br>    edgeCnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> t, x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t); <br>        <br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">0</span>) &#123;<br>            nodeType[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x); <br>            fileSizeVal[i] = x;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nodeType[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> k;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k); <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>                <span class="hljs-type">int</span> v;<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v);<br>                add_edge(i, v);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> q;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q);<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> id;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;id);<br>        <span class="hljs-type">int</span> ans = dfs_sum(id);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h2><p>笔者不幸只做出了两道题，这是新手保护期的唯一一次没有拿满。但是不用担心，未进闯关制之前基本不算分。</p><p>三道题，每题都给出了C语言代码，但是翻译也是没有那么好翻译滴~</p><p>首先，对于T1就有不少坑，<code>long long</code>意味着我们要分开存高低位，比较大小也要用类似字典序的方法分别比较高低位；三目运算符，即取绝对值，需要用分支语句，并且存在新的变量里；输出第一组满足题意的坐标，后面严格大于才能覆盖。</p><p>然后对于T2，主要是考验你函数调用的能力，笔者投机取巧，好像删掉了一个函数，没有完全对着翻译。</p><p>最后T3，笔者没有调出来，数据结构的知识忘光了，说实话，连C语言代码我都看不懂了。$dfs$的递归和邻接表，我记得我做数据结构的时候不爱用邻接表，喜欢用点自创的方法，但是现在也忘了。本题写出来代码也会非常长。</p><h2 id="笔者的话"><a href="#笔者的话" class="headerlink" title="笔者的话"></a>笔者的话</h2><p>如果你有感觉P2和前后的P格格不入的话，你的感觉是正确的。其实MIPS只要会一些基础的就差不多了，用于后续上机的调试，以及期末的代码补全。如果P2挂了，也不必过于担心。</p>]]></content>
    
    
    <categories>
      
      <category>CO上机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>CO上机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P2-课下题目汇总与反思解答</title>
    <link href="/posts/P2-%E8%AF%BE%E4%B8%8B%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%8E%E5%8F%8D%E6%80%9D%E8%A7%A3%E7%AD%94/"/>
    <url>/posts/P2-%E8%AF%BE%E4%B8%8B%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%8E%E5%8F%8D%E6%80%9D%E8%A7%A3%E7%AD%94/</url>
    
    <content type="html"><![CDATA[<h1 id="P2-课下题目汇总与反思解答"><a href="#P2-课下题目汇总与反思解答" class="headerlink" title="P2-课下题目汇总与反思解答"></a>P2-课下题目汇总与反思解答</h1><h2 id="课下作业说明"><a href="#课下作业说明" class="headerlink" title="课下作业说明"></a>课下作业说明</h2><h3 id="作业说明："><a href="#作业说明：" class="headerlink" title="作业说明："></a>作业说明：</h3><ul><li>学习基于 MIPS 指令集的汇编语言，并在 Mars 环境下独立编写和调试以下程序：矩阵乘法、回文串判断、卷积运算，全排列。</li><li>高精度阶乘、01 迷宫两道题为挑战题，不作为参与 P2 课上测试的条件。</li><li>所有程序的初始地址设置都是 <strong>Compact,Data at Address 0</strong></li><li>测试平台是使用命令行运行汇编程序，命令行中有 CompactDataAtZero 这个参数，如果<strong>初始地址的设置不按照要求或者 .data 指令后面带有参数，程序会编译错误</strong>。</li><li>P2 中所有的题目，如果没有特殊声明，都<strong>不考虑延迟槽</strong>的存在。</li><li>P2 中所有的题目，在程序运行完成后，需要<strong>使用 syscall 结束程序</strong>，否则评测机可能会误认为程序运行时间超出限制从而报错。</li><li>P2 中所有的题目，请大家本地充分测试后提交，请勿滥用评测机，每道题将设置 5 分钟提交间隔。</li></ul><h2 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在高级语言中，我们可以使用多维数组对内存进行多维操作，但实际上，一般这些多维数组在内存中也只是按照一维的形式连续存储的。比如二维数组 arr[2][2]，他在内存中会占用 4 个单位的连续空间，分别保存 arr[0][0]、arr[0][1]、arr[1][0]、arr[1][1]。</p><p>作为低级语言，汇编语言对内存只能进行一维操作。而为了实现多维操作，我们就需要使用一些技巧了，下面会进行举例分析。</p><h3 id="样例分析"><a href="#样例分析" class="headerlink" title="样例分析"></a>样例分析</h3><p>比如我们要将 0~255 依次赋给一个 16*16 的矩阵，填充方式如下图 4*4 矩阵的例子。</p><img src="/posts/P2-%E8%AF%BE%E4%B8%8B%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%8E%E5%8F%8D%E6%80%9D%E8%A7%A3%E7%AD%94/ff2f668fa5897d44b22ad64c79f0e606.png" class="" title="ff2f668fa5897d44b22ad64c79f0e606"><p>使用高级语言的话只需要两个 for 循环嵌套，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">16</span>][<span class="hljs-number">16</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">16</span>; j++) &#123;<br>        arr[i][j] = value++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用汇编语言的话，就需要分为三步：</p><ul><li>初始化数据</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.data</span><br><span class="hljs-symbol">    data:</span> <span class="hljs-meta">.word</span> <span class="hljs-number">0</span> : <span class="hljs-number">256</span>       <span class="hljs-comment"># storage for 16x16 matrix of words</span><br><br><span class="hljs-meta">.text</span><br>    li $<span class="hljs-built_in">t0</span>, <span class="hljs-number">16</span>         <span class="hljs-comment"># $t0 = number of rows</span><br>    li $<span class="hljs-built_in">t1</span>, <span class="hljs-number">16</span>         <span class="hljs-comment"># $t1 = number of columns</span><br>    <span class="hljs-keyword">move </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">zero</span>    <span class="hljs-comment"># $s0 = row counter</span><br>    <span class="hljs-keyword">move </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-built_in">zero</span>    <span class="hljs-comment"># $s1 = column counter</span><br>    <span class="hljs-keyword">move </span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">zero</span>    <span class="hljs-comment"># $t2 = the value to be stored</span><br></code></pre></td></tr></table></figure><p> <code>$t0</code> 和 <code>$t1</code> 是总的行列数，<code>$s0</code> 和 <code>$s1</code> 是当前赋值的行列数，<code>$t2</code> 就是要赋的值。</p><ul><li>为一行矩阵赋值</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#________ tag1 _______</span><br><span class="hljs-symbol">loop:</span><br>    <span class="hljs-keyword">mult </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">t1</span>      <span class="hljs-comment"># $s2 = row * #cols (two-instruction sequence)</span><br>    <span class="hljs-keyword">mflo </span>$<span class="hljs-built_in">s2</span>           <span class="hljs-comment"># move multiply result from lo register to $s2</span><br>    <span class="hljs-keyword">add </span>$<span class="hljs-built_in">s2</span>, $<span class="hljs-built_in">s2</span>, $<span class="hljs-built_in">s1</span>  <span class="hljs-comment"># $s2 += column counter</span><br>    <span class="hljs-keyword">sll </span>$<span class="hljs-built_in">s2</span>, $<span class="hljs-built_in">s2</span>, <span class="hljs-number">2</span>    <span class="hljs-comment"># $s2 *= 4 (shift left 2 bits) for byte offset</span><br>    <span class="hljs-keyword">sw </span>$<span class="hljs-built_in">t2</span>, data($<span class="hljs-built_in">s2</span>)  <span class="hljs-comment"># store the value in matrix element</span><br><span class="hljs-comment">#---------------------  </span><br><br><span class="hljs-comment">#________ tag2 _______</span><br>    <span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">t2</span>, <span class="hljs-number">1</span>   <span class="hljs-comment"># increment value to be stored</span><br><span class="hljs-comment">#---------------------  </span><br><br><span class="hljs-comment"># Loop control: If we increment past last column, reset colume counter and increment row counter</span><br><span class="hljs-comment">#               If we increment past last row,we&#x27;re finished.</span><br><br><span class="hljs-comment">#________ tag3 _______</span><br>    <span class="hljs-keyword">addi </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-built_in">s1</span>, <span class="hljs-number">1</span>   <span class="hljs-comment"># increment coumn counter</span><br><span class="hljs-comment">#---------------------  </span><br><br>    <span class="hljs-keyword">bne </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-built_in">t1</span>, loop <span class="hljs-comment"># not at end of row so loop back</span><br></code></pre></td></tr></table></figure><p>tag1 代码段为当前矩阵元素对应的内存赋值，tag2 和 tag3 代码段更新数据，最后一行判断这一行矩阵是否已完全赋值。</p><ul><li>准备为下一行矩阵赋值</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">    <span class="hljs-keyword">move </span>$<span class="hljs-built_in">s1</span>, $<span class="hljs-built_in">zero</span>    <span class="hljs-comment"># reset column counter</span><br>    <span class="hljs-keyword">addi </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">s0</span>, <span class="hljs-number">1</span>   <span class="hljs-comment"># increment row counter</span><br>    <span class="hljs-keyword">bne </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">t0</span>, loop <span class="hljs-comment"># not at end of matrix so loop back</span><br><span class="hljs-comment"># We&#x27;re finished traversing the matrix</span><br>    li $<span class="hljs-built_in">v0</span>, <span class="hljs-number">10</span>         <span class="hljs-comment"># system service 10 is exit</span><br>    <span class="hljs-keyword">syscall </span>           <span class="hljs-comment"># we are outta here</span><br></code></pre></td></tr></table></figure><p>当一行矩阵已赋完值后，更新数据，然后重新跳回到 loop 处为下一行矩阵赋值，直到整个矩阵都赋完值。</p><h3 id="补充：利用Macros简化二维数组的计算"><a href="#补充：利用Macros简化二维数组的计算" class="headerlink" title="补充：利用Macros简化二维数组的计算"></a>补充：利用Macros简化二维数组的计算</h3><p>在 MIPS 教程部分，我们学习了如何使用 macro 宏定义一些操作来简化我们的 MIPS 程序，对于二维数组的相关计算，我们可以发现，计算数组中元素的地址是一个重复且固定的算法，因此，我们计划创建一个 macro 来代替这些语句，从而减少代码行数，增加可读性，以便出错后更好的调试代码。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl">.macro calc_addr(<span class="hljs-variable">%dst</span>, <span class="hljs-variable">%row</span>, <span class="hljs-variable">%column</span>, <span class="hljs-variable">%rank</span>)<br>    <span class="hljs-comment"># dts: the register to save the calculated address</span><br>    <span class="hljs-comment"># row: the row that element is in</span><br>    <span class="hljs-comment"># column: the column that element is in</span><br>    <span class="hljs-comment"># rank: the number of columns in the matrix</span><br>    multu <span class="hljs-variable">%row</span>, <span class="hljs-variable">%rank</span><br>    mflo <span class="hljs-variable">%dst</span><br>    addu <span class="hljs-variable">%dst</span>, <span class="hljs-variable">%dst</span>, <span class="hljs-variable">%column</span><br>    sll <span class="hljs-variable">%dst</span>, <span class="hljs-variable">%dst</span>, <span class="hljs-number">2</span><br>.end_macro<br></code></pre></td></tr></table></figure><p>上图就是我们关于计算地址的 macro 了，我们精心的设计保证了运算中只改变 <code>%dst</code> 所代表的寄存器，避免了 macro 内部不可见的修改其他寄存器的情况的发生。这种复用代码的思想类似于函数，但是一定注意 macro 的运用中易出现的如上所述的问题，希望同学们能够熟练运用，写出易懂的汇编代码来。</p><h2 id="P2-L0-matrix-任务"><a href="#P2-L0-matrix-任务" class="headerlink" title="P2_L0_matrix-任务"></a>P2_L0_matrix-<strong>任务</strong></h2><p>使用MIPS汇编语言编写一个具有矩阵相乘功能的汇编程序(不考虑延迟槽)。</p><h2 id="具体要求"><a href="#具体要求" class="headerlink" title="具体要求"></a><strong>具体要求</strong></h2><ul><li><p>首先读取方形矩阵的阶数n，然后再依次读取第一个矩阵（n行n列）和第二个矩阵（n行n列）中的元素。</p></li><li><p>两个矩阵的阶数相同，我们提供的测试数据中0&lt;n≤8,每个矩阵元素是小于10的整数。</p></li><li><p>最终将计算出的结果输出，每行n个数据，每个数据间用空格分开。评测机会自动过滤掉行尾空格以及最后的回车。</p></li><li><p>请使用syscall结束程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs none">li $v0,10<br>syscall<br></code></pre></td></tr></table></figure></li></ul><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a><strong>样例</strong></h2><img src="/posts/P2-%E8%AF%BE%E4%B8%8B%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%8E%E5%8F%8D%E6%80%9D%E8%A7%A3%E7%AD%94/38054fccf198fd20798d7944101ab78f.png" class="" title="38054fccf198fd20798d7944101ab78f"><p>比如我们想要计算上面这两个矩阵相乘的结果，我们会给出以下输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs none">2<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br></code></pre></td></tr></table></figure><p>正确的输出应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs none">19 22<br>43 50<br></code></pre></td></tr></table></figure><h2 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a><strong>提交要求</strong></h2><ul><li>请勿使用<code>.globl main</code>。</li><li>不考虑延迟槽。</li><li>只需要提交.asm文件。</li><li>程序的初始地址设置（Mars-&gt;Settings-&gt;Memory Configuration）为<strong>Compact,Data at Address 0</strong>。</li></ul><h2 id="P2-L0-judge-回文串判断"><a href="#P2-L0-judge-回文串判断" class="headerlink" title="P2_L0_judge-回文串判断"></a>P2_L0_judge-回文串判断</h2><p>实现满足下面功能的汇编程序：</p><ol><li><p>判断输入的字符串是不是回文串。</p></li><li><p>输出一个字符，是回文串输出1，否则输出0</p></li><li><p>每组数据最多执行100,000条指令。</p></li><li><p>请使用syscall结束程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs none">li $v0,10<br>syscall<br></code></pre></td></tr></table></figure></li></ol><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为一个整数n，代表字符串的长度。第二行开始的n行：每行一个字符(小写字母)，连起来为输入的字符串。<strong>(0&lt;n&lt;=20)</strong></p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出为一行，输出一个字符，是回文串输出1，否则输出0。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">5</span><br><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><br><span class="hljs-selector-tag">b</span><br>d<br>l<br></code></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><h2 id="提交要求-1"><a href="#提交要求-1" class="headerlink" title="提交要求"></a>提交要求</h2><ol><li><strong>请勿使用</strong> <code>.globl main</code></li><li>不考虑延迟槽</li><li>只需要提交.asm文件。</li><li>程序的初始地址设置为<strong>Compact,Data at Address 0</strong>。</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>注意!因为评测机的行为和MARS有一些区别，你需要注意以下事项。</li><li>如果你采取每次读入一个字符的系统调用（<code>\$v0=12</code>）来读入数据,那么我们保证你不会读入到任何换行符。如果你采取这种方式输入，那么对于样例，你可以在MARS中首先手动输入5，打回车，然后手动在一行之中输入$abbdl$。</li><li>如果你采取一次读一行的系统调用（<code>$v0=8</code>），那么你读入的每行有一个小写字母以及行尾的一个换行符。</li><li>如果你的程序长时间等不到应有的输入，则有可能提示超时或运行错误。</li><li>在你处理字符的时候，你需要考虑到上述情况。</li></ol><h2 id="P2-L0-conv-矩阵卷积"><a href="#P2-L0-conv-矩阵卷积" class="headerlink" title="P2_L0_conv-矩阵卷积"></a>P2_L0_conv-矩阵卷积</h2><p>使用MIPS汇编语言编写一个进行卷积运算的汇编程序(不考虑延迟槽)。</p><h2 id="具体要求-1"><a href="#具体要求-1" class="headerlink" title="具体要求"></a>具体要求</h2><ul><li><p>首先读取待卷积矩阵的行数$m_1$和列数$n_1$，然后读取卷积核的行数$m_2$和列数$n_2$。</p></li><li><p>然后再依次读取待卷积矩阵($m_1$行$n_1$列)和卷积核($m_2$行$n_2$列)中的元素。</p></li><li><p>卷积核的行列数分别严格小于待卷积矩阵的行列数.</p></li><li><p>测试数据中$0&lt;m_1, n_1, m_2, n_2 &lt;11$</p></li><li><p>输入的每个数的绝对值不超过$2^{10}$.</p></li><li><p>最终输出进行卷积后的结果</p></li><li><p>输出中，有$m_1-m_2+1$行，每行有$n_1-n_2+1$个数据，每个数据用空格分开。</p></li><li><p>卷积运算的定义:</p><img src="/posts/P2-%E8%AF%BE%E4%B8%8B%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%8E%E5%8F%8D%E6%80%9D%E8%A7%A3%E7%AD%94/615877cee96354be21fc260092c44252.png" class="" title="615877cee96354be21fc260092c44252"><p>其中f为待卷积矩阵，h为卷积核，g即为输出矩阵，k与l的终值分别为卷积核h的行大小、列大小。计算中不考虑边缘效应。</p></li><li><p>请使用<code>syscall</code>结束程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs none">li $v0, 10<br>syscall<br></code></pre></td></tr></table></figure></li></ul><h2 id="特别的"><a href="#特别的" class="headerlink" title="特别的"></a>特别的</h2><ul><li>卷积窗口的移动步长为$1$，且不采用填充。</li></ul><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><p>给出以下输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs none">4<br>3<br>2<br>2<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>0<br>1<br>2<br>3<br></code></pre></td></tr></table></figure><p>正确的输出应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs none">25 31 <br>43 49 <br>61 67 <br></code></pre></td></tr></table></figure><h2 id="提交要求-2"><a href="#提交要求-2" class="headerlink" title="提交要求"></a>提交要求</h2><ul><li>请勿使用<code>.globl main</code>。</li><li>不考虑延迟槽。</li><li>只需要提交.asm文件。</li><li>程序的初始地址设置（Mars-&gt;Settings-&gt;Memory Configuration）为<strong>Compact,Data at Address 0</strong>。</li></ul><h2 id="P2-L0-full-1-全排列生成"><a href="#P2-L0-full-1-全排列生成" class="headerlink" title="P2_L0_full_1-全排列生成"></a>P2_L0_full_1-全排列生成</h2><p>实现满足下面功能的汇编程序：</p><ol><li><p>使用mips实现全排列生成算法。</p></li><li><p>以0x00000000为数据段起始地址。</p></li><li><p>输入一个小于等于6的正整数，求出n的全排列，并按照字典序输出。</p></li><li><p>每组数据最多执行500,000条指令。</p></li><li><p>请使用syscall结束程序：</p></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs none">li $v0,10<br>syscall<br></code></pre></td></tr></table></figure></li></ol><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>只输入一行，输入一个整数$n (0&lt;n&lt;=6)$</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>按照字典序输出$n!$行数组，每行输出$n$个数字，数字之间以空格隔开，每行最后一个数字后可以有空格。</p><h2 id="C代码提示"><a href="#C代码提示" class="headerlink" title="C代码提示"></a>C代码提示</h2><img src="/posts/P2-%E8%AF%BE%E4%B8%8B%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%8E%E5%8F%8D%E6%80%9D%E8%A7%A3%E7%AD%94/fa70e970f8c622d03bf08cbd4e2b77b3.png" class="" title="fa70e970f8c622d03bf08cbd4e2b77b3"><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="提交要求-3"><a href="#提交要求-3" class="headerlink" title="提交要求"></a>提交要求</h2><ol><li><strong>请勿使用</strong> <code>.globl main</code></li><li>不考虑延迟槽</li><li>只需要提交.asm文件。</li><li>程序的初始地址设置为<strong>Compact,Data at Address 0</strong>。</li></ol><h2 id="P2-L1-puzzle-01迷宫"><a href="#P2-L1-puzzle-01迷宫" class="headerlink" title="P2_L1_puzzle-01迷宫"></a>P2_L1_puzzle-01迷宫</h2><ol><li>在mips教程部分我们出了一道挑战题留给大家探索——哈密顿回路，哈密顿回路问题是一道npc的问题，需要使用深度优先探索算法进行求解。而我们今天课下测试也准备了一道挑战性测试题：使用深度优先探索算法求解01迷宫的逃离路线个数（这道题通过与否不作为是否能参加P2课上的条件）。</li></ol><h2 id="逃跑路线"><a href="#逃跑路线" class="headerlink" title="逃跑路线"></a>逃跑路线</h2><img src="/posts/P2-%E8%AF%BE%E4%B8%8B%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E4%B8%8E%E5%8F%8D%E6%80%9D%E8%A7%A3%E7%AD%94/b0af7199a734f248b1a7a45950f7e10f.png" class="" title="b0af7199a734f248b1a7a45950f7e10f"><ol><li>左图表示的是一个4*5的01矩阵，这个矩阵就是一个01迷宫。</li><li>如左图，以红色0作为起点，绿色0作为终点，每一次行进只能选择上下左右中值为0且未走过的位置，满足上述条件的路线，即为一条迷宫逃跑路线。如右图中，蓝色的路线即为一条逃跑路线。</li></ol><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ol><li>使用mips实现01迷宫路线数目计算。</li><li>以0x00000000为数据段起始地址。</li><li>输入一个n*m的01矩阵作为01迷宫，并给定他的起点与终点，求出他不同逃跑路线的数目（不同逃跑路线中可以有相同的部分，但是不能完全相同）。</li><li>每组数据最多执行5,000,000条指令。</li></ol><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>前两行输入两个整数n和m（n、m均为正整数并且小于等于7），分别代表01矩阵行数和列数。接下来的n*m行，每行输入1个整数（0或1），对应着01矩阵各个元素值(第i*m+j个整数为矩阵的第（i+1）行第j个元素，即一行一行输入)。接下来的四行分别代表迷宫的起点和终点，每行一个整数，分别代表起点与终点行数和列数。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>只输出一个整数，代表逃跑路线的数目。</p><h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs">4<br>5<br>0<br>0<br>1<br>0<br>0<br>1<br>0<br>0<br>0<br>1<br>1<br>0<br>1<br>0<br>1<br>1<br>0<br>0<br>0<br>0<br>1<br>1<br>4<br>5<br></code></pre></td></tr></table></figure><h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><h2 id="提交要求-4"><a href="#提交要求-4" class="headerlink" title="提交要求"></a>提交要求</h2><ol><li><strong>请勿使用</strong><code>.globl main</code></li><li>不考虑延迟槽</li><li>只需要提交.asm文件。</li><li>程序的初始地址设置为<strong>Compact,Data at Address 0</strong>。</li></ol><h2 id="P2-L1-factorial-高精度阶乘的计算"><a href="#P2-L1-factorial-高精度阶乘的计算" class="headerlink" title="P2_L1_factorial-高精度阶乘的计算"></a>P2_L1_factorial-高精度阶乘的计算</h2><p>（这道题通过与否不作为是否能参加P2课上的条件）</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ul><li>使用MIPS汇编语言编写一个求n的阶乘的汇编程序(不考虑延迟槽)。</li></ul><h3 id="具体要求-2"><a href="#具体要求-2" class="headerlink" title="具体要求"></a>具体要求</h3><ul><li><p>第一行读取n</p></li><li><p>计算并输出n的阶乘，输出字符串长度小于等于1000</p></li><li><p>步数限制为200,000</p></li><li><p>请使用syscall结束程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">li $v0, 10<br>syscall<br></code></pre></td></tr></table></figure></li></ul><h3 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h3><ul><li><p>给出以下输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">24<br></code></pre></td></tr></table></figure></li><li><p>期望的输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">620448401733239439360000<br></code></pre></td></tr></table></figure></li></ul><h2 id="提交要求-5"><a href="#提交要求-5" class="headerlink" title="提交要求"></a>提交要求</h2><ul><li>请勿使用<code>.globl main</code>。</li><li>不考虑延迟槽。</li><li>只需要提交.asm文件。</li><li>程序的初始地址设置（Mars-&gt;Settings-&gt;Memory Configuration）为<strong>Compact,Data at Address 0</strong>。</li></ul><div class="table-container"><table><thead><tr><th>思考题</th></tr></thead><tbody><tr><td>结合一般程序的执行流，解释为什么<code>MIPS</code>指令中 link 类指令（如<code>jal</code>指令等），在不考虑延迟槽的情况下，将<strong>当前指令地址 +4</strong> 的值写入一个寄存器而不是写入<strong>当前指令地址</strong>或<strong>当前指令地址 -4</strong> 的值。</td></tr><tr><td>根据你编写过的汇编程序，总结程序中常见的<strong>条件分支</strong>、<strong>循环与循环控制</strong>、<strong>函数调用</strong>、<strong>多维变量访问</strong>、<strong>格式化输入输出</strong>等逻辑在汇编语言下的通用表达方式。</td></tr><tr><td>我们现在正在使用的计算机设备几乎全部都基于<code>x86-64</code>或<code>ARM</code>指令集，MARS 也运行在我们的电脑上，为什么其可以运行<code>MIPS</code>指令？结合相关资料解释原因。</td></tr></tbody></table></div><h2 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h2><h3 id="P2-L0-matrix-任务-1"><a href="#P2-L0-matrix-任务-1" class="headerlink" title="P2_L0_matrix-任务"></a>P2_L0_matrix-<strong>任务</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>a: .space 1024<br>b: .space 1024<br>space: .asciiz &quot; &quot;<br>nextline: .asciiz &quot;\n&quot;<br><br>.macro calc_addr(%dst,%row,%column,%rank)<br>multu %row,%rank<br>mflo %dst<br>addu %dst,%dst,%column<br>sll %dst,%dst,2<br># dts: the register to save the calculated address<br>    # row: the row that element is in<br>   # column: the column that element is in<br>   # rank: the number of columns in the matrix<br>.end_macro<br><br>.text<br><br>li $t0,0#i=0<br>li $t1,0#j=0<br><br>li $v0,5<br>syscall#read n<br>move $s0,$v0<br><br>loop_init_i:<br>beq $t0,$s0,loop_init_end<br>li $t1,0<br>loop_init_j:<br>beq $t1,$s0,loop_init_j_end<br>li $v0,5<br>syscall<br>move $t3,$v0<br>calc_addr($t2,$t0,$t1,$s0)<br>sw $t3,a($t2)<br>addi $t1,$t1,1<br>j loop_init_j<br>loop_init_j_end:<br>addi $t0,$t0,1<br>j loop_init_i<br>loop_init_end:<br>li $t0,0#i=0<br>li $t1,0#j=0<br><br>loop_init_i2:<br>beq $t0,$s0,loop_init_end2<br>li $t1,0<br>loop_init_j2:<br>beq $t1,$s0,loop_init_j_end2<br>li $v0,5<br>syscall<br>move $t3,$v0<br>calc_addr($t2,$t0,$t1,$s0)<br>sw $t3,b($t2)<br>addi $t1,$t1,1<br>j loop_init_j2<br>loop_init_j_end2:<br>addi $t0,$t0,1<br>j loop_init_i2<br>loop_init_end2:<br>li $t0,0#i=0<br>li $t1,0#j=0<br>li $t2,0#k=0<br><br><br>loop_i:<br>beq $t0,$s0,loop_end<br>li $t1,0<br>loop_j:<br>beq $t1,$s0,loop_j_end<br>li $t2,0<br>li $s1,0<br>loop_k:<br>beq $t2,$s0,loop_k_end<br>calc_addr($t3,$t0,$t2,$s0)<br>lw $t4,a($t3)<br>calc_addr($t5,$t2,$t1,$s0)<br>lw $t6,b($t5)<br>mult $t4,$t6<br>mflo $t7<br>add $s1,$s1,$t7<br>addi $t2,$t2,1<br>j loop_k<br>loop_k_end:<br>li $v0,1<br>move $a0,$s1<br>syscall<br>li $v0,4<br>la $a0,space<br>syscall<br>addi $t1,$t1,1<br>j loop_j<br>loop_j_end:<br>li $v0,4<br>la $a0,nextline<br>syscall<br>addi $t0,$t0,1<br>j loop_i<br>loop_end:<br>li $v0,10<br>syscall<br></code></pre></td></tr></table></figure><h3 id="P2-L0-judge-回文串判断-1"><a href="#P2-L0-judge-回文串判断-1" class="headerlink" title="P2_L0_judge-回文串判断"></a>P2_L0_judge-回文串判断</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>a: .space 100<br><br>.text<br><br>li $v0,5<br>syscall<br>move $s0,$v0<br><br>li $t0,0<br>loop_in:<br>beq $t0,$s0,in_end<br>li $v0,12<br>syscall<br>move $t1,$v0<br>sll $t2,$t0,2<br>sw $t1,a($t2)<br>addi $t0,$t0,1<br>j loop_in<br>in_end:<br>li $t0,0<br><br>loop_check:<br>beq $t0,$s0,end1<br>sub $t1,$s0,$t0<br>subi $t1,$t1,1<br>sll $t2,$t0,2<br>lw $t3,a($t2)<br>sll $t2,$t1,2<br>lw $t4,a($t2)<br>bne $t3,$t4,end0<br>addi $t0,$t0,1<br>j loop_check<br><br>end1:<br>li $v0,1<br>li $a0,1<br>syscall<br>li $v0,10<br>syscall<br><br>end0:<br>li $v0,1<br>li $a0,0<br>syscall<br>li $v0,10<br>syscall<br></code></pre></td></tr></table></figure><h3 id="P2-L0-conv-矩阵卷积-1"><a href="#P2-L0-conv-矩阵卷积-1" class="headerlink" title="P2_L0_conv-矩阵卷积"></a>P2_L0_conv-矩阵卷积</h3><p>四重循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>a: .space 2048<br>b: .space 2048<br>ans: .space 2048<br>space: .asciiz &quot; &quot;<br>line: .asciiz &quot;\n&quot;<br><br>.macro calc_addr(%dst,%row,%col,%rank)<br>multu %row,%rank<br>mflo %dst<br>add %dst,%dst,%col<br>sll %dst,%dst,2<br>.end_macro <br><br>.text <br>li $v0,5<br>syscall <br>move $s0,$v0#s0=m1<br><br>li $v0,5<br>syscall <br>move $s1,$v0#s1=n1<br><br>li $v0,5<br>syscall <br>move $s2,$v0#s2=m2<br><br>li $v0,5<br>syscall <br>move $s3,$v0#s3=n2<br><br>li $t0,0<br>loop_in_i_1:<br>beq $t0,$s0,loop_in_1_end<br>li $t1,0<br>loop_in_j_1:<br>beq $t1,$s1,loop_in_j1_end<br>li $v0,5<br>syscall<br>move $t3,$v0<br>calc_addr($t2,$t0,$t1,$s1)<br>sw $t3,a($t2)<br>addi $t1,$t1,1<br>j loop_in_j_1<br>loop_in_j1_end:<br>addi $t0,$t0,1<br>j loop_in_i_1<br>loop_in_1_end:<br>li $t0,0<br>loop_in_i_2:<br>beq $t0,$s2,loop_in_2_end<br>li $t1,0<br>loop_in_j_2:<br>beq $t1,$s3,loop_in_j2_end<br>li $v0,5<br>syscall<br>move $t3,$v0<br>calc_addr($t2,$t0,$t1,$s3)<br>sw $t3,b($t2)<br>addi $t1,$t1,1<br>j loop_in_j_2<br>loop_in_j2_end:<br>addi $t0,$t0,1<br>j loop_in_i_2<br>loop_in_2_end:<br>sub $s5,$s0,$s2<br>addi $s5,$s5,1<br>sub $s6,$s1,$s3<br>addi $s6,$s6,1<br><br>li $t0,0<br>loop_calc_i:<br>beq $t0,$s5,calc_end<br>li $t1,0<br>loop_calc_j:<br>beq $t1,$s6,calc_j_end<br>move $t2,$zero<br>li $s4,0<br>loop_calc_k:<br>beq $t2,$s2,calc_k_end<br>li $t3,0<br>loop_calc_l:<br>beq $t3,$s3,calc_l_end<br>addu $t4,$t2,$t0<br>addu $t5,$t3,$t1<br>calc_addr($t6,$t4,$t5,$s1)<br>lw $t7,a($t6)<br>calc_addr($t6,$t2,$t3,$s3)<br>lw $t8,b($t6)<br>multu $t7,$t8<br>mflo $t7<br>addu $s4,$s4,$t7<br>addi $t3,$t3,1<br>j loop_calc_l<br>calc_l_end:<br>addi $t2,$t2,1<br>j loop_calc_k<br>calc_k_end:<br>calc_addr($t2,$t0,$t1,$s6)<br>sw $s4,ans($t2)<br>addi $t1,$t1,1<br>j loop_calc_j<br>calc_j_end:<br>addi $t0,$t0,1<br>j loop_calc_i<br>calc_end:<br><br>li $t0,0<br>loop_out_i:<br>beq $t0,$s5,end<br>li $t1,0<br>loop_out_j:<br>beq $t1,$s6,j_end<br>calc_addr($t2,$t0,$t1,$s6)<br>lw $t3,ans($t2)<br>move $a0,$t3<br>li $v0,1<br>syscall<br>la $a0,space<br>li $v0,4<br>syscall<br>addi $t1,$t1,1<br>j loop_out_j<br>j_end:<br>la $a0,line<br>li $v0,4<br>syscall<br>addi $t0,$t0,1<br>j loop_out_i<br>end:<br>li $v0,10<br>syscall<br></code></pre></td></tr></table></figure><h3 id="P2-L0-full-1-全排列生成-1"><a href="#P2-L0-full-1-全排列生成-1" class="headerlink" title="P2_L0_full_1-全排列生成"></a>P2_L0_full_1-全排列生成</h3><p>C语言代码已经给出，翻译即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>a: .space 100<br>fl: .space 100<br>space: .asciiz &quot; &quot;<br>line: .asciiz &quot;\n&quot;<br><br>.macro push(%src)<br>addi $sp,$sp,-4<br>sw %src,0($sp)<br>.end_macro<br><br>.macro pop(%src)<br>lw %src,0($sp)<br>addi $sp,$sp,4<br>.end_macro<br><br>.macro printInt(%src)<br>move $a0,%src<br>li $v0,1<br>syscall<br>.end_macro<br><br>.macro printSpace()<br>la $a0,space<br>li $v0,4<br>syscall<br>.end_macro<br><br>.macro printLine()<br>la $a0,line<br>li $v0,4<br>syscall<br>.end_macro<br><br>.text<br><br>main:<br>li $v0,5<br>syscall<br>move $s0,$v0<br>li $a0,1<br>jal dfs<br>li $v0,10<br>syscall<br><br>dfs:<br>push($ra)<br>push($s1)<br>push($t0)<br>push($t1)<br>push($t2)<br>push($t3)<br><br>move $s1,$a0<br>ble $s1,$s0,else<br>if:<br>li $t0,1<br>loop_out:<br>bgt $t0,$s0,out_end<br>sll $t2,$t0,2<br>lw $t1,a($t2)<br>printInt($t1)<br>printSpace()<br>addi $t0,$t0,1<br>j loop_out<br>out_end:<br>printLine()<br>j return<br>else:<br>li $t0,1<br>loop_deep:<br>bgt $t0,$s0,deep_end<br>sll $t2,$t0,2<br>lw $t1,fl($t2)<br>li $t3,1<br>beq $t1,$t3,next<br>sw $t3,fl($t2)<br>sll $t2,$s1,2<br>sw $t0,a($t2)<br>add $a0,$s1,1<br>jal dfs<br>sll $t2,$t0,2<br>sw $zero,fl($t2)<br>next:<br>addi $t0,$t0,1<br>j loop_deep<br>deep_end:<br>j return<br>return:<br>pop($t3)<br>pop($t2)<br>pop($t1)<br>pop($t0)<br>pop($s1)<br>pop($ra)<br>jr $ra<br></code></pre></td></tr></table></figure><h3 id="P2-L1-puzzle-01迷宫-1"><a href="#P2-L1-puzzle-01迷宫-1" class="headerlink" title="P2_L1_puzzle-01迷宫"></a>P2_L1_puzzle-01迷宫</h3><p>标准的DFS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>a: .space 1024<br>fl: .space 1024<br><br>.macro push(%src)<br>addi $sp,$sp,-4<br>sw %src,0($sp)<br>.end_macro <br><br>.macro pop(%src)<br>lw %src 0($sp)<br>addi $sp,$sp,4<br>.end_macro <br><br>.macro getInt(%dst)<br>li $v0,5<br>syscall<br>move %dst,$v0<br>.end_macro <br><br>.macro printInt(%src)<br>move $a0,%src<br>li $v0,1<br>syscall <br>.end_macro <br><br>.macro calc_addr(%dst,%row,%col,%rank)<br>multu %row,%rank<br>mflo %dst<br>add %dst,%dst,%col<br>sll %dst,%dst,2<br>.end_macro <br>.text<br>main:<br>getInt($s0)<br>getInt($s1)<br><br>li $t0,1<br>loop_in_i:<br>bgt $t0,$s0,in_end<br>li $t1,1<br>loop_in_j:<br>bgt $t1,$s1,in_j_end<br>getInt($t3)<br>calc_addr($t2,$t0,$t1,$s1)<br>sw $t3,a($t2)<br>addi $t1,$t1,1<br>j loop_in_j<br>in_j_end:<br>addi $t0,$t0,1<br>j loop_in_i<br>in_end:<br><br>getInt($s2)<br>getInt($s3)<br>getInt($s4)<br>getInt($s5)<br><br>move $a0,$s2<br>move $a1,$s3<br><br>jal dfs<br><br>li $v0,1<br>syscall<br><br>li $v0,10<br>syscall<br><br>dfs:<br>push($ra)<br>push($t0)<br>push($t1)<br>push($t2)<br>push($t3)<br>push($t4)<br>push($s2)<br>push($s3)<br><br>move $s2,$a0<br>move $s3,$a1<br>blez $s2,return0<br>blez $s3,return0<br>bgt $s2,$s0,return0<br>bgt $s3,$s1,return0<br><br>bne $s2,$s4,else<br>bne $s3,$s5,else<br>li $a0,1<br>j return<br><br>else:<br>li $t0,0<br>calc_addr($t2,$s2,$s3,$s1)<br>li $t1,1<br>sw $t1,fl($t2)<br><br>sub $t1,$s2,1<br>calc_addr($t2,$t1,$s3,$s1)<br>lw $t1,fl($t2)<br>lw $t3,a($t2)<br><br>bnez $t1,skip1<br>bnez $t3,skip1<br><br>sub $a0,$s2,1<br>move $a1,$s3<br><br>jal dfs<br>add $t0,$t0,$a0<br><br>skip1:<br>add $t1,$s2,1<br>calc_addr($t2,$t1,$s3,$s1)<br>lw $t1,fl($t2)<br>lw $t3,a($t2)<br><br>bnez $t1,skip2<br>bnez $t3,skip2<br><br>add $a0,$s2,1<br>move $a1,$s3<br><br>jal dfs<br>add $t0,$t0,$a0<br><br>skip2:<br>sub $t1,$s3,1<br>calc_addr($t2,$s2,$t1,$s1)<br>lw $t1,fl($t2)<br>lw $t3,a($t2)<br><br>bnez $t1,skip3<br>bnez $t3,skip3<br><br>sub $a1,$s3,1<br>move $a0,$s2<br><br>jal dfs<br>add $t0,$t0,$a0<br><br>skip3:<br>add $t1,$s3,1<br>calc_addr($t2,$s2,$t1,$s1)<br>lw $t1,fl($t2)<br>lw $t3,a($t2)<br><br>bnez $t1,skip4<br>bnez $t3,skip4<br><br>add $a1,$s3,1<br>move $a0,$s2<br><br>jal dfs<br>add $t0,$t0,$a0<br><br>skip4:<br>calc_addr($t2,$s2,$s3,$s1)<br>sw $zero,fl($t2)<br><br>move $a0,$t0<br>j return<br><br>return0:<br>li $a0,0<br>j return<br><br>return:<br>pop($s3)<br>pop($s2)<br>pop($t4)<br>pop($t3)<br>pop($t2)<br>pop($t1)<br>pop($t0)<br>pop($ra)<br>jr $ra<br></code></pre></td></tr></table></figure><h3 id="P2-L1-factorial-高精度阶乘的计算-1"><a href="#P2-L1-factorial-高精度阶乘的计算-1" class="headerlink" title="P2_L1_factorial-高精度阶乘的计算"></a>P2_L1_factorial-高精度阶乘的计算</h3><p>由于阶乘结果超出常规寄存器范围，利用数组模拟高精度整数，数组的每一位存储大数的一位数字。初始化数组为 $1$，随后使用循环从 $2$ 乘到 $n$。在每次乘法运算中，遍历数组的每一位与当前的乘数相乘，并加上前一位的进位，将运算结果的个位数存回当前位置，剩余部分作为新的进位传递给下一位。运算结束后，由于数组是从低位到高位存储的，需要倒序遍历数组输出非零的高位及其后的所有数字，即为最终的阶乘结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>a: .space 12000<br><br>.macro push(%src)<br>addi $sp,$sp,-4<br>sw %src,0($sp)<br>.end_macro <br><br>.macro  pop(%dst)<br>lw %dst,0($sp)<br>addi $sp,$sp,4<br>.end_macro <br><br>.macro getInt(%dst)<br>li $v0,5<br>syscall<br>move %dst,$v0<br>.end_macro <br><br>.macro printInt(%src)<br>move $a0,%src<br>li $v0,1<br>syscall <br>.end_macro <br><br>.text:<br>main:<br><br>li $t0,1<br>sw $t0,a($zero)<br>getInt($s0)<br>li $s1,1#s1为长度l<br>li $t0,2<br>loop_calc:<br>bgt,$t0,$s0,calc_end<br>move $a0,$t0<br>jal multi<br>addi $t0,$t0,1<br>j loop_calc<br>calc_end:<br>subi $t0,$s1,1<br>loop_out:<br>bltz $t0,end<br>sll $t2,$t0,2<br>lw $t1,a($t2)<br>printInt($t1)<br>subi $t0,$t0,1<br>j loop_out<br>end:<br>li $v0,10<br>syscall <br><br><br>multi:<br>push($ra)<br>push($t0)<br>push($t1)<br>push($t2)<br>push($t3)<br>push($t4)<br>push($s2)<br>move $t1,$a0<br>li $t0,0<br>li $s2,0<br>loop1:<br>beq $t0,$s1,loop1_end<br>sll $t2,$t0,2<br>lw $t3,a($t2)<br>mult $t3,$t1<br>mflo $t4<br>add $t3,$t4,$s2<br>li $t4,10<br>div $t3,$t4<br>mflo $s2#c<br>mfhi $t3#temp<br>sll $t2,$t0,2<br>sw $t3,a($t2)<br>addi $t0,$t0,1<br>j loop1<br>loop1_end:<br>loop2:<br>beqz $s2,loop2_end<br>li $t4,10<br>div $s2,$t4<br>mfhi $t1<br>sll $t2,$s1,2<br>sw $t1,a($t2)<br>mflo $s2<br>addi $s1,$s1,1<br>j loop2<br>loop2_end:<br>pop($s2)<br>pop($t4)<br>pop($t3)<br>pop($t2)<br>pop($t1)<br>pop($t0)<br>pop($ra)<br>jr $ra<br></code></pre></td></tr></table></figure><h2 id="笔者的话"><a href="#笔者的话" class="headerlink" title="笔者的话"></a>笔者的话</h2><p>很可惜，从P2开始，迫于课业压力等原因，博客的完整程度会略有下降，但在此保证每次的上机题目均会提供。而课下题目题面和解答可能都有所缺失，<del>当本人放寒假时再来看已经不会做了</del>。不过现在ai如此发达，相信给出题面大家便能找到满意的解答。祝大家co上机顺利！</p>]]></content>
    
    
    <categories>
      
      <category>CO课下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>CO课下</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P1上机-问题反思总结</title>
    <link href="/posts/P1%E4%B8%8A%E6%9C%BA-%E9%97%AE%E9%A2%98%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93/"/>
    <url>/posts/P1%E4%B8%8A%E6%9C%BA-%E9%97%AE%E9%A2%98%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>还是一样先给出这次上机的考题叭~</p><h2 id="P1-CNNX-异或卷积"><a href="#P1-CNNX-异或卷积" class="headerlink" title="P1_CNNX-异或卷积"></a>P1_CNNX-异或卷积</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>给出一个位宽为$36$的输入$a$ ，代表一个$6\times 6$的矩阵。再给出一个位宽为$9$的输入$b$ ，代表一个$3\times 3$的卷积核。请你输出一个位宽为$16$的输出$ans$ ，代表卷积后的$4\times 4$ 的矩阵。</p><p>将位宽为$n^2$的数据$a$转换成$n \times n$矩阵的规则为：将$a$从低位到高位依次填入矩阵，先填满第 0 行，再填满第 1 行，以此类推。从矩阵转换成数据的规则相同。</p><p>精确定义： 矩阵第$i$行、第$j$列的元素$M[i][j]$（行列均从$0$开始计数）的值，等于$a$的第$i\times n+j$位。 数学公式表达为：</p><p>$M[i][j] = a_{i \times n+j}$</p><p>例如：给定输入 = <code>9&#39;b110100001</code>，则其对应的矩阵为：</p><img src="/posts/P1%E4%B8%8A%E6%9C%BA-%E9%97%AE%E9%A2%98%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93/image-20260124120132364.png" class="" title="image-20260124120132364"><p>卷积操作是指，对于输出矩阵$ans$中的每一个元素$ans[i][j]$(其中$0\leq i,j \leq 3$)，其值由输入矩阵$a$中以$a[i][j]$为左上角的$3\times 3$子矩阵与卷积核$b$计算得出。</p><p>计算方法为：将该$3\times 3$子矩阵与卷积核$b$的对应元素逐个进行 <strong>逻辑与（AND）</strong>，然后将得到的$9$个结果进行 <strong>异或（XOR）</strong> 运算，得到最终的$1$位结果$ans[i][j]$ 。 用公式表达为：</p><p>$ans[i][j]=\bigoplus_{k=0}^{2} \bigoplus_{l=0}^{2} a[i+k][j+l] \wedge b[k][l]$</p><p>其中$\wedge$表示与运算，$\oplus$表示异或运算。</p><p>最后输出一维的$ans$矩阵，其与二维$ans$矩阵的转化规则为：</p><p>$ans_{i\times 4+j}=ans[i][j]$</p><h3 id="2、模块规格"><a href="#2、模块规格" class="headerlink" title="2、模块规格"></a>2、模块规格</h3><p>模块名：CNNX</p><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>a[35:0]</td><td>I</td><td>用于卷积的矩阵</td></tr><tr><td>b[8:0]</td><td>I</td><td>卷积核</td></tr><tr><td>ans[15:0]</td><td>O</td><td>卷积结果</td></tr></tbody></table></div><h3 id="3、输入输出样例"><a href="#3、输入输出样例" class="headerlink" title="3、输入输出样例"></a>3、输入输出样例</h3><img src="/posts/P1%E4%B8%8A%E6%9C%BA-%E9%97%AE%E9%A2%98%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93/2df44a47b2a068f01ea6655c37050cce.png" class="" title="2df44a47b2a068f01ea6655c37050cce"><p>如图，当 <code>a = 36&#39;hfffffffff</code> ，<code>b = 9&#39;h000</code> 时，<code>ans = 16&#39;h0000</code> 。</p><p>当 <code>a = 36&#39;h3a9f01be7</code> ，<code>b = 9&#39;h191</code> 时，<code>ans = 16&#39;hc1e0</code> 。</p><h3 id="4、提交要求"><a href="#4、提交要求" class="headerlink" title="4、提交要求"></a>4、提交要求</h3><ul><li>必须严格按照模块的端口名称和方向定义。</li><li>文件内模块名： CNNX</li><li>模块内不要包含任何 <code>$display</code> 语句，以防造成误判。</li></ul><h2 id="P1-note-recorder-音符记录器"><a href="#P1-note-recorder-音符记录器" class="headerlink" title="P1_note_recorder-音符记录器"></a>P1_note_recorder-音符记录器</h2><h3 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h3><p>你需要设计一个简单的音符记录器。这个记录器可以存储最近的$128$个音符（位置为$0-127$），并能根据指令对这些音符进行分析和处理。</p><p>我们用数字$0-7$表示不同的音符（$0$表示休止符，$1-7$分别表示 <code>do-re-mi-fa-sol-la-si</code>）。记录器需要能够添加新音符、查询特定位置的音符，以及计算特定音符的出现次数。</p><h3 id="2、功能说明"><a href="#2、功能说明" class="headerlink" title="2、功能说明"></a>2、功能说明</h3><p>同步复位操作：清空所有存储的音符记录（设为 <code>3&#39;d0</code>），$note_{out}$和$count$也置零。</p><p>每当时钟上升沿到达：</p><ol><li>添加音符（ 为 <code>2&#39;b00</code>）：所有已记录的音符位置前移$1$位，位置为$0$的音符被丢弃，将$note_{in}$添加到位置为$127$的地方，输出保持不变。初始状态下所有位置都是休止符。</li><li>查询音符（ 为 <code>2&#39;b01</code>）：将$query$位置的音符值输出到$note_{out}$，$count$保持不变。</li><li>统计音符（ 为 <code>2&#39;b11</code>）：统计当前存储的$128$个音符中，值等于$query[2:0]$的音符个数，结果输出到 ，$note_{out}$，$count$保持不变。</li><li>无效操作（ 为 <code>2&#39;b10</code>）：保持上一周期输出。</li></ol><h3 id="3、模块规格"><a href="#3、模块规格" class="headerlink" title="3、模块规格"></a>3、模块规格</h3><p>模块名：note_recorder</p><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td>同步复位信号，高电平有效</td></tr><tr><td>note_in[2:0]</td><td>I</td><td>输入的音符值</td></tr><tr><td>op[1:0]</td><td>I</td><td>操作码</td></tr><tr><td>query[6:0]</td><td>I</td><td>查询位置或要统计的音符值</td></tr><tr><td>note_out[2:0]</td><td>O</td><td>查询操作的输出音符值</td></tr><tr><td>count[7:0]</td><td>O</td><td>统计操作的输出计数值</td></tr></tbody></table></div><h3 id="4、输入输出样例"><a href="#4、输入输出样例" class="headerlink" title="4、输入输出样例"></a>4、输入输出样例</h3><img src="/posts/P1%E4%B8%8A%E6%9C%BA-%E9%97%AE%E9%A2%98%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93/b4abddf2af10f3ba26d99d575ef3400d.png" class="" title="b4abddf2af10f3ba26d99d575ef3400d"><ol><li>时钟周期 1 复位后，所有存储单元为 ，<code>note_out = 0</code>，<code>count = 0</code>。</li><li>如图，添加音符：<ul><li>时钟周期 2：<code>note_in = 3&#39;d1</code>，<code>op = 2&#39;b00</code>（添加音符 do）</li><li>时钟周期 3：<code>note_in = 3&#39;d2</code>，<code>op = 2&#39;b00</code>（添加音符 re）</li><li>时钟周期 4：<code>note_in = 3&#39;d3</code>，<code>op = 2&#39;b00</code>（添加音符 mi）</li><li>此时序列为 （共 个零）</li></ul></li><li>查询操作：<ul><li>时钟周期 5：<code>query = 7&#39;d127</code>，<code>op = 2&#39;b01</code>（查询最新添加的音符）</li><li>同一时钟周期，<code>note_out = 3&#39;d3</code></li></ul></li><li>统计操作：<ul><li>时钟周期6：<code>query = 7&#39;d0</code>，<code>op = 2&#39;b11</code>（统计休止符个数）</li><li>同一时钟周期，<code>count = 8&#39;d125</code></li></ul></li></ol><h3 id="5、提交要求"><a href="#5、提交要求" class="headerlink" title="5、提交要求"></a>5、提交要求</h3><ul><li>必须严格按照模块的端口名称和方向定义。</li><li>文件内模块名：note_recorder。</li><li>模块内不要包含任何 <code>$display</code> 语句，以防造成误判。</li></ul><h2 id="P1-json-序列检验"><a href="#P1-json-序列检验" class="headerlink" title="P1_json-序列检验"></a>P1_json-序列检验</h2><h2 id="1、题目简介"><a href="#1、题目简介" class="headerlink" title="1、题目简介"></a>1、题目简介</h2><p>你需要设计一个 Moore 型状态机对一个 json 序列进行有效性检测并统计键值对数量。每个周期内，串行输入 json 序列的一个字符，你需要根据现有的输入来决定输出并在下个时钟上升沿更新。</p><h3 id="json-介绍"><a href="#json-介绍" class="headerlink" title="json 介绍"></a>json 介绍</h3><p>具体的，对于一个示例 json 序列：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>   <br>    <span class="hljs-attr">&quot;key1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;key2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;key3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value3&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>我们会将该 json 序列集中在一行，同时去掉所有空白字符，形如下文：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;key1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;value1&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;key2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;value2&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;key3&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;value3&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后每个周期以 ASCII 码的形式输入该 json 序列的一个字符。</p><p>比如：第$0$周期输入左括号 <code>&#123;</code> 。第$1$周期输入左双引号 <code>&quot;</code> 。第$2$周期输入字符 <code>k</code> …… 以此类推。</p><p>对于所有输入的 json 序列，都满足以下格式规范：</p><ul><li>每个 json 序列以左大括号 “{“ 为开始，以右大括号 “}” 为结束。内部不包含嵌套大括号。</li><li>每个 json 序列内部由不定组键值对组成，每组键值对之间用逗号 “,” 隔开。可以没有键值对，也可以有多组键值对。最多包含$255$组键值对。</li><li>键值对的格式严格符合 <code>&quot;key&quot;:&quot;value&quot;</code> 。其中内部的 key 和 value 可被替换且至少有一个字符（不为空字符串），例如 <code>&quot;test&quot;:&quot;CO&quot;</code> 。字符串由大小写字母和数字组成，不包含嵌套双引号，长度最多为$15$个字符。</li><li>相邻两个 json 序列间用若干个空格隔开（可以没有空格）。例如 <code>&#123;&quot;fruit&quot;:&quot;apple&quot;&#125; &#123;&#125;&#123;&quot;animal&quot;:&quot;cat&quot;&#125;</code>。</li></ul><h3 id="输出介绍"><a href="#输出介绍" class="headerlink" title="输出介绍"></a>输出介绍</h3><p>输出包括两个$8bits$的变量$cur_num$，$max_num$。在初始状态或 后为 <code>8&#39;d0</code> 。</p><ul><li>$cur_num$：输出当前 json 序列的键值对数目。具体的，在每个 json 序列输入完毕的下一个时钟上升沿更新该 json 序列中的键值对数目。例如，对于输入 <code>&#123;&quot;k1&quot;:&quot;v1&quot;,&quot;k2&quot;:&quot;v2&quot;&#125;</code> ，该 json 序列含有$2$组键值对，<strong>若当前周期输入了右大括号 “}”</strong>，则在下一个时钟上升沿更新$cur_num$为 <code>8&#39;d2</code> ，之后$cur_num$将一直不变直到$reset$ 或 下一个 json 序列输入完毕。</li><li>$max_num$：输出历史输入的 json 序列的键值对数目的最大值。具体的，每次$cur_num$更新时，同步更新$max_num$为历史所有$cur_num$中的最大值。例如，对于输入 <code>&#123;&quot;k&quot;:&quot;v&quot;&#125; &#123;&quot;k1&quot;:&quot;v1&quot;,&quot;k2&quot;:&quot;v2&quot;&#125;&#123;&#125;</code> ，在第一个 json 序列的右大括号输入后，下一个周期 <code>cur_num = 8&#39;d1 , max_num = 8&#39;d1</code> 。在第二个 json 序列的右大括号输入后，下一个周期 <code>cur_num = 8&#39;d2 , max_num = 8&#39;d2</code> 。在第三个 json 序列的右大括号输入后，下一个周期 <code>cur_num = 8&#39;d0 , max_num = 8&#39;d2</code> 。<strong>当$reset$后，清空所有 json 序列历史记录。</strong></li></ul><h3 id="特别情况"><a href="#特别情况" class="headerlink" title="特别情况"></a>特别情况</h3><ul><li>正常情况下 json 序列键值对中的字符串不为空，即至少有一个字符。</li><li><strong>若 json 序列键值对中的字符串出现空串，即 <code>&#123;&quot;&quot;:&quot;value&quot;&#125;</code> 或 <code>&#123;&quot;key&quot;:&quot;&quot;&#125;</code> ，则该 json 序列为无效序列，其$cur_num$视为 <code>8&#39;d0</code> 。</strong> json 序列为有效序列当且仅当内部所有键值对的字符串都不是空串。</li><li>除了上述情况外，不会出现其他非法情况。即输入的 json 序列只有两种：1. 合法 json 序列，所有键值对的字符串均不为空串。 2. 无效 json 序列，至少有一个字符串是空串。</li><li>保证在每个 json 序列输入的过程中不会出现$reset$，即$reset$只可能会在 json 序列之间的间隙出现。</li><li><strong>判断输入$char$是否等于双引号时，请使用：<code>char == 8&#39;h22</code></strong> 。</li></ul><h3 id="2、模块规格-1"><a href="#2、模块规格-1" class="headerlink" title="2、模块规格"></a>2、模块规格</h3><p>模块名：json</p><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td><strong>异步</strong>复位信号</td></tr><tr><td>char[7:0]</td><td>I</td><td>串行输入的字符 ASCII 码</td></tr><tr><td>cur_num[7:0]</td><td>O</td><td>当前 json 序列的键值对数目</td></tr><tr><td>max_num[7:0]</td><td>O</td><td>历史 json 序列的最多键值对数目</td></tr></tbody></table></div><h3 id="3、输入输出样例-1"><a href="#3、输入输出样例-1" class="headerlink" title="3、输入输出样例"></a>3、输入输出样例</h3><img src="/posts/P1%E4%B8%8A%E6%9C%BA-%E9%97%AE%E9%A2%98%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93/ed24cd606779357f4fe7db839aca43e3.png" class="" title="ed24cd606779357f4fe7db839aca43e3"><p>如图，当输入为 <code>&#123;&quot;key&quot;:&quot;value&quot;&#125; &#123;&quot;k&quot;:&quot;v&quot;,&quot;k&quot;:&quot;v&quot;&#125;</code> 时，在第一个 json 序列输入完后，<code>cur_num = 1, max_num = 1</code> 。当第二个 json 序列输入完后，<code>cur_num = 2, max_num = 2</code> 。</p><h3 id="4、提交要求-1"><a href="#4、提交要求-1" class="headerlink" title="4、提交要求"></a>4、提交要求</h3><ul><li>必须严格按照模块的端口名称和方向定义。</li><li>文件内模块名： json</li><li>模块内不要包含任何 <code>$display</code> 语句，以防造成误判。</li></ul><h1 id="思路解释与总结反思"><a href="#思路解释与总结反思" class="headerlink" title="思路解释与总结反思"></a>思路解释与总结反思</h1><p>想起写这篇博客时有点晚了，已经到了P2上机的下午。对于上次上机细节已经记不清了，只能大致说说了。</p><h2 id="T1-卷积"><a href="#T1-卷积" class="headerlink" title="T1-卷积"></a>T1-卷积</h2><p>感觉卷积计算的题时常看见，出在Logisim,Verilog,MIPS里都可以，用Verilog是最简单的了。这题没有什么卡人的点，基本就是考验你能否写对循环，是否会定义数组。</p><p><strong>注意！</strong>Verilog中没有二维数组，所以$a[i][j]$得使用<code>a[i*6+j]</code>来引用。</p><p>循环变量设为<code>integer</code>，使用二重循环模拟即可，思路和C语言没差。</p><h2 id="T2-音符记录器"><a href="#T2-音符记录器" class="headerlink" title="T2-音符记录器"></a>T2-音符记录器</h2><p>这题相当的恶心且卡人。首先，一定不要把它当C语言算法题来做，要是真用队列和动态维护计数器，会有奇奇怪怪的错误<del>（别问我怎么知道的）</del>。本题是一道时序逻辑题，可以算是一种状态机吧，但是不建议往这方面想。</p><p>一般而言，我们说<code>always @(posedge clk)</code>里面应该都是非阻塞赋值<code>&lt;=</code>，但是这题计数的循环使用的是普通的<code>=</code>，考场上让我犹豫许久</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>1.<code>reg [3:0] q[0:127]</code>作为储存的$128$个音符，每次循环移位</p><p>2.<code>reg [7:0] cnt[0:7]</code>作为计数器，输入<code>2&#39;b11</code>时把q循环计数</p><p>3.嗯就这么简单，考场上不熟悉语法的话会写的很难受</p><h2 id="T3-序列检验"><a href="#T3-序列检验" class="headerlink" title="T3-序列检验"></a>T3-序列检验</h2><p>这题是来吃你时间的，但是我做的比较顺利，总耗时40min。tb会比较难写。具体题意理解以波形图为准，题目表述可能不太清楚。其他的按照操作进行计数就行，注意空串。</p>]]></content>
    
    
    <categories>
      
      <category>CO上机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>CO上机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P0上机-问题总结与反思</title>
    <link href="/posts/P0%E4%B8%8A%E6%9C%BA-%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D/"/>
    <url>/posts/P0%E4%B8%8A%E6%9C%BA-%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="P0上机-问题总结与反思"><a href="#P0上机-问题总结与反思" class="headerlink" title="P0上机-问题总结与反思"></a>P0上机-问题总结与反思</h1><h2 id="题面复原"><a href="#题面复原" class="headerlink" title="题面复原"></a>题面复原</h2><h3 id="1-P0-ups-and-downs"><a href="#1-P0-ups-and-downs" class="headerlink" title="1.P0_ups_and_downs"></a>1.P0_ups_and_downs</h3><p><strong>题目描述</strong><br>独小星在监测一个数列的起伏变化，聪明的他想到可以用状态机来自动监测。请你帮助小星设计一个 Moore 状态机，来统计一个串行输入数列的起伏规律，并在识别到特定规律时输出。</p><p><strong>前置知识</strong><br>在本题中，串行输入是指，不断将当前输入追加到之前输入数列的末尾。假设截止到某个周期共有 $m$ 个输入，从第零个周期到该周期的输入分别为：$a_{0}$，$a_1, \dots $,$a_{m-2}$，$a_{m-1}$。则从第零周期到该周期的串行输入的串依次为：</p><p>$a_0$</p><p>$a_0 a_1$</p><p>…</p><p>$a_0 a_1 a_2 a_3 \dots a_{m-1}$</p><p>本题中的“起伏”指的是：当前周期输入 $a_m$ 相对于上一周期最后输入 $a_{m-1}$ 的大小关系。若 $a_m$ 严格大于 $a_{m-1}$，则称为一次“起”。若 $a_m$ 严格小于 $a_{m-1}$，则称为一次“伏”。</p><p>数据保证<strong>相邻两周期输入不相同</strong>。</p><p><strong>任务要求</strong><br>使用 Logisim 搭建一个识别串行输入串中“起起伏起伏”规律的 Moore 状态机。</p><p>每个周期输入一个位宽为 5 的<strong>无符号数</strong>，当最近四个周期的输入使得数列满足“起”“起”“伏”“起”时，输出1，否则输出0。</p><p>状态机支持<strong>循环检测</strong>，即当前“起”“起”“伏”“起”的最后一个“起”可以作为下一次“起”“起”“伏”“起”的第一个“起”。</p><p>数列默认第零项为 <code>5&#39;d7</code>，<strong>在初始状态和复位后，数列的 $a_0 = 5’d7$</strong>。</p><p><strong>样例</strong><br>假设串行输入串为：(7)8901215，则状态机输出为：(0)0001001，其中输入的第一个 7 表示数列默认第零项为 7，输出的第一个 0 表示在第一个输入到来之前输出默认为 0。</p><p><strong>输入输出</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">功能</th><th style="text-align:left">位宽</th><th style="text-align:left">方向</th></tr></thead><tbody><tr><td style="text-align:left">a</td><td style="text-align:left">输入</td><td style="text-align:left">5</td><td style="text-align:left">I</td></tr><tr><td style="text-align:left">clk</td><td style="text-align:left">时钟信号</td><td style="text-align:left">1</td><td style="text-align:left">I</td></tr><tr><td style="text-align:left">reset</td><td style="text-align:left">异步复位信号</td><td style="text-align:left">1</td><td style="text-align:left">I</td></tr><tr><td style="text-align:left">output</td><td style="text-align:left">结果</td><td style="text-align:left">1</td><td style="text-align:left">O</td></tr></tbody></table></div><ul><li><strong>输入</strong>：上文所述 $a$ (5 bit)，时钟信号 (1 bit)，异步复位信号 (1 bit)。</li><li><strong>输出</strong>：0 或者 1。</li><li><strong>文件内模块名</strong>：main</li><li><strong>测试要求</strong>：请以 Moore 状态机的方式实现，并提供<strong>异步复位</strong>。</li></ul><hr><h3 id="2-P0-binary-calculator"><a href="#2-P0-binary-calculator" class="headerlink" title="2.P0_binary_calculator"></a>2.P0_binary_calculator</h3><p><strong>题目描述</strong><br>小企鹅在做数字电路设计时，想要设计一个支持特殊位运算的移位计算器，请你帮助设计一个 Mealy 状态机来实现这个功能。</p><p><strong>前置知识</strong><br>在本题中，我们需要设计一个基于移位操作的二进制计算器，支持以下三种操作：</p><ol><li><strong>移位加法(SA)</strong>：将当前寄存器中的数值左移一位，然后加上输入的操作数。</li><li><strong>移位减法(SS)</strong>：将当前寄存器中的数值左移一位，然后减去输入的操作数。</li><li><strong>移位异或(SX)</strong>：将当前寄存器中的数值左移一位，然后与输入的操作数进行按位异或运算。</li></ol><p><strong>任务要求</strong><br>使用 Logisim 搭建一个移位计算器的 Mealy 状态机。<br>每个周期，系统接收一个 2 位的操作码 <code>op</code> 和一个 8 位的操作数 <code>operand</code>，根据操作码执行相应的运算，输出计算结果并将该结果存入寄存器。</p><p>操作码与运算的对应关系如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">op</th><th style="text-align:left">操作</th><th style="text-align:left">功能描述</th></tr></thead><tbody><tr><td style="text-align:left">00</td><td style="text-align:left">复位</td><td style="text-align:left">将寄存器清零</td></tr><tr><td style="text-align:left">01</td><td style="text-align:left">SA</td><td style="text-align:left">将当前寄存器中的数值左移一位，然后加上输入的操作数</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">SS</td><td style="text-align:left">将当前寄存器中的数值左移一位，然后减去输入的操作数</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">SX</td><td style="text-align:left">将当前寄存器中的数值左移一位，然后与输入的操作数进行按位异或运算</td></tr></tbody></table></div><p>计算器的初始状态和复位后，寄存器中的值为 <code>8&#39;h00</code>。<br>所有计算均使用无符号 8 位整数，计算结果如果超出 8 位表示范围，则类似取模运算保留低 8 位即可。<br><strong>reset 说明</strong>：本题不需要 <code>reset</code> 信号，具体逻辑通过 <code>op</code> 实现。</p><p><strong>样例</strong><br>假设每个时钟周期只有一次输入，那么输入序列为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">op = 01, operand = 0x03 # SA 操作: (0x00 &lt;&lt; 1) + 0x03 = 0x03<br>op = 01, operand = 0x05 # SA 操作: (0x03 &lt;&lt; 1) + 0x05 = 0x0B<br>op = 10, operand = 0x02 # SS 操作: (0x0B &lt;&lt; 1) - 0x02 = 0x14<br>op = 11, operand = 0xFF # SX 操作: (0x14 &lt;&lt; 1) ^ 0xFF = 0x28 ^ 0xFF = 0xD7<br>op = 00, operand = 任意 # 复位操作: 0x00<br></code></pre></td></tr></table></figure><p>对应的输出序列为：<code>0x03, 0x0B, 0x14, 0xD7, 0x00</code></p><p>需要注意的是，本题要求使用 Mealy 型有限状态机，在一个时钟周期内可能输入不停变化，但是只要时钟上升沿没有到达，其状态就不会被写入寄存器。</p><p><strong>输入输出</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">功能</th><th style="text-align:left">位宽</th><th style="text-align:left">方向</th></tr></thead><tbody><tr><td style="text-align:left">op</td><td style="text-align:left">操作码</td><td style="text-align:left">2</td><td style="text-align:left">I</td></tr><tr><td style="text-align:left">operand</td><td style="text-align:left">操作数</td><td style="text-align:left">8</td><td style="text-align:left">I</td></tr><tr><td style="text-align:left">clk</td><td style="text-align:left">时钟信号</td><td style="text-align:left">1</td><td style="text-align:left">I</td></tr><tr><td style="text-align:left">result</td><td style="text-align:left">计算结果</td><td style="text-align:left">8</td><td style="text-align:left">O</td></tr></tbody></table></div><ul><li><strong>输入</strong>：操作码 <code>op</code>，操作数 <code>operand</code>，时钟信号。</li><li><strong>输出</strong>：计算结果 <code>result</code></li><li><strong>文件内模块名</strong>：main</li></ul><hr><h3 id="3-P0-intelligent-elevator"><a href="#3-P0-intelligent-elevator" class="headerlink" title="3.P0_intelligent_elevator"></a>3.P0_intelligent_elevator</h3><p><strong>题目描述</strong><br>独小星设计了一种智能电梯，能够根据每层乘客人数来动态调节目标楼层，请你设计一个组合电路，计算电梯移动的总楼层数。</p><p><strong>前置知识</strong><br>在本题中，<strong>一共有四个楼层</strong>，分别命名为：第 0 层、第 1 层、第 2 层、第 3 层。<br>从第 $n$ 层移动到第 $m$ 层，电梯移动了 $|m - n|$ 层楼。</p><p><strong>任务要求</strong><br>使用 Logisim 搭建一个组合电路，根据输入的信息计算电梯移动的总楼层数，并输出。</p><p>电梯初始停留楼层不固定，由输入信号 <code>from</code> 指定。<code>from</code> 是一个位宽为 4 的独热编码，其与初始停留楼层的对应关系如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">from</th><th style="text-align:left">初始停留楼层</th></tr></thead><tbody><tr><td style="text-align:left">0001</td><td style="text-align:left">第 0 层</td></tr><tr><td style="text-align:left">0010</td><td style="text-align:left">第 1 层</td></tr><tr><td style="text-align:left">0100</td><td style="text-align:left">第 2 层</td></tr><tr><td style="text-align:left">1000</td><td style="text-align:left">第 3 层</td></tr></tbody></table></div><p>该电梯为理想电梯，乘客只上不下，电梯容量无限。<br>电梯停留在某一楼层时，可以认为该层乘客全部进入电梯了，后续该层乘客数即为 0。由于电梯一开始停留在初始楼层，因此无论输入的乘客数是多少，初始楼层乘客数可直接视为 0。</p><p>电梯的运行逻辑为：寻找目前所有楼层中<strong>乘客数最多且不为 0</strong> 的楼层，并视其为目标楼层，然后从当前停留楼层直达目标楼层并停留（中间路过的楼层不算做停留）。之后继续以该逻辑运行，直到所有楼层乘客数都为 0。</p><p>数据保证<strong>所有楼层乘客数不相同，且均不为 0</strong>。</p><p><strong>输入输出</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">功能</th><th style="text-align:left">位宽</th><th style="text-align:left">方向</th></tr></thead><tbody><tr><td style="text-align:left">from</td><td style="text-align:left">初始楼层独热编码</td><td style="text-align:left">4</td><td style="text-align:left">I</td></tr><tr><td style="text-align:left">num0</td><td style="text-align:left">第 0 层乘客数</td><td style="text-align:left">8</td><td style="text-align:left">I</td></tr><tr><td style="text-align:left">num1</td><td style="text-align:left">第 1 层乘客数</td><td style="text-align:left">8</td><td style="text-align:left">I</td></tr><tr><td style="text-align:left">num2</td><td style="text-align:left">第 2 层乘客数</td><td style="text-align:left">8</td><td style="text-align:left">I</td></tr><tr><td style="text-align:left">num3</td><td style="text-align:left">第 3 层乘客数</td><td style="text-align:left">8</td><td style="text-align:left">I</td></tr><tr><td style="text-align:left">output</td><td style="text-align:left">电梯移动总楼层数</td><td style="text-align:left">8</td><td style="text-align:left">O</td></tr></tbody></table></div><ul><li><strong>输入</strong>：保证 <code>num0</code>, <code>num1</code>, <code>num2</code>, <code>num3</code> 互不相等，且均不为 0。</li><li><strong>输出</strong>：电梯移动总楼层数 (8 bit)。</li><li><strong>文件内模块名</strong>：main</li><li><strong>注意</strong>：请保证模块的 appearance 与下图一致，否则有可能造成评测错误。注意输入的上下顺序。</li></ul><h2 id="解答与反思"><a href="#解答与反思" class="headerlink" title="解答与反思"></a>解答与反思</h2><p>第一二题都比较简单（绝对不是这个入懒得重新做的），在我印象中P1还是有点卡人的，主要点在于这个$5’d7$的初始值，我们实际上是无法直接初始化的。要么使用$MUX$选择是7还是寄存器出来的值，要么直接将输入减$7$即可。</p><p>第三题我记得当时颇引起一些风波。我记得有一位同学的做法特别好，我们课下已经学会了排序，这题应该怎么直接套用呢？将$0,1,2,3$补到输入的末尾（$2$位二进制数），对这四个补完的数排序，末尾两位代表对应楼层，这样就知道四个楼层的大小关系了。核心部分就能直接做出来。当然，打表也是可以做的。</p><p>附上我课后重做的文件：</p><a class="btn" href="/files/T3.circ"  title="fas fa-download" target="_blank">T3.circ</a>]]></content>
    
    
    <categories>
      
      <category>CO上机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>CO上机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P1课下-总结反思</title>
    <link href="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/"/>
    <url>/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<p>这次可能是最简单的一次课下了？只有附加题较难。当然这并不是好事，可能会导致上机难度陡然上升而我们在课下没有得到充分练习的情况。还是与往常一样，分为教程复现，题面，思路与题解三部分。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="Verilog-FSM-设计流程"><a href="#Verilog-FSM-设计流程" class="headerlink" title="Verilog FSM 设计流程"></a>Verilog FSM 设计流程</h3><h4 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h4><p>对于状态机的概念和用法在理论课和前面部分的学习中接触到了很多，所以在此不再过多叙述。</p><p>在 Verilog HDL 中可以用许多种方法来描述有限状态机，最常用的方法是用 <strong>always 语句</strong>和 <strong>case 语句</strong>。下面具体说明用 Verilog 设计有限状态机的一般步骤：</p><ol><li><p>逻辑抽象，得出状态转换图。</p></li><li><p>状态化简（该步骤可以省略），如果在状态转换图中出现两个一样的状态则需要将其合并为一个状态，以得到最简的状态转换图。</p></li><li><p>状态分配，也就是状态编码。通常有很多种编码方式，比如 Gray 编码、独热编码等。在实际电路中，需综合考虑电路复杂度与电路性能之间的折中。这里的设计没有用到特别复杂的电路逻辑，所以大家可以自行决定用哪种编码方式。（不过，对于需要在FPGA上运行的电路，推荐使用<strong>独热</strong>编码方式。因为 <a href="http://cscore.buaa.edu.cn/tutorial/fpga/intro/intro/">FPGA</a> 有丰富的寄存器资源，门逻辑相对缺乏，采用独热编码可以有效提高电路的速度和可靠性，也有利于提高器件资源的利用率。）</p><p>下面利用独热编码来介绍状态编码定义的两种方式：parameter 和 `define 语句。</p><ul><li>用 parameter 参数定义：用 n 个 parameter 常量表示 n 个状态，如下图所示：</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">parameter</span> State1 = <span class="hljs-number">4&#x27;b0001</span>,<br>       State2 = <span class="hljs-number">4&#x27;b0010</span>,<br>       State3 = <span class="hljs-number">4&#x27;b0100</span>,<br>       State4 = <span class="hljs-number">4&#x27;b1000</span>;<br>...............<br><br><span class="hljs-keyword">case</span> (State)<br>     State1:........;<br>     State2:........;<br>     ........<br></code></pre></td></tr></table></figure><ul><li>用`define 语句定义：用 n 个宏名表示 n 个状态，如下所示：</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">define</span> State1 4&#x27;b0001</span><br> <span class="hljs-comment">// 不要加分号</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> State2 4&#x27;b0010</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> State3 4&#x27;b0100</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> State4 4&#x27;b1000</span><br>...<br><br><span class="hljs-keyword">case</span> (State)<br>    `State1:...;<br>    `State2:...;<br>    ...<br><span class="hljs-keyword">endcase</span><br></code></pre></td></tr></table></figure></li><li><p>根据状态转移图得出次态逻辑和输出逻辑。</p></li><li><p>按照相应逻辑，用 Verilog HDL 来描述有限状态机状态转移的情况。</p></li></ol><ul><li>复位时回到起始状态（敏感信号为<strong>时钟</strong>和<strong>复位</strong>信号，注意同步复位和异步复位的区别）</li><li>用 case 或 if-else 语句描述出状态的转移（根据现态（和输入）产生次态，可以与复位时回到起始状态的语句放在同一个 always 块中，即敏感信号为时钟和复位信号）</li><li>输出信号描述。用 case 语句或 if-else 语句描述状态机的输出信号</li></ul><h4 id="设计建议"><a href="#设计建议" class="headerlink" title="设计建议"></a>设计建议</h4><p>下面给出设计的几点建议：</p><ul><li>一般用 <strong>case、casez 或 casex</strong> 语句进行状态判断，比用 if-else 语句更加清晰明了。</li><li>在 case 语句的最后，要加上 <strong>default</strong> 分支语句，以避免锁存器的产生。</li><li>状态机一般应设计为<strong>同步</strong>方式，并由一个时钟信号来触发。</li><li>实用的状态机都应设计为由唯一的<strong>时钟边沿</strong>触发的<strong>同步</strong>运行方式。</li></ul><h3 id="Verilog-状态机设计示例"><a href="#Verilog-状态机设计示例" class="headerlink" title="Verilog 状态机设计示例"></a>Verilog 状态机设计示例</h3><h4 id="MOORE-型状态机设计示例"><a href="#MOORE-型状态机设计示例" class="headerlink" title="MOORE 型状态机设计示例"></a>MOORE 型状态机设计示例</h4><p>在上一节中，我们复习了 Verilog 状态机的设计流程。这一节我们以一个简单的状态机为例，解析如何全面地设计一个 Moore 型状态机。下面是一道简单的题目：</p><h4 id="用于识别串-1010-的自动机"><a href="#用于识别串-1010-的自动机" class="headerlink" title="用于识别串 1010 的自动机"></a>用于识别串 1010 的自动机</h4><p>clk 上升沿时，读入一个字符 in ，这时若<code>1010</code>是已读入的字符串的后缀，则 out 输出<code>1</code>，否则输出<code>0</code>。</p><blockquote><p>例如：对于已有输入<code>101</code>，输出为<code>0</code>，对于<code>101010</code>，输出为<code>1</code>。</p></blockquote><p>设计状态机的第一步，我们需要先分析问题，确定状态的<strong>数量</strong>和<strong>定义</strong>。</p><p>这道题我们需要设计一个识别 1010 的状态机。要确定它的状态数量，我们可能直觉认为要设置5种状态，分别处理读入了 ∅,1,10,101,1010 五种情况。这种想法是可行的，我们先根据这个直观的理解画出部分状态转换图，其中 state=0,1,2,3,4 分别对应“读入了∅,1,10,101,1010”。</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.5.2.png" class="" title="p1.0.5.2"><p>显然，如果从零时刻开始，串行输入 1010 ，状态机会按照 state=0-&gt;1-&gt;2-&gt;3-&gt;4 的顺序转移，假如我们规定 out=1 当且仅当 state=4 ，那么状态机可以正确识别 1010 的串。问题是，当匹配到 101 时，如果读入了一个1，得到了 1011 ，我们该如何正确选择应该转移到哪个状态？为此，我们要用一种啰嗦的方式严格定义状态 statei 的意义。我们看到，所谓“读入了 ∅,1,10,101,1010”是一种很模糊的说法，它有歧义。例如字符流是 1010 ，我们该说“读入了10”，还是“读入了1010”呢？因此，原来的说法不是良好的定义，因为它不能单单根据字符流来确定究竟是哪个状态。</p><p><strong>定义</strong>：设目标字符串 1010 为 str；状态机处于 statei 当且仅当：i&gt;0, 设所有 1&lt;=j&lt;=4, str[1:j] 能匹配的输入字符流的后缀为 <strong>S</strong>，str[1:i] 匹配的输入字符流的后缀在 <strong>S</strong> 中最长; i=0, 当且仅当所有 1&lt;=j&lt;=4, str[1:j] 都不能匹配输入字符流的任何一个后缀。</p><p>str[1:i] 的意义是 str 第 1 个字符到第 i 个字符的部分，比如 str[1:4] 就是 <strong>1010</strong>。通过这个定义，我们就可以很好地直接根据字符流确定是哪个状态。例如读入了 1010 时，显然 str[1:2], str[1:4] 都可以匹配 1010 的后缀，前者对应 state2，后者对应 state4，然而后者匹配的后缀长度最长，因此我们确定这时应该是 state=state4。</p><p>这样的定义是有好处的，有了它，我们就可以根据字符流判断是哪个状态。当然，这种状态的正确性的维护有赖于状态转移函数的选择。如果状态转移函数胡乱规定，我们就无法确定状态的正确性。</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.5.2.png" class="" title="p1.0.5.2"><p>在这里，我们采用类似于动态规划的思路规划状态转移函数。思路是：每在状态之间加入一条或几条表示状态转移的边，都要保证这样的操作能维持一个<strong>性质</strong>——在外界输入保证变换只涉及当前已经加入的边的条件下，涉及到的状态不违背我们事先约定的定义。</p><p>现在我们有四条边，我们考虑在这四条边上进行状态转移的情况。初始状态为 state=0。显然要走到 4，只有一条路径 0-&gt;1-&gt;2-&gt;3-&gt;4，对应输入 1010。state=0 时，我们回顾<strong>定义</strong>，输入的字符流是 ∅，这时谁也匹配不了，我们保持了状态定义的正确性；state=1，输入的字符流是 1，str[1:i], i=1 能匹配最长的后缀，而别的 str[1:j] 都不能匹配，我们再次保持了状态定义的正确性……接下来你可以自己推导，我们初步的状态转移设置确实维护了<strong>定义的正确性</strong>。</p><p>接下来，我们要补全状态转换图。当前的状态转换图是不完整的，我们在维持定义正确性的前提下补全每个状态下 0,1 两种输入对应的状态转移后，就得到了完整的正确的状态转换图。</p><p>首先从 state=0 开始考虑，我们欠缺了输入为 0 的情况。我们尝试加入一条边，再验证它的正确性。</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.5.3.png" class="" title="p1.0.5.3"><p>首先，我们根据前面的分析，知道假如状态转移只走之前加过的边，状态的定义是被保持的。现在我们考虑经过新加边的情况。当 state=0，对任意 1&lt;=j&lt;=4，输入字符流的末尾没有一个符合 str[1:j]，新加边表示我们又读入了一个 0，显然还是没有 statej 来匹配输入字符流的后缀。因此新加边没有影响定义的正确性。</p><p>接着我们看 state=1。我们像上面一样，添加一个状态转移边并分析正确性。</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.5.4.png" class="" title="p1.0.5.4"><p>回顾定义，state=1 时，字符串”1”即 str[1:1] 匹配的输入字符流的后缀在所有状态中最长的。隐含的意思是，我们不需要考虑输入字符流的后缀有什么“101”的情况。这时我们读入了一个字符 1，那么输入字符流的一个后缀是 11，我们扫遍所有的 statej，发现还是 state1 匹配的后缀最长，因此要保持在 state=1。我们再次维护了上述的定义的正确性。</p><p>以此类推，我们容易得到正确的状态转移图：</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.5.5.png" class="" title="p1.0.5.5"><p>最后，把状态转换图改写成对应的 Verilog 程序，并注意根据 state 维护 out 的值，我们就成功实现了一个能正确识别1010串的 Moore 型有限状态机。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> fsm_1010(<br>     <span class="hljs-keyword">input</span> clk,<br>     <span class="hljs-keyword">input</span> in,<br>     <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out = <span class="hljs-number">0</span><br>    );<br><br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;<br>     <span class="hljs-comment">/* state 被期望能够正确表示当前累计读入的 1010 前缀的长度。</span><br><span class="hljs-comment">     比如未读入时 state=0; 读入到 10 时我们期望有 state&lt;=2。*/</span><br><br>     <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">case</span> (state)<br>        <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">begin</span><br>                state &lt;= in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>                out &lt;= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">begin</span><br>                state &lt;= in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;<br>                out &lt;= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">begin</span><br>                state &lt;= in == <span class="hljs-number">1</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">0</span>;<br>                out &lt;= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">begin</span><br>                state &lt;= in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">4</span>;<br>                out &lt;= (in == <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">begin</span><br>                state &lt;= in == <span class="hljs-number">1</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">0</span>;<br>                out &lt;= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">endcase</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="状态机编码风格"><a href="#状态机编码风格" class="headerlink" title="状态机编码风格"></a>状态机编码风格</h4><p>前面我们已经知道了如何使用 Verilog 语言来描述状态机。这里介绍一下状态机的典型状态编码风格，仍然使用前面的例子进行分析。状态机的编码风格有一段式（也称高速状态机）、两段式、三段式等。</p><h5 id="一段式状态机"><a href="#一段式状态机" class="headerlink" title="一段式状态机"></a>一段式状态机</h5><p>一段式状态机将整个状态机编写在<strong>一个</strong> always 模块里，该模块采用同步时序逻辑，全部使用非阻塞赋值。该模块既描述状态转移，又描述状态的输入和输出。上面的例程就是典型的一段式状态机。</p><p>采用一段式状态机在思路上比较容易，书写的用时少，且运行速度快，在上机的时候可以节省编码的用时。但缺点是维护代码和调试比较困难。采用两段式和三段式状态机可以避免以上问题。</p><h5 id="两段式状态机"><a href="#两段式状态机" class="headerlink" title="两段式状态机"></a>两段式状态机</h5><p>两段式状态机使用<strong>两个</strong> always 模块，第一个 always 模块采用同步时序逻辑描述状态转移；第二个 always 模块使用组合逻辑判断状态转移的条件，描述状态转移的规律。</p><p>和一段式状态机相比，采用两段式状态机实现了同步时序列逻辑和组合逻辑的分离，便于阅读、理解和维护，有利于综合工具优化代码，方便用户添加时序约束条件。但缺点是编码环节多，代码量稍大，较为繁琐，因为要将其拆分成两个不同的模块。</p><p>示例代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> fsm_1010 (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out<br>);<br><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] next_state;<br><br><span class="hljs-comment">// 描述状态转移的时序逻辑</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    state &lt;= next_state; <span class="hljs-comment">// 这里还可以视情况添加复位功能</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">// 判断状态转移条件以及产生输出组合逻辑</span><br><span class="hljs-keyword">always</span> @(state, in) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span> (state)<br>        <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>                out = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;<br>                out = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">0</span>;<br>                out = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">4</span>;<br>                out = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">0</span>;<br>                out = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = <span class="hljs-number">0</span>;<br>                out = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">end</span> <span class="hljs-keyword">module</span><br></code></pre></td></tr></table></figure><h5 id="三段式状态机"><a href="#三段式状态机" class="headerlink" title="三段式状态机"></a>三段式状态机</h5><p>三段式状态机使用<strong>三个</strong> always 模块，第一个 always 模块采用同步时序逻辑描述状态转移；第二个 always 模块采用组合逻辑判断状态转移条件，描述状态转移规律；第三个 always 模块采用组合逻辑或者时序逻辑述每个状态的输出。</p><p>和两段式状态机相比，这样可以减少毛刺的产生（想想这是为什么）。其缺点和两段式状态机相同，编码复杂，消耗的资源也比较多，因为需要初态和次态状态寄存器等。</p><blockquote><p>这是因为三段式状态机将输出分离成独立的组合逻辑，减小了关键路径和时延，所以可以减少毛刺现象。</p></blockquote><p>示例代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> fsm_1010 (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out<br>);<br><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] next_state;<br><br><span class="hljs-comment">// 描述状态转移的时序逻辑</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    state &lt;= next_state;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">// 判断状态转移条件的组合逻辑</span><br><span class="hljs-keyword">always</span> @(state, in) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span> (state)<br>        <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">4</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">// 产生输出的组合逻辑</span><br><span class="hljs-keyword">always</span> @(state) <span class="hljs-keyword">begin</span><br>    out = (state == <span class="hljs-number">4</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>上面的例子是针对 Moore 状态机的，在 Mealy 状态机上也可以尝试使用这三种风格进行状态机的书写，代码框架是相同的。</p><p>同学们可以根据自身情况选用这三种不同风格的状态机，但一定要明白它们的内在区别和其中的设计原理，帮助自己在课下和上机的时候顺利完成各种状态机的书写。</p><div class="table-container"><table><thead><tr><th>思考题</th></tr></thead><tbody><tr><td>Verilog 语言和 Logisim 软件都可以用来对数字电路进行建模，你认为它们各有什么优缺点？</td></tr><tr><td>在使用 Verilog 编写电路时，一般很少使用到循环语句，如<code>for</code>语句等，Verilog 语言中也不包含<code>break</code>、<code>continue</code>这样的关键字。思考这是为什么？</td></tr><tr><td>Verilog 中的<code>generate</code>块在教程正文中并未提及，但有时这种语法可以给我们编写模块带来许多方便之处。请查阅相关资料，了解其作用与相关用法。</td></tr></tbody></table></div><h3 id="Verilog-模块代码样例"><a href="#Verilog-模块代码样例" class="headerlink" title="Verilog 模块代码样例"></a>Verilog 模块代码样例</h3><h4 id="小型通用模板"><a href="#小型通用模板" class="headerlink" title="小型通用模板"></a>小型通用模板</h4><p>这一节主要给出笔者个人对于不同需求的代码样例，供大家参考。</p><ul><li><p>MUX</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> result = (Aluop == <span class="hljs-number">4&#x27;d0</span>) ? (srca + srcb) :<br>                   (Aluop == <span class="hljs-number">4&#x27;d1</span>) ? (srca - srcb) :<br>                   (Aluop == <span class="hljs-number">4&#x27;d2</span>) ? (srca &amp; srcb) :<br>                   (Aluop == <span class="hljs-number">4&#x27;d3</span>) ? (srca | srcb) :<br>                   (Aluop == <span class="hljs-number">4&#x27;d4</span>) ? (srca ^ srcb) :<br>                   (Aluop == <span class="hljs-number">4&#x27;d5</span>) ? (srca &gt; srcb) :<br>                   <span class="hljs-number">32&#x27;d0</span>;<br></code></pre></td></tr></table></figure></li><li><p>如果涉及有符号数的运算，不推荐使用三目运算符，推荐使用 always@(<em>) 的方式，一般来说 always@(</em>) 配合 case 写出的类似 MUX 语句在仿真中的行为类似纯组合逻辑，但是 result 在写代码时应写为 reg 型。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">case</span>(Aluop)<br>        <span class="hljs-number">4&#x27;d0</span>:<span class="hljs-keyword">begin</span><br>            result = srca + srcb;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4&#x27;d1</span>:<span class="hljs-keyword">begin</span><br>            result = srca - srcb;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4&#x27;d2</span>:<span class="hljs-keyword">begin</span><br>            result = srca &amp; srcb;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4&#x27;d3</span>:<span class="hljs-keyword">begin</span><br>            result = srca | srcb;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4&#x27;d4</span>:<span class="hljs-keyword">begin</span><br>            result = srca ^ srcb;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4&#x27;d5</span>:<span class="hljs-keyword">begin</span><br>            result = srca &gt; srcb;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p>流水线寄存器（P5）</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> pipeline_sample(<br>   <span class="hljs-keyword">input</span> clk,<br>   <span class="hljs-keyword">input</span> reset,<br>   <span class="hljs-keyword">input</span> stall,<br>   <span class="hljs-keyword">input</span> flush,<br>   <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] aluResultAtExe,<br>   <span class="hljs-comment">// 可能还有其他来自前一级的输入</span><br>   <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] aluResultAtMemory<br>   <span class="hljs-comment">// 可能还有要输出到后一级的</span><br>   <span class="hljs-comment">// 输入输出应配对</span><br>   );<br>   <span class="hljs-comment">// 根据端口定义，可能还要开其他的临时寄存器</span><br>   <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] aluResult;<br>   <span class="hljs-comment">// 根据临时寄存器的值，可能还要连其他的线</span><br>   <span class="hljs-keyword">assign</span> aluResultAtMemory = aluResult;<br><br>   <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)<br>   <span class="hljs-comment">// 可能还要处理其他的临时寄存器</span><br>   <span class="hljs-keyword">begin</span><br>       <span class="hljs-comment">// 复位 或者 清除流水线寄存器（阻塞，异常中断处理会用到）</span><br>       <span class="hljs-keyword">if</span>(reset | flush)<br>       <span class="hljs-keyword">begin</span><br>           aluResult &lt;= <span class="hljs-number">32&#x27;d0</span>;<br>       <span class="hljs-keyword">end</span><br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>           <span class="hljs-comment">// 判定是否应阻塞该级，不阻塞时才更新为前一级的值</span><br>           <span class="hljs-keyword">if</span>(!stall)<br>           <span class="hljs-keyword">begin</span><br>               aluResult &lt;= aluResultAtExe;<br>           <span class="hljs-keyword">end</span><br>       <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="Verilog-代码规范"><a href="#Verilog-代码规范" class="headerlink" title="Verilog 代码规范"></a>Verilog 代码规范</h3><p>本文档是推荐的 Verilog 编程规范，遵守本规范可以减少你代码中出现的问题，避免在“莫名其妙”的问题上浪费时间。</p><h4 id="VC-001-信号名称采用-snake-case"><a href="#VC-001-信号名称采用-snake-case" class="headerlink" title="VC-001 信号名称采用 snake_case"></a>VC-001 信号名称采用 <code>snake_case</code></h4><p>信号名称通常采用 <code>snake_case</code>，即变量名全小写，单词之间用下划线分隔。</p><h4 id="VC-002-信号极性为低有效用-n-后缀表示"><a href="#VC-002-信号极性为低有效用-n-后缀表示" class="headerlink" title="VC-002 信号极性为低有效用 _n 后缀表示"></a>VC-002 信号极性为低有效用 <code>_n</code> 后缀表示</h4><p>对于复位和使能信号，例如 <code>rst</code> 和 <code>we</code>，如果添加了 <code>_n</code> 后缀，表示值为零时生效（低有效，Active Low），值为一时不生效；如果没有添加 <code>_n</code> 后缀，表示值为一时生效（高有效，Active High），值为零时不生效。详细解释见下面的表格：</p><div class="table-container"><table><thead><tr><th style="text-align:left">信号名称</th><th style="text-align:left">极性</th><th style="text-align:left">1’b1</th><th style="text-align:left">1’b0</th></tr></thead><tbody><tr><td style="text-align:left">rst</td><td style="text-align:left">高有效</td><td style="text-align:left">复位</td><td style="text-align:left">不复位</td></tr><tr><td style="text-align:left">rst_n</td><td style="text-align:left">低有效</td><td style="text-align:left">不复位</td><td style="text-align:left">复位</td></tr><tr><td style="text-align:left">we</td><td style="text-align:left">高有效</td><td style="text-align:left">写入</td><td style="text-align:left">不写入</td></tr><tr><td style="text-align:left">we_n</td><td style="text-align:left">低有效</td><td style="text-align:left">不写入</td><td style="text-align:left">写入</td></tr></tbody></table></div><p>当代码中需要混合使用 <code>rst</code> 和 <code>rst_n</code> 的时候，采用以下的方式来转换：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> test(<br>  <span class="hljs-keyword">input</span> rst_n<br>);<br>  <span class="hljs-keyword">wire</span> rst;<br><br>  <span class="hljs-comment">// GOOD</span><br>  <span class="hljs-keyword">assign</span> rst = ~rst_n;<br><br>  <span class="hljs-comment">// GOOD</span><br>  <span class="hljs-comment">// Verilog</span><br>  <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>    rst = ~rst_n;<br>  <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="VC-003-信号仅在一个-always-块中赋值"><a href="#VC-003-信号仅在一个-always-块中赋值" class="headerlink" title="VC-003 信号仅在一个 always 块中赋值"></a>VC-003 信号仅在一个 <code>always</code> 块中赋值</h4><p>通常情况下，一个信号只会在一个 <code>always</code> 块中赋值。</p><h4 id="VC-004-组合逻辑采用-always-块或者-assign-编写"><a href="#VC-004-组合逻辑采用-always-块或者-assign-编写" class="headerlink" title="VC-004 组合逻辑采用 always @(*) 块或者 assign 编写"></a>VC-004 组合逻辑采用 <code>always @(*)</code> 块或者 <code>assign</code> 编写</h4><p>组合逻辑的 <code>always</code> 块，使用以下的写法：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Verilog</span><br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>  c = a + b;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">// GOOD</span><br><span class="hljs-keyword">assign</span> c = a + b;<br></code></pre></td></tr></table></figure><h4 id="VC-005-组合逻辑-always-块中仅使用阻塞赋值"><a href="#VC-005-组合逻辑-always-块中仅使用阻塞赋值" class="headerlink" title="VC-005 组合逻辑 always 块中仅使用阻塞赋值"></a>VC-005 组合逻辑 <code>always</code> 块中仅使用阻塞赋值</h4><p>表示组合逻辑的 <code>always</code> 块中所有的赋值请使用阻塞赋值（<code>=</code>）。</p><h4 id="VC-006-组合逻辑-always-块中保证每个分支都进行赋值"><a href="#VC-006-组合逻辑-always-块中保证每个分支都进行赋值" class="headerlink" title="VC-006 组合逻辑 always 块中保证每个分支都进行赋值"></a>VC-006 组合逻辑 <code>always</code> 块中保证每个分支都进行赋值</h4><p>如果使用了条件语句 <code>if</code>，需要保证信号在每个可能的分支途径下都进行了赋值。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// GOOD</span><br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span> (reset_n) <span class="hljs-keyword">begin</span><br>    c = a + b;<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>    c = <span class="hljs-number">1&#x27;b0</span>;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">// BAD</span><br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span> (reset_n) <span class="hljs-keyword">begin</span><br>    c = a + b;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>请不要列举敏感信号：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// BAD</span><br><span class="hljs-keyword">always</span> @ (b, c) <span class="hljs-keyword">begin</span><br>  a = b + c;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="VC-007-时序逻辑在-always-posedge-clock-中实现"><a href="#VC-007-时序逻辑在-always-posedge-clock-中实现" class="headerlink" title="VC-007 时序逻辑在 always @(posedge clock) 中实现"></a>VC-007 时序逻辑在 <code>always @(posedge clock)</code> 中实现</h4><p>当需要表示时序逻辑时，使用以下的写法：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Verilog</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clock) <span class="hljs-keyword">begin</span><br>  c &lt;= a + b;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="VC-008-时序逻辑-always-块中仅使用非阻塞赋值"><a href="#VC-008-时序逻辑-always-块中仅使用非阻塞赋值" class="headerlink" title="VC-008 时序逻辑 always 块中仅使用非阻塞赋值"></a>VC-008 时序逻辑 <code>always</code> 块中仅使用非阻塞赋值</h4><p>时序逻辑 <code>always</code> 块中，所有的赋值请使用非阻塞赋值（<code>&lt;=</code>）。</p><h4 id="VC-009-不要使用下降沿触发，特殊协议除外"><a href="#VC-009-不要使用下降沿触发，特殊协议除外" class="headerlink" title="VC-009 不要使用下降沿触发，特殊协议除外"></a>VC-009 不要使用下降沿触发，特殊协议除外</h4><p>通常情况下，请不要使用下降沿触发：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// BAD: do not use negedge</span><br><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">negedge</span> clock) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="VC-010-不要使用非时钟-复位信号的边沿触发"><a href="#VC-010-不要使用非时钟-复位信号的边沿触发" class="headerlink" title="VC-010 不要使用非时钟 / 复位信号的边沿触发"></a>VC-010 不要使用非时钟 / 复位信号的边沿触发</h4><p>通常情况下，不要使用除了时钟和复位以外的信号做边沿触发。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// BAD: do not use non-clock/reset signals</span><br><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> signal) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="VC-011-时序逻辑中不要使用时钟信号"><a href="#VC-011-时序逻辑中不要使用时钟信号" class="headerlink" title="VC-011 时序逻辑中不要使用时钟信号"></a>VC-011 时序逻辑中不要使用时钟信号</h4><p>在时序逻辑中，请不要在敏感列表以外的地方使用时钟信号：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// BAD</span><br><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clock) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span> (clock) <span class="hljs-keyword">begin</span><br>    a &lt;= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="VC-012-使用同步复位，而不是异步复位"><a href="#VC-012-使用同步复位，而不是异步复位" class="headerlink" title="VC-012 使用同步复位，而不是异步复位"></a>VC-012 使用同步复位，而不是异步复位</h4><p>对于 FPGA，请使用同步复位：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Verilog</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clock) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>    c &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>    c &lt;= a + b;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="VC-013-不要在内部模块中使用-inout"><a href="#VC-013-不要在内部模块中使用-inout" class="headerlink" title="VC-013 不要在内部模块中使用 inout"></a>VC-013 不要在内部模块中使用 <code>inout</code></h4><p>FPGA 内部的模块之间请不要使用 <code>inout</code>，仿真环境除外。</p><h4 id="VC-014-用-localparam-命名状态机的各个状态"><a href="#VC-014-用-localparam-命名状态机的各个状态" class="headerlink" title="VC-014 用 localparam 命名状态机的各个状态"></a>VC-014 用 localparam 命名状态机的各个状态</h4><p>编写状态机的时候，用 <code>localparam</code> 命名各个状态：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// GOOD</span><br><span class="hljs-keyword">localparam</span> sInit = <span class="hljs-number">2&#x27;d0</span>;<br><span class="hljs-keyword">localparam</span> sIdle = <span class="hljs-number">2&#x27;d1</span>;<br><span class="hljs-keyword">localparam</span> sWork = <span class="hljs-number">2&#x27;d2</span>;<br><span class="hljs-keyword">localparam</span> sDone = <span class="hljs-number">2&#x27;d3</span>;<br><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] state;<br></code></pre></td></tr></table></figure><p>如果仿真工具不支持在波形中显示为对应的状态名称，可以采用以下的方法：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">ifndef</span> SYNTHESIS</span><br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">39</span>:<span class="hljs-number">0</span>] state_string; <span class="hljs-comment">// 40 bits = 5 byte</span><br><br>  <span class="hljs-keyword">always</span> @ (*) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(state)<br>      sInit: state_string = <span class="hljs-string">&quot;sInit&quot;</span>;<br>      sIdle: state_string = <span class="hljs-string">&quot;sIdle&quot;</span>;<br>      sWork: state_string = <span class="hljs-string">&quot;sWork&quot;</span>;<br>      sDone: state_string = <span class="hljs-string">&quot;sDone&quot;</span>;<br>      <span class="hljs-keyword">default</span>: state_string = <span class="hljs-string">&quot;?????&quot;</span>;<br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>此时在仿真波形中，<code>state_string</code> 信号就可以看到状态的名称了。</p><h3 id="其他可参考的-Verilog-编程规范"><a href="#其他可参考的-Verilog-编程规范" class="headerlink" title="其他可参考的 Verilog 编程规范"></a>其他可参考的 Verilog 编程规范</h3><ul><li>本规范修改自 <a href="https://github.com/thu-cs-lab/verilog-coding-standard">thu-cs-lab/verilog-coding-standard</a></li><li><a href="http://fpgacpu.ca/fpga/verilog.html">Verilog Coding Standard</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md">lowRISC Verilog Coding Style</a></li></ul><h2 id="P1课下题面"><a href="#P1课下题面" class="headerlink" title="P1课下题面"></a>P1课下题面</h2><h3 id="P1-L0-splitter-Verilog部件设计-P1-Q1"><a href="#P1-L0-splitter-Verilog部件设计-P1-Q1" class="headerlink" title="P1_L0_splitter-Verilog部件设计(P1.Q1)"></a>P1_L0_splitter-Verilog部件设计(P1.Q1)</h3><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在这个部分中，我们的目标是完成Splitter、ALU和EXT的搭建。相信经过之前的学习，大家对这三个组合逻辑部件已经有了一定的了解。在组合逻辑电路中，这是相当简单的例子。我们也希望大家能够从这些简单的例子中，复习使用 Verilog 进行电路设计的一般流程，并且学会如何测试自己所搭建电路的正确性。在本门课程中，Debug 和测试将会是非常重要的技能，希望大家能在课下努力锻炼这种能力。</p><h3 id="1、Verilog-实现-Splitter"><a href="#1、Verilog-实现-Splitter" class="headerlink" title="1、Verilog 实现 Splitter"></a>1、Verilog 实现 Splitter</h3><p>使用 Verilog 搭建一个32位 Splitter , 给定一个32位的二进制数作为输入，将其划分为四个8位的二进制数作为输出。</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.1.1.png" class="" title="p1.0.1.1.png"><h3 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h3><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名: splitter</li></ul><h3 id="P1-L0-ALU-Verilog部件设计-P1-Q2"><a href="#P1-L0-ALU-Verilog部件设计-P1-Q2" class="headerlink" title="P1_L0_ALU-Verilog部件设计(P1.Q2)"></a>P1_L0_ALU-Verilog部件设计(P1.Q2)</h3><h3 id="2、Verilog-实现-ALU"><a href="#2、Verilog-实现-ALU" class="headerlink" title="2、Verilog 实现 ALU"></a>2、Verilog 实现 ALU</h3><p>使用 Verilog 搭建一个 32 位六运算 ALU 并提交。具体模块端口定义如下：</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.2.1.png" class="" title="p1.0.2.1.png"><p>模块功能定义如下：</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.2.2.png" class="" title="p1.0.2.2.png"><h3 id="知识复习："><a href="#知识复习：" class="headerlink" title="知识复习："></a>知识复习：</h3><p>在这里我们需要复习逻辑右移和算术右移的区别：</p><p>逻辑右移不考虑符号位，右移一位，左边补零即可。</p><p>算术右移需要考虑符号位，右移一位，若符号位为 1 ，在左边补 1 ；否则，补 0 。</p><p>例如，8 位二进制数 10111101 分别右移2位。</p><ul><li>逻辑右移结果为<strong>00</strong>101111</li><li>算术右移结果为<strong>11</strong>101111</li></ul><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><p>在进行有符号数的相关操作时，应注意 <strong>$signed()</strong> 的使用。若有必要，请参照Verilog教程的语法部分中的相关介绍进行复习。</p><h3 id="要求：-1"><a href="#要求：-1" class="headerlink" title="要求："></a>要求：</h3><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名: alu</li></ul><h3 id="P1-L0-EXT-Verilog部件设计-P1-Q3"><a href="#P1-L0-EXT-Verilog部件设计-P1-Q3" class="headerlink" title="P1_L0_EXT-Verilog部件设计(P1.Q3)"></a>P1_L0_EXT-Verilog部件设计(P1.Q3)</h3><h3 id="3、Verilog-实现-EXT"><a href="#3、Verilog-实现-EXT" class="headerlink" title="3、Verilog 实现 EXT"></a>3、Verilog 实现 EXT</h3><p>EXT为扩展单元，其主要功能是完成将输入到其中的16位数据进行符号扩展、零扩展以及将输入的16位数加载到高位等操作。具体模块端口定义如下：</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.3.1.png" class="" title="p1.0.3.1.png"><p>模块功能定义如下：</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.3.2.png" class="" title="p1.0.3.2.png"><h3 id="要求：-2"><a href="#要求：-2" class="headerlink" title="要求："></a>要求：</h3><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名: ext</li></ul><h3 id="P1-L0-gray-Verilog时序逻辑-P1-Q4"><a href="#P1-L0-gray-Verilog时序逻辑-P1-Q4" class="headerlink" title="P1_L0_gray-Verilog时序逻辑(P1.Q4)"></a>P1_L0_gray-Verilog时序逻辑(P1.Q4)</h3><h3 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h3><h3 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h3><p>在完成了 Verilog 组合逻辑部件设计的三道编程题之后，相信大家对于使用 Verilog 进行设计的一般流程和方法已经再次熟悉。现在，我们将进行下一步的挑战——设计包含<strong>时序逻辑</strong>的 Verilog 部件，这也将是我们从组合逻辑部件到之后的<strong>有限状态机</strong>的重要过渡。 在 Verilog 的教程部分，我们曾设计了一个简易的计数器。而我们现在的任务就是设计一个加强版的计数器——格雷码计数器。 如果你对格雷码的定义和优点等知识有所遗忘，这个链接可以帮到你： <a href="https://en.wikipedia.org/wiki/Gray_code">格雷码-wikipedia</a></p><h3 id="2、模块规格"><a href="#2、模块规格" class="headerlink" title="2、模块规格"></a>2、模块规格</h3><p>我们的格雷码计数器端口定义如下：</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.4.1.png" class="" title="p1.0.4.1.png"><p>我们要实现的功能如下：</p><h4 id="1、-在任意一个时钟上升沿到来的时候，如果复位信号有效，则将计数器清零；"><a href="#1、-在任意一个时钟上升沿到来的时候，如果复位信号有效，则将计数器清零；" class="headerlink" title="1、 在任意一个时钟上升沿到来的时候，如果复位信号有效，则将计数器清零；"></a>1、 在任意一个时钟上升沿到来的时候，如果复位信号有效，则将计数器清零；</h4><h4 id="2、-每个时钟上升沿到来的时候，如果使能信号有效，计数器的值-1；"><a href="#2、-每个时钟上升沿到来的时候，如果使能信号有效，计数器的值-1；" class="headerlink" title="2、 每个时钟上升沿到来的时候，如果使能信号有效，计数器的值+1；"></a>2、 每个时钟上升沿到来的时候，如果使能信号有效，计数器的值+1；</h4><h4 id="3、-在满足1时，即使2的条件满足，也不必执行2；"><a href="#3、-在满足1时，即使2的条件满足，也不必执行2；" class="headerlink" title="3、 在满足1时，即使2的条件满足，也不必执行2；"></a>3、 在满足1时，即使2的条件满足，也不必执行2；</h4><h4 id="4、-计数器初值为0；"><a href="#4、-计数器初值为0；" class="headerlink" title="4、 计数器初值为0；"></a>4、 计数器初值为0；</h4><h4 id="5、-当计数器的值在-1后出现溢出的情况时，将会回到零，同时从发生溢出的这个时钟上升沿开始，溢出标志位将会持续输出1，直到计数器被清零为止（其余情况下溢出标志位必须为0）。"><a href="#5、-当计数器的值在-1后出现溢出的情况时，将会回到零，同时从发生溢出的这个时钟上升沿开始，溢出标志位将会持续输出1，直到计数器被清零为止（其余情况下溢出标志位必须为0）。" class="headerlink" title="5、 当计数器的值在+1后出现溢出的情况时，将会回到零，同时从发生溢出的这个时钟上升沿开始，溢出标志位将会持续输出1，直到计数器被清零为止（其余情况下溢出标志位必须为0）。"></a>5、 当计数器的值在+1后出现溢出的情况时，将会回到零，同时从发生溢出的这个时钟上升沿开始，溢出标志位将会持续输出1，直到计数器被清零为止（其余情况下溢出标志位必须为0）。</h4><p>示范波形：</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.4.2.png" class="" title="p1.0.4.2.png"><p>为了方便大家设计，这里附上3位格雷码的计数方式：</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.4.3.png" class="" title="p1.0.4.3.png"><h3 id="3、要求"><a href="#3、要求" class="headerlink" title="3、要求"></a>3、要求</h3><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名: gray</li></ul><h3 id="P1L0表达式状态机-Verilog表达式状态机-P1-Q5"><a href="#P1L0表达式状态机-Verilog表达式状态机-P1-Q5" class="headerlink" title="P1L0表达式状态机-Verilog表达式状态机(P1.Q5)"></a>P1<em>L0</em>表达式状态机-Verilog表达式状态机(P1.Q5)</h3><h3 id="提交要求-1"><a href="#提交要求-1" class="headerlink" title="提交要求"></a>提交要求</h3><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>计算机经常用于处理关于表达式的问题。现在有这样一类表达式F的字符串需要你来验证它们的合法性：</p><p>1、表达式F中只含有数字0-9，加号+，乘号*。</p><p>2、表达式F可以按如下的规则产生：</p><p>a. 单个数字[0-9]是F； b. 如果<strong>X</strong>是F，<strong>Y</strong>是F，<strong>X+Y</strong>也是F； c. 如果<strong>X</strong>是F，<strong>Y</strong>是F，<strong>X*Y</strong>也是F。</p><p>排除显而易见的所用符号不合法，所有的非法情况总结如下：</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.6.1.png" class="" title="p1.0.6.1.png"><p>现在，我们需要你用Verilog HDL语言设计一个有限状态机来识别这样的表达式。</p><h3 id="2、模块规格-1"><a href="#2、模块规格-1" class="headerlink" title="2、模块规格"></a>2、模块规格</h3><p>模块名：<strong>expr</strong></p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.5.1.png" class="" title="p1.0.5.1.png"><h3 id="3、功能要求"><a href="#3、功能要求" class="headerlink" title="3、功能要求"></a>3、功能要求</h3><p>每个时钟上升沿，状态机从 in 中读入一个ASCII编码的字符。假设读入的第i个字符为ci，则第n个时钟上升沿时，可以拼出一个字符串:</p><p>s=c1c2….cn</p><p>我们需要你此时判断 s 是否符合表达式F的定义。假如s符合F的定义，那么 out 应输出1，否则输出0。</p><p>另外，每个 clr 上升沿时，请清零状态；如果 clk 的上升沿时 clr 为 1，也需要清零状态。清零后，上面定义的字符串s也应从空串开始计算。如果s当前是空串，out也应输出0。注意，我们不需要你分析表达式的语法和语义，只要判断形式上合法性就可以正确求解。</p><h3 id="4、输入输出样例"><a href="#4、输入输出样例" class="headerlink" title="4、输入输出样例"></a>4、输入输出样例</h3><p>时序规范：总是保证in信号稳定时clk才产生上升沿。</p><p>输入：s = <strong>1+2+3+4</strong> 输出：out = 1</p><p>输入：s = <strong>1+2+3+</strong> 输出：out = 0</p><p>示范波形（输入：s=<strong>1+2*3</strong>, 清零一周期, s’=<strong>1+2*3</strong>。时钟周期10ns）：</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.4.3__1_.png" class="" title="p1.0.4.3 1.png"><h3 id="5、提交要求"><a href="#5、提交要求" class="headerlink" title="5、提交要求"></a>5、提交要求</h3><ul><li>必须严格按照模块的端口定义。</li><li>文件内模块名: <strong>expr</strong></li><li>注意由于 <code>string</code> 是 SystemVerilog 的保留字，本题模块名改为 <strong>expr</strong>。</li></ul><h3 id="P1-L1-BlockChecker-语句块检查模拟-附加题"><a href="#P1-L1-BlockChecker-语句块检查模拟-附加题" class="headerlink" title="P1_L1_BlockChecker-语句块检查模拟(附加题)"></a>P1_L1_BlockChecker-语句块检查模拟(附加题)</h3><p>本题为附加题，通过与否不计入P1课下通过条件。</p><p>现在需要你用Verilog语言编写一个模拟语句块检查的工具。</p><p>为了简化要求，<strong>输入由ASCII字母和空格组成</strong>。一个或多个连续出现的字母构成一个单词，单词<strong>不区分大小写</strong>，单词之间由一个或多个空格分隔开。检查工具检查<strong>自复位之后的输入中</strong>，begin和end是否能够匹配。</p><p>匹配规则类似括号匹配：一个begin只能匹配一个end，但是一个匹配的begin必须出现在对应的end之前；允许出现嵌套；最后若出现不能按上述规则匹配的begin或end，则匹配失败。</p><p>输入的读取在<strong>时钟上升沿</strong>进行。</p><p>匹配示例：Hello world，begin comPuTer orGANization End。</p><p>不匹配示例：eND，beGin study。</p><p><strong>建议大家认真查看示例波形。</strong></p><p>模块端口定义如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">信号名</th><th style="text-align:left">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">clk</td><td style="text-align:left">I</td><td style="text-align:left">时钟信号</td></tr><tr><td style="text-align:left">reset</td><td style="text-align:left">I</td><td style="text-align:left">异步复位信号（高电平有效，复位时将输入记录清空）</td></tr><tr><td style="text-align:left">in[7:0]</td><td style="text-align:left">I</td><td style="text-align:left">当前输入字符的ASCII码</td></tr><tr><td style="text-align:left">result</td><td style="text-align:left">O</td><td style="text-align:left">当前输入是否能够完成begin和end的匹配</td></tr></tbody></table></div><h3 id="提交要求-2"><a href="#提交要求-2" class="headerlink" title="提交要求"></a>提交要求</h3><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名：BlockChecker</li><li><strong>模块内不要包含任何$display语句</strong> ，以防造成误判</li><li>我们保证在使用模块前进行复位</li><li><strong>保证输入的单词数和单词长度均小于2^32</strong></li></ul><h3 id="示例波形"><a href="#示例波形" class="headerlink" title="示例波形"></a>示例波形</h3><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/example_blockchecker.png" class="" title="example_blockchecker.png"><h2 id="思路与题解"><a href="#思路与题解" class="headerlink" title="思路与题解"></a>思路与题解</h2><p>好了那么进入正题，我们依次看每道题目。可以说前三题都是白送，只需要你会一点Verilog的语法即可。时序逻辑两道题稍有新意，BlockChecker相当有难度。</p><h3 id="T1-splitter"><a href="#T1-splitter" class="headerlink" title="T1-splitter"></a>T1-splitter</h3><p>四行代码搞定，依次<code>assign</code>为输入中对应的八位即可，不多解释。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> splitter(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] A,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] O1,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] O2,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] O3,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] O4<br>    );<br><span class="hljs-keyword">assign</span> O1=A[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>];<br><span class="hljs-keyword">assign</span> O2=A[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>];<br><span class="hljs-keyword">assign</span> O3=A[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>];<br><span class="hljs-keyword">assign</span> O4=A[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>如果你是初学者<del>（虽然不应该，pre都学过语法了）</del>，注意一下是从大往小写<code>[7:0]</code>而非<code>[0:7]</code>就行。</p><h3 id="T2-ALU"><a href="#T2-ALU" class="headerlink" title="T2-ALU"></a>T2-ALU</h3><p>没错，这个模块将会在将来的P4中遇到，还是很重要的。只要学会使用<code>switch-case</code>语句就行了（当然你就<code>if-else if</code>也不是不行），仍然是组合逻辑，可以选择<code>assign</code>和三目运算符直接解决，或者<code>always @(*)</code>里面使用条件语句。因为情况较多，而且后者好加语句和后续维护，我倾向于使用后者。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">case</span> (ALUOp)<br><span class="hljs-number">3&#x27;b000</span>:<br>C=A+B;<br><span class="hljs-number">3&#x27;b001</span>:<br>C=A-B;<br><span class="hljs-number">3&#x27;b010</span>:<br>C=A&amp;B;<br><span class="hljs-number">3&#x27;b011</span>:<br>C=A|B;<br><span class="hljs-number">3&#x27;b100</span>:<br>C=A&gt;&gt;B;<br><span class="hljs-number">3&#x27;b101</span>:<br>C=<span class="hljs-built_in">$signed</span>(A)&gt;&gt;&gt;(&#123;<span class="hljs-number">1&#x27;b0</span>,B[<span class="hljs-number">30</span>:<span class="hljs-number">0</span>]&#125;);<br><span class="hljs-keyword">default</span> C=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>1.这里算数右移需要考虑符号，使用<code>$signed(A)</code>将其转换为有符号形式。其实这里比较意义不明，因为字节是$32$位的，两个右移最多$5$位有效，否则相当于在循环移。在搭建单周期$CPU$时这里会有改动。</p><p>2.建议所有条件语句都加上<code>default</code>或者<code>else</code>，以免产生锁存器，增强鲁棒性。</p><h3 id="T3-EXT"><a href="#T3-EXT" class="headerlink" title="T3-EXT"></a>T3-EXT</h3><p>这题很简单，就是一个条件语句+信号位拼接的题，但我甚至卡在了编译那块，不知道为什么报语法错误。实际上还是我对拼接的语法理解模糊，少套了一层大括号。变量信号<code>x[y:z]</code>是不用加一层大括号的，但是若干个常数和信号就要了，比如<code>&#123;16&#123;1&#39;b0&#125;&#125;</code>，会显得大括号很多。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> ext(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] imm,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] EOp,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ext<br>    );<br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">case</span> (EOp)<br><span class="hljs-number">2&#x27;b00</span>:<br>ext=&#123;&#123;<span class="hljs-number">16</span>&#123;imm[<span class="hljs-number">15</span>]&#125;&#125;,imm&#125;;<br><span class="hljs-number">2&#x27;b01</span>:<br>ext=&#123;&#123;<span class="hljs-number">16</span>&#123;<span class="hljs-number">1&#x27;b0</span>&#125;&#125;,imm&#125;;<br><span class="hljs-number">2&#x27;b10</span>:<br>ext=&#123;imm,&#123;<span class="hljs-number">16</span>&#123;<span class="hljs-number">1&#x27;b0</span>&#125;&#125;&#125;;<br><span class="hljs-number">2&#x27;b11</span>:<br>ext=&#123;&#123;<span class="hljs-number">14</span>&#123;imm[<span class="hljs-number">15</span>]&#125;&#125;,imm,<span class="hljs-number">2&#x27;b00</span>&#125;;<br><span class="hljs-keyword">default</span>: ext=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="T4-gray"><a href="#T4-gray" class="headerlink" title="T4-gray"></a>T4-gray</h3><p>其实只是计时器，把数字$0-7$重新”编码“了一下而已。最开始写着写着忘了这事。后来我在想怎么把格雷码和$cnt$一一对应上呢？我便去百度了一下，查到：</p><script type="math/tex; mode=display">G_i=B_i ~\oplus ~ B_{i+1}~~ (0\leq i\leq n-1)</script><p>$G_i$为格雷码的每一位，$B_i$是二进制码的每一位，约定$B_n=0$。这样我们很快就能做出来。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> gray(<br>    <span class="hljs-keyword">input</span> Clk,<br>    <span class="hljs-keyword">input</span> Reset,<br>    <span class="hljs-keyword">input</span> En,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] Output,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> Overflow<br>    );<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] cnt;<br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> Clk) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(Reset) <span class="hljs-keyword">begin</span><br>Overflow&lt;=<span class="hljs-number">0</span>;<br>cnt&lt;=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">3&#x27;b111</span> &amp;&amp; En==<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>cnt&lt;=<span class="hljs-number">0</span>;<br>Overflow&lt;=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>cnt&lt;=cnt+En;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">assign</span> Output=&#123;cnt[<span class="hljs-number">2</span>],&#123;cnt[<span class="hljs-number">2</span>]^cnt[<span class="hljs-number">1</span>]&#125;,&#123;cnt[<span class="hljs-number">0</span>]^cnt[<span class="hljs-number">1</span>]&#125;&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="T5-expr"><a href="#T5-expr" class="headerlink" title="T5- expr"></a>T5- expr</h3><p>一个状态转移图略显奇怪的有限状态机，实际上只需要三个状态就行了。初始$S_0$，符号结尾$S_1$，数字结尾（合法序列）$S_2$，已经非法了的状态$S_3$。</p><img src="/posts/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/FSM.jpg" class="" title="FSM"><p>或者从另一种角度来看，$S_1$是暂时非法的状态，$S_2$是暂时合法，$S_3$是永久非法，除非$reset$否则无法跳出。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> expr(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> clr,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> out<br>    );<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] status;<br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> clr) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(clr) <span class="hljs-keyword">begin</span><br>status&lt;=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">case</span> (status)<br><span class="hljs-number">0</span>:<br><span class="hljs-keyword">if</span>(in==<span class="hljs-number">8&#x27;d42</span> || in==<span class="hljs-number">8&#x27;d43</span>) status&lt;=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span> status&lt;=<span class="hljs-number">2</span>;<br><span class="hljs-number">1</span>:<br><span class="hljs-keyword">if</span>(in==<span class="hljs-number">8&#x27;d42</span> || in==<span class="hljs-number">8&#x27;d43</span>) status&lt;=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span> status&lt;=<span class="hljs-number">2</span>;<br><span class="hljs-number">2</span>:<br><span class="hljs-keyword">if</span>(in==<span class="hljs-number">8&#x27;d42</span> || in==<span class="hljs-number">8&#x27;d43</span>) status&lt;=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> status&lt;=<span class="hljs-number">3</span>;<br><span class="hljs-number">3</span>:<br>status&lt;=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">default</span>: status&lt;=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">assign</span> out=(status==<span class="hljs-number">2</span>)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>字符可以用双引号引起来使用，免得像我这里一样查<code>ascii</code>表。</li><li>可以看出其实是$Moore$型有限状态机，虽然题目没有明说，做的时候我也没有考虑这些。</li></ol>]]></content>
    
    
    <categories>
      
      <category>CO课下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>CO课下</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pre上机-总结反思与问题汇总</title>
    <link href="/posts/Pre%E4%B8%8A%E6%9C%BA-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E4%B8%8E%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/posts/Pre%E4%B8%8A%E6%9C%BA-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E4%B8%8E%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Pre-总结反思与问题汇总"><a href="#Pre-总结反思与问题汇总" class="headerlink" title="Pre-总结反思与问题汇总"></a>Pre-总结反思与问题汇总</h1><h3 id="T1-推箱子-Logisim"><a href="#T1-推箱子-Logisim" class="headerlink" title="T1.推箱子-Logisim"></a>T1.推箱子-Logisim</h3><p>出现了严重的失误，花了两个多小时导致道心破碎，甚至一度想“大不了爆零吧”。主要需要反思以下几点：</p><ol><li>平常“真值表生成状态机”的轮椅题做的太多了，往往没有过多的输入输出设计，导致看到题目第一眼是懵的，甚至还在想怎么设计状态转移图和真值表，“难道要三十个状态吗”，对较新颖的题型不熟练导致没有做题的底气，对于$flag$保持一周的创新点也处理的略微慌张；</li><li>对<strong>早晚一拍概念不清晰</strong>，是拿$x$比较还是拿$xnext$比较，到考试结束前五分钟甚至都没有意识到这个问题；</li><li>看到$flag$要保持一拍，确实很快想到了要用<strong>寄存器</strong>，但心里不踏实的感觉，有点不敢实践，总想“先不管交一交看一看”，后面用寄存器还是没过，我就以为自己想法错了，开始一阵瞎改，把状态机模块的$flag$直接废除不用了，丝毫没有意识到是$out$的问题；</li><li>不会<strong>自动化测试</strong>，手动点在考场紧张的环境下，有时候输出错了也没发现，精神高度紧张可能忽略掉一些东西，有空可以学一学有没有更好的测试方式；</li><li>值得夸奖的是我的状态转移模块一般就写对了，没有更多的更改，而且我做的很从容淡定有自信，可能是考试刚开始还很冷静。</li></ol><p>本题的解题思路:</p><p>先设计状态转移模块$fsm$，用$tunnel$表示$x$,$x+dx$,$y$,$y+dy$，判断$x+dx$是否$&gt;5$，$y+dy$是否$&gt;5$，以及$x$，$y$是否同时等于那六个障碍物的$x$，$y$坐标，将这些或起来，便是我们想要的<strong>实时的下一拍的</strong>$flag$。当然，作为组合逻辑，我们本就只能输出实时的，”保持一拍”得在主电路里实现。注意：$dx$，$dy$要进行<strong>零扩展</strong>变成三位，比较器一定要选$Unsigned$。</p><p>然后设计主电路，首先两个$3$位寄存器分别存$x$，$y$当下的值，与$dx$，$dy$一同传入$fsm$模块，得到的$flag$在寄存器中<strong>缓一拍</strong>输出，既实现了将$fsm$模块中对$x+dx$，$y+dy$判断导致的“早一拍”问题，又实现了无$reset$信号时保持一拍，有$reset$立马清零的效果。至于$out$就更简单了，使用比较器判断当前$x$，$y$（可以从寄存器$Q$端引出隧道）是否都为0即可，组合逻辑。</p><h3 id="T2-Roll-Verilog"><a href="#T2-Roll-Verilog" class="headerlink" title="T2.Roll-Verilog"></a>T2.Roll-Verilog</h3><p>暴露了我Verilog已经几近与忘光了的事实。太久没写，没地方可以评测，没有什么有创新点的题目，对一些稍微进阶的语言技巧都记不太清不敢用。总结一下当中遇到的各种问题：</p><ol><li>$for$循环怎么写都不会了？是在什么模块里面能写？晚些时候一定要查证一下，在我印象中是$tb$文件的$initial$用的多，要提交的文件应该是尽量不要用$initial$，不能综合还是什么？时序逻辑里不能$for$吗？组合逻辑可以？这次只有$assign$我用着放心，得亏是简单的组合逻辑；（查证：<strong>组合逻辑</strong>和<strong>时序逻辑</strong>都可使用可综合的$for$循环，用在$always$块里即可）</li><li>$wire$的拼接，用大括号，<strong>从高位到低位</strong>，考场上甚至不确定；</li><li><strong>数组的定义方式</strong>！不是像$C$语言一样$a[8]$，应该是$a[7:0]$这种？晚点查证一下；（查证后回答：应是$a[0:7]$）</li><li>最初居然定义$reg$类型，明显这里都用$wire$就好，顶多循环变量用$reg$，说明基本概念还没有炉火纯青，虽然看到报错能立马意识到；</li><li>$testbench$中要不要用$initial$，感觉这还是我第一次直接$assign$，两行就写完了。看向巨的反应我应该写的不对。不确定是不是最好的写法。而且实例化的写法有点忘了，结合报错试探了好几下；（查证：实现一次测试完给的两个测试点，要用$initial$，还是用$initial$比较好，组合逻辑的$testbench$<strong>无需$clk$</strong>，但是也要延迟10s）</li><li>对于一部分报错信息看不懂，看到反倒懵了，还是得多练。</li></ol><p>本题解题思路：</p><p>这题很简单，哪怕设$8+8$个变量然后各种复制粘贴$assign$也是能过的。但是本题的目的是让你学如何使用$for$循环，以及”-：”的使用。那么首先这是一道组合逻辑，由输入和逻辑运算直接得到输出，具体操作都给你了，按操作翻译一遍就行，当然我们在写循环的过程中，难免遇到一些问题：</p><p><strong>循环变量</strong>用什么？在<code>always</code>外面设<code>integer</code></p><ol><li>$for$放在哪？放在<code>always @(*)</code>里面</li><li>数组是怎么定义的？<code>wire [3:0] a[0:7]</code></li><li>注意$i++$会报错，Verilog没有这种语法，要用$i=i+1$</li><li>如果直接<code>arr[i]=a[(i + 1) * 4 - 1-:i*4]</code>，会收到报错：$i\ is\ not\ a\ constant$。其实并不是要求中括号内非得都是常数，<strong>只要冒号左右两边不全为变量就行</strong>。于是我们学会使用<code>[i-:4]</code>，意思是<strong>往低里取从$i$开始$4$个位</strong>。</li></ol><p>最后将<code>sum[i]</code>用<strong>大括号拼接</strong>起来，<code>assign</code>给$out$就行了。代码及其$testbench$见下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> roll(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out<br>    );<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] arr[<span class="hljs-number">0</span>:<span class="hljs-number">7</span>],sum[<span class="hljs-number">0</span>:<span class="hljs-number">7</span>],tmp;<br><span class="hljs-keyword">integer</span> i,j;<br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i=i+<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>arr[i]=a[(i + <span class="hljs-number">1</span>) * <span class="hljs-number">4</span> - <span class="hljs-number">1</span>-:<span class="hljs-number">4</span>];<br><span class="hljs-keyword">end</span><br>sum[<span class="hljs-number">0</span>]=arr[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">7</span>;i=i+<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>sum[i+<span class="hljs-number">1</span>]=sum[i]+arr[i+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">assign</span> out=&#123;sum[<span class="hljs-number">7</span>],sum[<span class="hljs-number">6</span>],sum[<span class="hljs-number">5</span>],sum[<span class="hljs-number">4</span>],sum[<span class="hljs-number">3</span>],sum[<span class="hljs-number">2</span>],sum[<span class="hljs-number">1</span>],sum[<span class="hljs-number">0</span>]&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tbroll(<br>    );<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>a=<span class="hljs-number">32&#x27;h11111111</span>;<br>#<span class="hljs-number">10</span>;<br>a=<span class="hljs-number">32&#x27;h87654321</span>;<br>#<span class="hljs-number">10</span>;<br><span class="hljs-keyword">end</span><br>roll r(a,out);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="T3-Submatrix-MIPS"><a href="#T3-Submatrix-MIPS" class="headerlink" title="T3.Submatrix-MIPS"></a>T3.Submatrix-MIPS</h3><p>整体写法和常用指令确实记得，但是很多地方也不熟练或遗忘了。总结问题如下：</p><ol><li>不记得宏定义怎么写了，那些找矩阵下标，输入输出，平常复制粘贴惯了，国庆好好记一下；</li><li>由于天天复制粘贴宏定义，导致输入输出也不熟练，甚至完全遗忘了字符串是怎么输出的，还好在$help$文档里翻到了一处$la$提醒了我；</li><li>助教问答环节回答的不是很理想，要注意记一下各个<strong>寄存器的作用</strong>；</li><li>中间错误的想要用乘法，发现不会用，对乘除的$HI$，$LO$<strong>怎么分配</strong>，要再看一看，记一下并实战应用一下；</li><li>这次有时间不够的原因，做的很匆忙思路都没成型，导致删删改改很多，之后要整体<strong>构思</strong>好；</li></ol><p>本题解题思路:</p><p>没有递归和函数调用，所以是一道比较简单的MIPS题，考验你基本的输入输出，宏定义，寻址，循环等内容。可以不用写出C语言代码直接写。首先我们要能熟练的写出那些常用的宏定义，平常的练习中经常直接复制粘贴，可上机考试的时候没有办法投机取巧，只能自己老老实实打，这个时候像我一样忘了怎么输出字符串就很致命了。我们需要给矩阵开至少$4\times 4\times 4$的空间，用<code>asciiz</code>定义空格，换行与<code>&quot;Out of bounds&quot;</code>。输入循环$16$次，用$beq$跳出。先用<code>bgt</code>判断$i+m$和$j+n$是否存在$&gt;4$的情况，有就跳转到<code>error</code>，直接输出报错的字符串就行。接着往后写二重循环，外层从$i$到$i+m-1$，内层由$j$到$j+m-1$，注意不要漏掉</p><ol><li>每个循环末尾$j$指令</li><li>$j$指令前将循环变量$+1$</li><li>外层循环每次回到开头进入新一轮循环，将内层循环变量<strong>复位</strong></li><li>内层循环每输出一个数输出一个空格</li><li>外层循环$j$前输出换行符</li></ol><p>至于寄存器的作用：</p><div class="table-container"><table><thead><tr><th style="text-align:left">寄存器编号</th><th style="text-align:left">助记符</th><th style="text-align:left">名称</th><th style="text-align:left">用途</th><th style="text-align:left">是否在调用中保持</th></tr></thead><tbody><tr><td style="text-align:left"><strong>零寄存器</strong></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0</td><td style="text-align:left"><code>$zero</code></td><td style="text-align:left">常数零</td><td style="text-align:left">其值恒为0，读取它总是返回0，写入它无效。</td><td style="text-align:left">不适用</td></tr><tr><td style="text-align:left"><strong>保留寄存器</strong></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1</td><td style="text-align:left"><code>$at</code></td><td style="text-align:left">汇编临时寄存器</td><td style="text-align:left">被汇编器保留，用于处理大的立即数或地址加载（如 <code>lui</code> 指令）。<strong>程序员不应直接使用。</strong></td><td style="text-align:left">否</td></tr><tr><td style="text-align:left"><strong>返回值寄存器</strong></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">2-3</td><td style="text-align:left"><code>$v0</code> - <code>$v1</code></td><td style="text-align:left">值寄存器</td><td style="text-align:left">用于存放<strong>函数调用的返回值</strong>。如果返回值大小超过一个寄存器（如64位整数），则使用 <code>$v0</code> 和 <code>$v1</code> 共同存放。</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left"><strong>参数寄存器</strong></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">4-7</td><td style="text-align:left"><code>$a0</code> - <code>$a3</code></td><td style="text-align:left">参数寄存器</td><td style="text-align:left">用于向函数传递<strong>前四个参数</strong>。如果参数多于四个，超出的部分会通过栈来传递。</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left"><strong>临时寄存器</strong></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">8-15</td><td style="text-align:left"><code>$t0</code> - <code>$t7</code></td><td style="text-align:left">临时寄存器</td><td style="text-align:left">用于存放<strong>临时变量</strong>。在函数调用中，这些寄存器的值<strong>不保证</strong>被调用者保存。如果调用函数后还需要这些值，调用者必须自己保存。</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left"><strong>保存寄存器</strong></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">16-23</td><td style="text-align:left"><code>$s0</code> - <code>$s7</code></td><td style="text-align:left">保存寄存器</td><td style="text-align:left">用于存放<strong>需要跨函数调用保留的局部变量</strong>。如果一个函数使用了这些寄存器，它<strong>必须</strong>在函数开始时保存它们的原始值（通常在栈上），并在函数返回前恢复它们。</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left"><strong>更多临时寄存器</strong></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">24-25</td><td style="text-align:left"><code>$t8</code> - <code>$t9</code></td><td style="text-align:left">临时寄存器</td><td style="text-align:left">与 <code>$t0-$t7</code> 作用相同，是额外的临时寄存器。</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left"><strong>内核寄存器</strong></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">26-27</td><td style="text-align:left"><code>$k0</code> - <code>$k1</code></td><td style="text-align:left">内核保留寄存器</td><td style="text-align:left">专门为<strong>操作系统内核</strong>（如中断和异常处理程序）保留。应用程序<strong>不应使用</strong>这些寄存器。</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left"><strong>全局指针寄存器</strong></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">28</td><td style="text-align:left"><code>$gp</code></td><td style="text-align:left">全局指针</td><td style="text-align:left">指向静态数据区（存储全局变量和静态变量）的中间位置。通过 <code>$gp</code> 可以更方便地用单条指令访问64KB范围内的全局数据，而不需要每次都使用 <code>lui</code> 和 <code>ori</code> 两条指令。</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left"><strong>栈指针寄存器</strong></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">29</td><td style="text-align:left"><code>$sp</code></td><td style="text-align:left">栈指针</td><td style="text-align:left">指向运行时栈的顶部。栈用于存放函数返回地址、保存的寄存器、局部变量等。<code>$sp</code> 必须按字（4字节）对齐。</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left"><strong>帧指针寄存器</strong></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">30</td><td style="text-align:left"><code>$fp</code> 或 <code>$s8</code></td><td style="text-align:left">帧指针</td><td style="text-align:left">指向当前函数栈帧的底部。它提供了一个固定的参考点，方便访问栈上的参数和局部变量，尤其是在栈指针 <code>$sp</code> 动态变化时。虽然它被列为 <code>$s8</code>，但其作用更像一个专用的帧指针。</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left"><strong>返回地址寄存器</strong></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">31</td><td style="text-align:left"><code>$ra</code></td><td style="text-align:left">返回地址</td><td style="text-align:left">当使用 <code>jal</code>（跳转并链接）指令调用函数时，下一条指令的地址（返回地址）会自动存入 <code>$ra</code>。函数结束时通常通过 <code>jr $ra</code> 指令返回到调用点。</td><td style="text-align:left">否</td></tr></tbody></table></div><p>完整代码见下，宏定义板子也可自取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.macro end<br>li $v0,10<br>syscall<br>.end_macro <br><br>.macro getInt(%des)<br>li $v0,5<br>syscall <br>move %des,$v0<br>.end_macro <br><br>.macro printInt(%src)<br>move $a0,%src<br>li $v0,1<br>syscall <br>.end_macro <br><br>.macro printStr(%src)<br>la $a0,%src<br>li $v0,4<br>syscall <br>.end_macro <br><br>.macro push(%src)<br>addi $sp,$sp,-4<br>sw %src 0($sp)<br>.end_macro <br><br>.macro getIndex(%src1,%src2,%des)<br>sll %des,%src1,2<br>add %des,%des,%src2<br>sll %des,%des,2<br>.end_macro <br><br>.data<br>a: .space 100<br>space: .asciiz &quot; &quot;<br>nxtline: .asciiz &quot;\n&quot;<br>err: .asciiz &quot;Out of bounds&quot;<br><br>.text<br>li $s0,16<br>li $t0,0<br>for_in:<br>beq $t0,$s0,for_in_end<br>getInt($t1)<br>sll $t2,$t0,2<br>sw $t1 a($t2)<br>addi $t0,$t0,1<br>j for_in<br><br>for_in_end:<br>getInt($s1)#s1=m<br>getInt($s2)#s2=n<br>getInt($s3)#s3=i<br>getInt($s4)#s4=j<br><br>add $t4,$s1,$s3<br>add $t5,$s2,$s4<br>bgt $t4,4,error<br>bgt $t5,4,error<br><br>move $t0,$s3<br>for_i:<br>beq $t0,$t4,for_i_end<br>move $t1,$s4<br>for_j:<br>beq $t1,$t5,for_j_end<br>getIndex($t0,$t1,$t2)<br>lw $t3,a($t2)<br>printInt($t3)<br>printStr(space)<br>addi $t1,$t1,1<br>j for_j<br>for_j_end:<br>addi $t0,$t0,1<br>printStr(nxtline)<br>j for_i<br>for_i_end:<br>end<br><br>error:<br>printStr(err)<br>end<br><br></code></pre></td></tr></table></figure><p>下面附本次上机题目：</p><p>（注：本次上机全部做对才算通过）</p><h1 id="T1-推箱子"><a href="#T1-推箱子" class="headerlink" title="T1-推箱子"></a>T1-推箱子</h1><p>独小星在玩一个简化版的推箱子游戏，请你设计一个状态机，根据输入来判断箱子是否被推到了目标点并输出。</p><h2 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h2><h3 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h3><p>游戏地图建立在一个二维平面直角坐标系中，箱子在游戏开始或每次$reset$后位于$(0,0)$坐标处。推箱子的目标点固定位于$(5,5)$坐标处。</p><p>游戏地图大小为：以$(0,0)$为左下角，以$(5,5)$为右上角，边长为$5$的正方形 (共$6\times6=36$个坐标点) 。 位于游戏地图内，当且仅当 。</p><p>游戏地图中的坐标点分为墙体和空地。墙体固定为：$(1,1)$ ，$(1,2)$，$(2,1)$，$(4,4)$，$(4,3)$，$(3,4)$ 这 个坐标点。墙体是不可到达区域。</p><p>每周期输入一对$(dx,dy)$，表示箱子的移动变化量。若箱子当前坐标为$(x,y)$，则箱子的预期落脚点为$(x+dx,y+dy)$ 。</p><p>如果箱子的预期落脚点是合法的 (合法定义见下文) ，则在下一周期更新箱子的坐标为该落脚点。如果箱子的预期落脚点不合法，则将$flag$置为$1$持续一周期，下一周期箱子坐标保持不动。</p><p>保证每周期输入的 只会是：$(0,0)$ ，$(1,0)$，$(0,1)$ 这$3$种中的一种。</p><p>箱子的预期落脚点是合法的，<strong>当且仅当该落脚点位于游戏地图内，并且该落脚点不是墙体</strong>。</p><p>当箱子坐标位于目标点时，输出$out$为$1$ ，否则为$0$。</p><p>游戏地图大致如下：</p><img src="/posts/Pre%E4%B8%8A%E6%9C%BA-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E4%B8%8E%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/grid.png" class="" title="grid"><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><div class="table-container"><table><thead><tr><th>名称</th><th>功能</th><th>位宽</th><th>方向</th></tr></thead><tbody><tr><td>clk</td><td>时钟信号</td><td>1</td><td>I</td></tr><tr><td>reset</td><td><strong>异步</strong>复位信号</td><td>1</td><td>I</td></tr><tr><td>dx</td><td>坐标移动变化量</td><td>1</td><td>I</td></tr><tr><td>dy</td><td>坐标移动变化量</td><td>1</td><td>I</td></tr><tr><td>out</td><td>箱子是否位于目标点</td><td>1</td><td>O</td></tr><tr><td>flag</td><td>是否尝试移动到非法坐标</td><td>1</td><td>O</td></tr></tbody></table></div><ul><li><strong>输入</strong>：保证每周期输入的$(dx,dy)$只会是：$(0,0)$ ，$(1,0)$，$(0,1)$ 这$3$种中的一种。</li><li><strong>输出</strong>：$flag$默认为$0$，若当前周期箱子尝试移动到非法坐标，则下一周期$flag$置为$1$( 若有$reset$则立刻复位为$1$)。</li><li><strong>文件内模块名</strong>: <strong>Sokoban</strong></li><li><strong>测试电路图</strong>：</li></ul><img src="/posts/Pre%E4%B8%8A%E6%9C%BA-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E4%B8%8E%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/testcirc.png" class="" title="testcirc"><ul><li><strong>注意：请保证模块的 appearance 与下图一致，否则有可能造成评测错误。注意输入的上下顺序。</strong></li></ul><img src="/posts/Pre%E4%B8%8A%E6%9C%BA-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E4%B8%8E%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/fmt.png" class="" title="fmt"><h1 id="T2-翻涌数字"><a href="#T2-翻涌数字" class="headerlink" title="T2-翻涌数字"></a>T2-翻涌数字</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>给出一个位宽为$32$的输入 ，代表$8$个位宽为$4$的数据，分别命名为$a_0$，$a_1$，…… ，$a_7$ 。</p><p>其中$a_i$= $a[(i+1)*4-1:i*4]$</p><p>对每一个$a_i$进行操作，使得$a_i$= $\sum_{j=0}^{i}a_j$</p><p>对操作后得到的$a_i$按原顺序进行拼接，并输出拼接后的$a$。</p><p>特别的：若$a_i$相加时出现溢出，则保留对 <code>4&#39;d16</code> 取余后的结果。</p><h2 id="2、模块规格"><a href="#2、模块规格" class="headerlink" title="2、模块规格"></a>2、模块规格</h2><p>模块名：roll</p><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>a[31:0]</td><td>I</td><td>用于计算的数</td></tr><tr><td>out[31:0]</td><td>O</td><td>计算结果</td></tr></tbody></table></div><h2 id="3、输入输出样例"><a href="#3、输入输出样例" class="headerlink" title="3、输入输出样例"></a>3、输入输出样例</h2><img src="/posts/Pre%E4%B8%8A%E6%9C%BA-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E4%B8%8E%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/wave.png" class="" title="wave"><p>如图，当 为 <code>32&#39;h11111111</code> 时， 为 <code>32&#39;h87654321</code> 。</p><p>当 为 <code>32&#39;h87654321</code> 时， 为 <code>32&#39;h4c5fa631</code> 。</p><h2 id="4、提交要求"><a href="#4、提交要求" class="headerlink" title="4、提交要求"></a>4、提交要求</h2><ul><li>必须严格按照模块的端口名称和方向定义。</li><li>文件内模块名： roll</li><li>模块内不要包含任何 <code>$display</code> 语句，以防造成误判。</li></ul><h2 id="T3-MIPS-Submatrix"><a href="#T3-MIPS-Submatrix" class="headerlink" title="T3-MIPS_Submatrix"></a>T3-MIPS_Submatrix</h2><h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><p>实现 MIPS 汇编程序：从 $4 × 4$ 的大矩阵 $A$ 中提取出指定位置指定大小的子矩阵。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第 1 - 16 行依次输入大矩阵 $A$ 的元素 $t$（整数， $0 ≤ t ≤ 100$）：</p><ul><li>第一行： $A$ 第 0 行第 0 列的元素</li><li>第二行： $A$ 第 0 行第 1 列的元素</li><li>…… （依此类推）</li></ul><p>第 17 行输入一个整数 $m$ ，表示子矩阵的行数（$1 ≤ m ≤ 4$）。</p><p>第 18 行输入一个整数 $n$ ，表示子矩阵的列数（$1 ≤ n ≤ 4$）。</p><p>第 19 行输入一个整数 $i$ ，表示子矩阵的第 0 行第 0 列元素在大矩阵 $A$ 中的行数（$0 ≤ i ≤ 3$）。</p><p>第 20 行输入一个整数 $j$ ，表示子矩阵的第 0 行第 0 列元素在大矩阵 $A$ 中的列数（$0 ≤ j ≤ 3$）。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><ol><li>若子矩阵完全位于大矩阵内，未超出边界：输出$m*n$子矩阵，共 $m$ 行，每行 $n$ 个元素（空格分隔）。</li><li>若超出边界：输出字符串 <code>Out of bounds</code>。</li></ol><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><ol><li>大矩阵 $A$ 的行索引和列索引从 0 开始编号。</li><li>请勿使用 <code>.globl main</code></li><li>请使用 <code>syscall</code> 结束程序：</li></ol><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mips">li $<span class="hljs-built_in">v0</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">syscall</span><br></code></pre></td></tr></table></figure><h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例 1"></a>输入样例 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs none">1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>2<br>2<br>1<br>1<br></code></pre></td></tr></table></figure><h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例 1"></a>输出样例 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs none">6 7<br>10 11<br></code></pre></td></tr></table></figure><h3 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例 2"></a>输入样例 2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs none">4<br>3<br>2<br>1<br>8<br>7<br>6<br>5<br>12<br>11<br>10<br>9<br>13<br>14<br>15<br>16<br>3<br>2<br>2<br>2<br></code></pre></td></tr></table></figure><h3 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例 2"></a>输出样例 2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">Out of bounds<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CO上机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>CO上机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P0课下-总结反思文档</title>
    <link href="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/"/>
    <url>/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P0课下-总结反思文档"><a href="#P0课下-总结反思文档" class="headerlink" title="P0课下-总结反思文档"></a>P0课下-总结反思文档</h1><p>本次课的实验教程相当完善，按部就班走就没有大问题，会有一些细节理解上的偏差和纠结。我们先把教程上知识点及引导部分放上来。</p><h2 id="1-如何设计电路模块"><a href="#1-如何设计电路模块" class="headerlink" title="1.如何设计电路模块"></a>1.如何设计电路模块</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>相信通过之前数个教程的学习，你已经对我们将要使用的工具——Logisim 与 ISE 已经比较熟悉。从这个 Project 开始，我们将要使用这两个工具来进行数字电路元件的设计。在我们这个 Project 中我们将主要关注 Logisim 组合电路和时序电路的设计。</p><h3 id="电路设计的目标"><a href="#电路设计的目标" class="headerlink" title="电路设计的目标"></a>电路设计的目标</h3><p>电路设计需要有一个“需求”——电路的功能与特性，这是我们电路设计的目标。如果我们从某个电路的用户角度看，我们实际上也是把电路本身作为一个“<strong>黑箱</strong>”，不关心其中的实现。因此我们自己在设计电路时，比起具体的实现，我们最先需要关心的就是电路的功能与特性。所谓磨刀不误砍柴功，通过对电路功能的深度理解和详细设计，我们往往能够在设计中节省很多精力，下面就给大家介绍一种规范需求的方法——端口定义表。</p><p><img src="P0-1-1.png" alt="P0-1-1"></p><p>上图是一个 8 位加法器最为简单的定义表，定义了它有 5 个信号，8 位信号 A、B、SUM，1 位信号 C0 和 Overflow。方向中用 I 代表 Input 输入，用 O 代表 Output 输出。描述一栏用汉语对加法器进行了简单的描述。信号的语法遵循了类似 Verilog HDL 中的写法，如此，通过这个简单的端口定义表，我们就能够知晓我们这个 8 位加法器应该做什么。</p><p>对于更复杂的电路，我们会使用两张表。</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-1-2.png" class="" title="P0-1-2"><p>一张模块接口定义表与一张功能定义表，原因是对于这些复杂电路来说，简单的端口定义已经无法识别其功能，或者该模块在不同的情况与输入下有不同的功能，这种时候我们需要使用功能定义表来对模块的功能进行约定。</p><p>在对我们设计的电路有了如此合理，无歧义的设计目标后，我们才能去动手实现真正的电路。我们需要把设计与实现这两项工作分开来保证我们在工程中较高的完成率。<strong>因此，建议，或者说要求，大家在之后我们的电路设计作业中，先要对模块的端口和功能进行书面化的定义，可以不拘泥于具体形式，但是一定要是可供他人阅读，立马明白模块功能的，</strong>再去进行实际的设计，我们不希望看到最终你设计的电路出问题是从功能定义上就出了毛病。我们之后的练习题部分也将会给出定义表供大家参照。</p><h3 id="分析目标并划分层次"><a href="#分析目标并划分层次" class="headerlink" title="分析目标并划分层次"></a>分析目标并划分层次</h3><p>在定义清楚设计的目标之后，我们需要对我们的实现目标进行分析——这是一个时序电路？还是一个无状态的纯组合电路？它需要同时有多个功能吗？需要分层化设计吗？需要模块化设计么？——解决这些问题的过程，其实就是完成实现的过程。而这些问题往往也与实际的模块要求有关系，之后我们将用具体的实例来进行说明。</p><p>模块设计相信大家在理论课以及前面的指导中已经有所耳闻，在这里需要提的一点是<strong>分层</strong>的设计思想，在计算机科学中领域中有一句名言，<strong>“在计算机科学中的任何问题都可以通过增加一个间接层来解决”（Any problem in computer science can be solved with another layer of indirection. ）。</strong>这句话即使是在电路设计这个偏硬的领域下也是有效的，以 32 位加法器为例，初拿到手，可能会觉得无所适从，输入是两个 32 位数，输出是一个 32 位数，关系虽然抽象上简单，但是并不能简单地用门电路概括。但是如果我们添加一个“一位加法器”的间接层。使用 1 位加法器拼出一个 32 位加法器比较简单，单独拼出一个 1 位加法器也很简单。如此，问题就解决了！可见分层的威力，希望大家在设计时也要重视这种思想，当然，<strong>分层</strong>的思想在后续课程中可能会和大家一次又一次的见面，记得和熟人打个招呼！</p><h3 id="电路搭建与注意事项"><a href="#电路搭建与注意事项" class="headerlink" title="电路搭建与注意事项"></a>电路搭建与注意事项</h3><p>在完成设计阶段后，具体的实现比起来可能只是一些小 case，通过我们关于工具的知识，可以把我们的设计变为具体的元件组合，这一点我们将在之后的示例里看的更加清楚。具体到工具上，在 Logisim 中，需要注意布线、器件设置等，在 Verilog 中，需要注意位宽一致、命名正确等。这里就是要考察大家的基本功啦！</p><p>在搭建功能较为复杂，重复性部件较多的电路（如通用寄存器堆）时，如果全部使用手工搭建会消耗较多时间，过程中也容易产生接线错误等问题。我们可以尝试采用代码生成 XML 文本等<a href="https://d.buaa.edu.cn/http/77726476706e69737468656265737421f3e44293353526526b0988e29d51367b9787/tutorial/logisim/logisim-6/logisim-6-4/">自动化方法</a>来辅助进行模块搭建。无论是手工搭建还是自动生成，建议同学们在完成 Logisim 电路后仔细检查模块外观、布线与接线、功能等是否正常，避免产生不必要的麻烦。</p><p>当然，我们也在此给出一些具体实现中常常遇到的一些问题，便于大家早点发现问题进行排除：</p><h4 id="多驱动"><a href="#多驱动" class="headerlink" title="多驱动"></a>多驱动</h4><p>这是指一个变量有两个以上的赋值源。这一般是由于对于某一输出源，存在多个路径向其提供输出值，对于这种情况，Logisim 也会识别并将相关线路标红。</p><p>具体而言，这可能是<strong>一个输入源经过不同的运算对其输出不同的值引起的：</strong></p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-1-3.png" class="" title="P0-1-3"><p>上述例子中，同一输入存在两条不同的路径到达输出，导致了多驱动。</p><p>也可能是由于<strong>多个输入源对其输出不同值引起的：</strong></p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-1-4.png" class="" title="P0-1-4"><p>上述例子中，多个输入源同时驱动输出，导致了多驱动</p><p>在 Verilog 中，也同样存在着这样的情况：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> signal_1 = a ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span><br><span class="hljs-keyword">assign</span> signal_1 = b ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span><br></code></pre></td></tr></table></figure><h4 id="组合逻辑环路"><a href="#组合逻辑环路" class="headerlink" title="组合逻辑环路"></a>组合逻辑环路</h4><p>这是指不经过任何时序逻辑（寄存器等），而直接将组合逻辑电路的输出信号反馈到其输入节点而形成的环路。这一般是由于<strong>电路中存在输出直接作为该输出的输入而导致的：</strong></p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-1-5.png" class="" title="P0-1-5"><p>上述例子中，输出又直接作为了输入的一部分（MUX 选择条件）接入到了输入中，导致电路发生震荡。Logisim 识别并将相关线路标注为蓝色。</p><p>同样，在 Verilog 中，也同样存在着这样的情况：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">assign <span class="hljs-keyword">BHR_Violent </span>= (Delay_BHR_Hash_Write_PC == <span class="hljs-keyword">BHR_Hash_Read_PC);</span><br><span class="hljs-keyword"></span>assign <span class="hljs-keyword">BHR_Hash_Read_PC </span>= <span class="hljs-keyword">BHR_Violent </span>? hash_10(Now_PC) + <span class="hljs-number">1</span> : hash_10(Now_PC);<br></code></pre></td></tr></table></figure><p>上述例子中，BHR_Violent 的计算需要 BHR_Hash_Read_PC 的值，但是 BHR_Hash_Read_PC 的计算同样需要 BHR_Violent 的值，这样导致了一个组合逻辑上的回路。</p><p><strong>当然，Logisim 线路颜色表达的含义不局限于以上的几种情况，希望大家在电路搭建时不要盲目依赖 Logisim 或者 ISE 给出的线路颜色或者错误信息，而应该在参考的基础上仔细思考搭建时产生的问题。</strong></p><h3 id="电路搭建与测试"><a href="#电路搭建与测试" class="headerlink" title="电路搭建与测试"></a>电路搭建与测试</h3><p>在完成了搭建后，测试是个必不可少的环节，尽管这次我们搭建了自动测试平台，所有的文件可以自动测试，但是在实际环境中，测试这项工作更多也需要设计者来进行一定的自我测试，来避免一些显而易见的错误。而测试的基本原则就是根据我们的端口定义和功能定义表，对各种可能的输入情况进行排查，观察是否有与定义违背的情况，或者在输入未定义信号的时候会不会产生一些非常危险的行为。</p><h4 id="测试样例设计"><a href="#测试样例设计" class="headerlink" title="测试样例设计"></a>测试样例设计</h4><p>有限的输入可能性可以穷举，但是需要消耗大量时间；无限的输入可能性无法穷举；无论是什么情况，我们都不可能枚举所有输入以求测试的覆盖性，因此最好的方法是使用有代表性的，有“价值”的测试数据进行测试，而测试数据的价值可以体现在很多方面，不同情境下我们对“价值”的定义不同。在这里我们给出几种样例生成的参考方向，以供大家在实践中使用，但是如何设计更多潜在有价值的测试数据，还需要同学们靠不断的练习来摸索并积累经验！</p><ul><li>覆盖所有测试功能正常进行的样例</li><li>极端情况的样例</li><li>异常情况的样例</li></ul><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><p>为了提高测试效率，我们可以使用 Pre 提到的 <a href="https://d.buaa.edu.cn/http/77726476706e69737468656265737421f3e44293353526526b0988e29d51367b9787/tutorial/logisim/logisim-6/logisim-6-5/">自动化测试</a> 方法！</p><p>大家看完上面的设计和测试方法可能还一头雾水，不过不用担心，下面我们将通过 CRC 校验码的例子来带大家深入体会整个流程！</p><blockquote><p>笔者的话：其实，我个人并不认为“具体的实现比起来可能只是一些小 case”，往往问题就出现在搭建过程中，感觉这需要一定的积累。自动化方法我至今都不会，我不知道学起来会不会太费时，毕竟只有P0，P3需要用Logisim。本篇中端口定义表是极其重要的，它将贯穿整个CO。</p></blockquote><h2 id="2-CRC-校验码计算电路的设计与测试"><a href="#2-CRC-校验码计算电路的设计与测试" class="headerlink" title="2.CRC 校验码计算电路的设计与测试"></a>2.CRC 校验码计算电路的设计与测试</h2><p>在这个部分中，你将从需求开始一步一步搭建我们所要求的 ８ 位 CRC 校验码计算电路。我们希望在这个简单的例子中，你能体会到方法性的东西，并应用到之后的设计中去。这对之后的学习和<strong>课上测试</strong>都是很有帮助的，请各位谨记。</p><h3 id="CRC-校验码简介"><a href="#CRC-校验码简介" class="headerlink" title="CRC 校验码简介"></a>CRC 校验码简介</h3><p>CRC 校验是数据通信领域中最常用的一种查错校验方式，它对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。（“帧” 在本章指的是数据的二进制码）</p><p>在了解这种校验码怎么计算之前，我们需要先了解一种特殊的除法:“模二除法”。它与算术除法类似，但在做减法时既不向上借位，也不比较除数和被除数相同位数值的大小；它的运算法则为 <code>1-1=0</code>，<code>0-1=1</code>，<code>1-0=1</code>，<code>0-0=0</code>，例如 <code>1100-1001=0101</code>。对于模二除法，我们以被除数为 1011，除数为 10 为例，运算过程如下：</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-3-1.png" class="" title="P0-3-1"><p>如果细心的话，你会发现，模二除法中的减法和异或的效果是相同的，所以模二除法可以用异或来完成。</p><p>知道了模二除法的计算过程，CRC 校验码的计算就很简单了。我们只需要将原帧补上（除数位数 - 1）个 0 作为被除数，然后进行模二除法即可。举个例子，我们要发送的帧 A 为 10011，发送端和接收端共同选定的除数 B 为 1110。因为 B 是 4 位二进制数，我们需要在 A 的后面补上 3 个 0，从而得到 A’=10011000。我们将 A’ 作被除数，B 作除数，进行“模二除法”。如下图：</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-3-2.png" class="" title="P0-3-2"><p>最后得到的余数是一个三位数（注意如果不是三位，也要在前面补零来凑齐三位），这就是要求的校验码。我们将得到的校验码 110 拼接在原数据帧的后面，就得到了要发送的新帧 A’’=10011110。这样就完成了 CRC 校验码的生成。</p><h3 id="CRC-校验码计算电路的定义"><a href="#CRC-校验码计算电路的定义" class="headerlink" title="CRC 校验码计算电路的定义"></a>CRC 校验码计算电路的定义</h3><p>在普通的设计流程中，一般都是用汉语描述电路的功能，需要我们自己来进行形式化的定义，不过由于我们这个例子相对简单，因此直接给出我们 ８ 位 CRC 校验码计算电路的端口定义。</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-3-3.png" class="" title="P0-3-3"><h3 id="分析目标并层次化"><a href="#分析目标并层次化" class="headerlink" title="分析目标并层次化"></a>分析目标并层次化</h3><p>初拿到如上表的需求，可以发现这是一个没有状态的部件，自身内部不存储信息，单纯的输入就决定了输出，因此有一种相当暴力的思路就是直接画出真值表，输入总共 11 位 2 进制码（考虑到除数的最高位一定为 1），输出 11 位二进制码，我们需要动 2048 下手指才可以把真值表画出来——似乎繁琐了点？我们需要更加简单的方法。但是希望大家明白真值表法永不过时，在输入输出比较小时是非常实用的方法，并且可以使用相关工具自动生成电路。</p><p>我们仔细分析一下，其实类似除法的计算方法，我们可以把这个计算过程分解为多次进行被除数为 4 位的除法计算。因此我们引入“4 位模二除法器”这个间接层，这样问题就变成了两个部分:</p><ul><li>设计四位模二除法器</li><li>使用四位模二除法器搭建 8 位 CRC 校验码计算电路</li></ul><p>为了方便理解，我们的给出了一种四位模二除法器的端口定义（这只是为了讲解时参考，你在设计时不一定要遵循这个定义）</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-3-4.png" class="" title="P0-3-4"><p>我们知道，模二除法和异或运算是等价的，所以对于一个四位除四位的模二除法器，如果被除数的最高位是 1，则商 1，余数使用异或门来将四位被除数和四位除数异或即可。当然，如果被除数的最高位是 0，则商为 0，余数直接等于被除数了。</p><p>这个电路搭建很简单，我们只需要判断下被除数的最高位，然后分情况输出即可。</p><p>搭建完四位的除法器，我们再来看看怎么使用这个简单的电路来搭建我们所需要的复杂电路。类似于普通除法的过程，我们计算模二除法时也是每次从被除数中取出一定的位数（对于该问题来说是四位）来和除数相除，除得的余数再补上一位被除数后继续与除数相除。如此，计算过程就相当于进行多次四位的模二除法了。我们要做的就是将上一个四位模二除法器的余数输出，拼接一位被除数作为下一个四位模二除法器的被除数输入(除数始终是同一个数),如此反复直到被除数所有的位都被使用。</p><h3 id="具体搭建（-LOGISIM-）"><a href="#具体搭建（-LOGISIM-）" class="headerlink" title="具体搭建（ LOGISIM ）"></a>具体搭建（ LOGISIM ）</h3><p>在 Logisim 搭建上述电路时还需注意：</p><ul><li>可以使用 <a href="https://d.buaa.edu.cn/http/77726476706e69737468656265737421f3e44293353526526b0988e29d51367b9787/tutorial/logisim/logisim-2/logisim-2-3/">Tunnel</a> 来表示中间变量简化布线</li><li>可以改变门电路输入数简化电路</li><li>这个电路并不是最简的，可以使用逻辑方法优化</li></ul><p>综上，我们可以在完成了设计工作的基础上使用 Logisim 进行电路搭建啦！</p><h3 id="测试与验证"><a href="#测试与验证" class="headerlink" title="测试与验证"></a>测试与验证</h3><h4 id="测试样例设计-1"><a href="#测试样例设计-1" class="headerlink" title="测试样例设计"></a>测试样例设计</h4><p>正如前文所述，开发者的自我测试在开发过程中是十分重要，这里我们就以刚搭建的 8 位 CRC 校验码计算电路为例来说明如何进行测试样例的设计。对于我们这里的组合电路，测试样例要覆盖所有的输入。因此最简单直接的想法就是将所有的二进制输入依次尝试一遍。在我们的电路中，共需尝试 2048 组输入。这种方法的好处就是保证彻底的覆盖性，缺点也很明显，需要过多的操作。在面对更复杂电路时，我们需要更加合理的样例。一种比较合理的方法是根据功能来设计相关的样例：</p><ul><li>覆盖所有测试功能正常进行的样例（如 A:11001010 B:1011, A:01001110 B:1100）</li><li>极端情况的样例（如：A:00000000 B:1000）</li><li>异常情况的样例（如：A:110X010X B:XXXX，这个 X 的输入在 Logisim 也是支持的）</li></ul><p>在设计出相应的测试样例后，需进行相关的输入观测现象，为了使测试电路更加简洁，我们将使用已经设计好的子电路进行测试，下面介绍子电路。</p><h4 id="子电路"><a href="#子电路" class="headerlink" title="子电路"></a>子电路</h4><p>我们在 Pre 中学习了子电路的使用，不知道同学是否有尝试过。在 P0 中，随着电路<strong>逐渐复杂化</strong>，我们需要子电路的帮助来完成整体电路。</p><p>其实子电路和<strong>子函数</strong>有一定的相似性。我们可以把合作完成同一功能的电路封装为一个子电路，再像 main 中调用子函数那样多处进行引用，减少重复且不必要的电路搭建，一定程度上减少我们的工作量。同时，由于 Logisim 是在画布上完成我们的任务，利用子电路也可以让我们整个画布更加<strong>简洁清楚</strong>。</p><p>同时，也可以把一部分相互依赖性高且线路连接复杂的电路封装成一个子电路，虽然可能不会有其他地方也利用这个子电路，但是由于 Logisim 没有很好的 debug 的方式，利用这个方式可以通过测试<strong>保证每个子电路的正确性</strong>，进而确定我们提交电路的正确性。</p><h5 id="如何使用子电路"><a href="#如何使用子电路" class="headerlink" title="如何使用子电路"></a>如何使用子电路</h5><p>为了提高使用子电路的效率，我们可以通过外观编辑界面以更改电路外观的形状及端口位置；通过更改 layout 为子电路及其相应端口设置 Label ，进而区分相同子电路的不同引用，并对子电路的输入输出进行命名（在引用时鼠标悬停即可查看其自定义名称），在引用子电路的同时可以更清楚其信息。</p><p>同时，在进行电路测试的时候，应该也测试每个子电路的功能，之后再对整个电路进行测试。如此可以减轻工作量，更快地完成测试工作。</p><p>在之后的题目中，虽然不用子电路也可以完成任务，但希望同学们可以尝试着使用子电路。</p><p>这里给出测试电路示例：(“CRC” 为你需要搭建的电路)</p><p>我们将设计好的 CRC 电路进行封装，并命名为 “CRC”，在测试电路中，A、B 为输入观测值，C 为输出观测值，“CRC” 以子电路的形式出现。</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-3-5.png" class="" title="P0-3-5"><h2 id="3-Logisim-中的有限状态机"><a href="#3-Logisim-中的有限状态机" class="headerlink" title="3.Logisim 中的有限状态机"></a>3.Logisim 中的有限状态机</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>经过理论课程和之前 Logisim 教程部分的学习，相信大家对有限状态机的基本知识已经有了充分的了解，也已经掌握了使用 Logisim 设计简单状态机的方法技巧。现在，我们帮助大家简单的回顾一下使用 Logisim 设计有限状态机的基本步骤，以帮助大家更快的适应 P0。</p><h3 id="使用-Logisim-设计有限状态机的基本步骤"><a href="#使用-Logisim-设计有限状态机的基本步骤" class="headerlink" title="使用 Logisim 设计有限状态机的基本步骤"></a>使用 Logisim 设计有限状态机的基本步骤</h3><p>使用 Logisim 设计有限状态机的过程基本上可以分为三个步骤： - 设计实现状态存储模块 - 设计实现状态转移模块 - 设计实现输出模块</p><p>以上三个模块是对有限状态机进行抽象后的三个主要方面。其中，状态转移模块和输出模块内是纯组合逻辑，不涉及时序逻辑。而状态存储模块则需要存储每个周期有限状态机的具体状态。它们之间的关系是，状态转移模块根据当前有限状态机的状态(即状态存储模块所存储的值)和当前的输入计算出有限状态机的下一状态值，当时钟上升沿到来时，这个新的状态值被存入状态存储模块中。输出模块的逻辑分为两种，根据输出逻辑的不同，有限状态机又被分为 Moore 型状态机和 Mealy 型状态机。它们之间具体的差别是，Moore 型状态机的输出逻辑仅与有限状态机当前状态值有关；而 Mealy 型状态机的输出逻辑则与有限状态机的当前状态和当前输入有关。</p><p>Moore 型状态机示例图</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-9-1.svg" class="" title="P0-9-1"><p>Mealy 型状态机示例图</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-9-2.svg" class="" title="P0-9-2"><p>（注：上图模块从左至右分别是：状态转移，状态存储，输出）</p><h3 id="设计建议"><a href="#设计建议" class="headerlink" title="设计建议"></a>设计建议</h3><ol><li>分析具体问题，画出状态转移图</li><li>对状态进行合适的编码</li><li>画出状态转移和输出逻辑的真值表</li><li>在 Logisim 中实现状态转移和输出逻辑，并采用合适的存储器存储具体状态值</li></ol><hr><p>同学们可以重新回顾一下 pre 部分中 Logisim 的部分内容，我们可以通过通过 analyze circuit 的功能来完成状态机状态转移部分的内容。（在 project-analyze circuit 可以选择此功能）</p><p>这个功能让我们可以通过打表的方式表示 input 和 output 的关系。当然同学们可以选择自己搭建电路，或者通过更好地设计状态机来简化其状态转移的过程。</p><h3 id="有限状态机测试"><a href="#有限状态机测试" class="headerlink" title="有限状态机测试"></a>有限状态机测试</h3><p>在完成了对有限状态机的设计之后，我们还需要进行有限状态机的<strong>测试</strong>，正如我们在教程中学到的，测试一直是电路设计中一个非常重要的环节。但是由于 FSM 相比之前简单的组合电路更加复杂，因此其测试也会包含更多内容，可以概括为两个主要的部分——<strong>输出电路</strong>测试与<strong>状态转移</strong>电路测试。</p><p>如果我们仍采用在组合电路中采用的<strong>黑箱测试</strong>办法，直接将输入与输出联系起来 ，那么我们将会需要非常大数量的样例序列来进行测试，这种做法既不经济也不实用，因此我们不予采用。我们需要做的是，将<strong>输出电路</strong>测试与<strong>状态转移</strong>电路测试分开进行，记录状态信息。</p><p>如果我们将这两者分开，那么对于这两者来说，它们都是普通的组合电路，只需要使用我们之前的方法就可以完成相关测试，测试上的问题也就迎刃而解了。</p><div class="table-container"><table><thead><tr><th>思考题</th></tr></thead><tbody><tr><td>状态存储器的复位方式包括<strong>异步复位</strong>和<strong>同步复位</strong>，二者的定义分别是什么？两种复位方式在 Verilog 中可以通过什么语句句式实现？在 Logisim 中又可以通过什么样的电路框架实现？</td></tr><tr><td>在 Verilog 中我们可以通过<code>initial</code>块对状态存储器的初值进行定义，在 Logisim 中我们可以通过哪些电路框架实现赋初值的功能？</td></tr><tr><td>一个大型的 Logisim 电路设计可能会具有非常复杂的电路结构，你有哪些可以降低这种复杂性的设计方法？</td></tr></tbody></table></div><p>那么，教程部分结束，下面是题面及我的解答。</p><h2 id="4-P0题面"><a href="#4-P0题面" class="headerlink" title="4.P0题面"></a>4.P0题面</h2><h3 id="1-P0-L0-CRC-CRC校验-P0-Q1"><a href="#1-P0-L0-CRC-CRC校验-P0-Q1" class="headerlink" title="1.P0_L0_CRC:CRC校验(P0.Q1)"></a>1.P0_L0_CRC:CRC校验(P0.Q1)</h3><h4 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h4><p>使用Logisim搭建一个除数为四位，原数据帧为8位的CRC校验码计算电路。具体模块端口定义如下：</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/499-1.png" class="" title="499-1"><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名: <strong>CRC</strong></li><li>我们规定除数的最高位一定为1,不需要考虑最高位非1的情况</li><li><strong>注意:由于信号原帧位数为8位，进行除法运算时被除数应为8+3=11位</strong></li><li>测试电路：(CRC为你需要搭建的电路)</li></ul><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/499-2.png" class="" title="499-2"><ul><li><strong>注意:请保证模块的appearance与下图完全一致，否则有可能造成评测错误</strong>(查看模块appearance方法:在Logisim中打开相应模块后点击左上角</li></ul><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/499-4.png" class="" title="499-4"><h3 id="2-P0-L0-GRF-实现GRF-P0-Q2"><a href="#2-P0-L0-GRF-实现GRF-P0-Q2" class="headerlink" title="2.P0_L0_GRF:实现GRF(P0.Q2)"></a>2.P0_L0_GRF:实现GRF(P0.Q2)</h3><h4 id="提交要求-1"><a href="#提交要求-1" class="headerlink" title="提交要求"></a>提交要求</h4><p>使用Logisim搭建一个GRF。</p><p>GRF中包含32个32位寄存器，分别对应0~31号寄存器，其中0号寄存器读取的结果恒为0。具体模块端口定义如下：</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/269-1.png" class="" title="269-1"><p>模块功能定义如下：</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/269-2.png" class="" title="269-2"><ul><li>必须严格按照模块的端口定义</li><li><strong>0号寄存器读出的数据在任何时刻都为0</strong></li><li><strong>请使用寄存器部件来实现GRF中的32个寄存器</strong></li><li>文件内模块名: grf</li><li>测试电路：(grf为你需要搭建的电路)</li></ul><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/269-3.png" class="" title="269-3"><ul><li><strong>注意:请保证模块的appearance与下图完全一致，否则有可能造成评测错误</strong>(查看模块appearance方法:在Logisim中打开相应模块后点击左上角</li></ul><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/269-5.png" class="" title="269-5"><h3 id="3-P0-L1-navigation-2020：Logisim导航-P0-Q3"><a href="#3-P0-L1-navigation-2020：Logisim导航-P0-Q3" class="headerlink" title="3.P0_L1_navigation_2020：Logisim导航(P0.Q3)"></a>3.P0_L1_navigation_2020：Logisim导航(P0.Q3)</h3><h4 id="提交要求-2"><a href="#提交要求-2" class="headerlink" title="提交要求"></a>提交要求</h4><p>计小组要去机房上机考试，需要去B机房，但是目前他在A机房。他现在的时间很充裕，就决定生成一串随机序列，告诉他下一步行走的方向，直到走到B机房。他希望用Logisim搭建一个可以导航的Moore型有限状态机，来通过序列告诉他是否到达B机房。</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/393-1.png" class="" title="393-1"><p>题目要求：</p><p>计小组只能往东南西北四个方向行走，且若能行走，则每次<strong>只能行走一格</strong>。若下一步不存在机房让计小组行走，那么计小组会撞到墙壁并且<strong>hit置高一周期</strong>，此时计小组仍<strong>保持原地</strong>不会移动，等待下一周期再进行运动。（如果下一步依旧撞墙， 则hit仍然置高；若下一步不会撞墙，则计小组将会继续行进，hit在此周期置0）</p><p>计小组走到B机房后，<strong>“到达”信号需要置位</strong>，<strong>并保持一周期</strong>。到达B机房后计小组将会在下一周期回到原点，（下一周期的输入将被忽略掉）等待下下周期的输入，继续测试他的序列。</p><p>计小组遵循上北下南左西右东的方向完成操作。</p><p>计小组在时钟上升沿的时候就已经知道自己下一步的方向并且瞬移过去，并且立即做出判断。</p><p>端口定义：</p><div class="table-container"><table><thead><tr><th style="text-align:left">信号名</th><th style="text-align:left">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">dir[1:0]</td><td style="text-align:left">I</td><td style="text-align:left">表示行走的方向：00：向北走 01：向东走 10：向南走 11：向西走</td></tr><tr><td style="text-align:left">clk</td><td style="text-align:left">I</td><td style="text-align:left">时钟信号</td></tr><tr><td style="text-align:left">reset</td><td style="text-align:left">I</td><td style="text-align:left">异步复位信号</td></tr><tr><td style="text-align:left">arrive</td><td style="text-align:left">O</td><td style="text-align:left">是否到达</td></tr><tr><td style="text-align:left">hit</td><td style="text-align:left">O</td><td style="text-align:left">是否撞上墙壁</td></tr></tbody></table></div><p><strong>模块名</strong>：navigation</p><p><strong>必须严格按照模块的端口定义</strong></p><p><strong>测试电路</strong>：</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/393-3.png" class="" title="393-3"><p><strong>注意:请保证模块的appearance与下图完全一致，否则有可能造成评测错误</strong>(查看模块appearance方法:在Logisim中打开相应模块后点击左上角</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/393-2.png" class="" title="3932.png"><h3 id="P0-L0-FSM：Logisim中的FSM-P0-Q4"><a href="#P0-L0-FSM：Logisim中的FSM-P0-Q4" class="headerlink" title="P0_L0_FSM：Logisim中的FSM(P0.Q4)"></a>P0_L0_FSM：Logisim中的FSM(P0.Q4)</h3><h4 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h4><p>正则表达式是对字符串操作的一种逻辑公式，它通常被用来检索、替换符合某个模式的文本。它的规则比较复杂，我们现在只讲解其中比较简单的几种规则。</p><ul><li>[…]是指要匹配中括号中的字符(注意是字符不是字符串),比如[xyz]就是要匹配x y z这三个字符中的任意一个。</li><li>{…}是指要求匹配”{“前的那个字符几次，比如a{2}是指要匹配a两次，a{2,4}是指要匹配a 2至4次,a{,4}指要匹配a 0至4次，a{2,}指要匹配a 2至无穷次。所以[cd]{1,2}就是要求匹配(c或d)一次或两次,即cc、dd、cd、dc、c、d都是能匹配的。</li><li>(…)是指将()内的字符串视为一个整体，比如(ab){1,2}对应的就是ab或abab。</li><li>我们也可以将多条表达式组合起来，如a{2}b{2}就是指匹配a两次后再匹配b两次,即匹配aabb。</li></ul><h4 id="提交要求-3"><a href="#提交要求-3" class="headerlink" title="提交要求"></a>提交要求</h4><p>使用Logisim搭建一个Mealy型有限状态机 检测串行输入字符串中的能匹配正则表达式b{1,2}[ac]{2}的子串并输出。具体模块端口定义如下：</p><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>In[1:0]</td><td>I</td><td>串行方式输入字符串。 为简化电路，我们规定 00 表示 ‘a’，01 表示 ‘b’，10 表示 ‘c’，11 表示其他字符。</td></tr><tr><td>CLR</td><td>I</td><td>清除置位信号</td></tr><tr><td>Z</td><td>O</td><td>输出是否检测到了与表达式匹配的子串 1：检测到了 0：未检测到</td></tr></tbody></table></div><p>模块功能定义如下：</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/9-2.png" class="" title="9-2"><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名: fsm</li><li><strong>注意: 每当匹配到一个子串时，需要输出一次1。例如对字符串bacbacac,模块应当在第1个c输入和第2个c输入时输出1,而在其他时刻保持输出为0。</strong></li><li><strong>注意：有限状态机的设计是Mealy型有限状态机。</strong></li><li>测试电路如下：(code部分是你需要搭建的电路)</li></ul><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/9-3.png" class="" title="9-3"><ul><li><strong>注意:请保证模块的appearance与下图完全一致，否则有可能造成评测错误</strong>(查看模块appearance方法:在Logisim中打开相应模块后点击左上角</li></ul><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/9-5.png" class="" title="95.png"><h3 id="P0-L1-ftoi：ftoi-附加题"><a href="#P0-L1-ftoi：ftoi-附加题" class="headerlink" title="P0_L1_ftoi：ftoi(附加题)"></a>P0_L1_ftoi：ftoi(附加题)</h3><p>本题为附加题，通过与否不计入P0课下通过条件。</p><h4 id="提交要求-4"><a href="#提交要求-4" class="headerlink" title="提交要求"></a>提交要求</h4><p>使用Logisim进行组合逻辑设计，要求输入一个16位的单精度浮点数（符合IEEE-754标准），输出该浮点数的整数部分(包含符号)，用32位二进制符号数表示。具体说明如下：</p><p>IEEE-754 标准中一个半精度16位浮点数的表示方法:</p><script type="math/tex; mode=display">V_{float}=(-1)^S \times M \times 2^E</script><p>利用这种浮点数表示方法进行编码后的值可以分为4类，如下图所示</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/319-1.png" class="" title="319-1"><ul><li><p>S代表最高位符号位，由sign[15]位编码，规定$S=sign$；</p></li><li><p>E代表指数，由图中exponent[14:10]域编码，规定<strong>补码</strong>$E=exponent-01111_2$</p></li><li><p>M代表小数点后的二进制小数位，由图中frac[9:0]域编码，Normalized的情况$M$永远有一位前导1，因此不占位，相当于$1 + frac$；而Denormalized的情况$frac$前面是$0$，$M$默认就是$frac$，即规定</p><script type="math/tex; mode=display">M = \begin{cases}1+frac, & exponent \neq 0 \\frac, & exponent = 0\end{cases}</script></li></ul><p>Normalized例子：</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/319-2.png" class="" title="319-2"><p>Denormalized例子：</p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/319-3.png" class="" title="319-3"><p>模块端口定义如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">float[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位半精度浮点数（IEEE-754标准）</td></tr><tr><td style="text-align:center">int[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">该浮点数的整数部分（带符号），用32位符号数的补码来表示，超出表示范围则取低32位。 <strong>第3类Infinity和第4类NaN为了简化直接输出0即可</strong></td></tr></tbody></table></div><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名: <strong>ftoi</strong></li><li>测试电路：</li></ul><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/319-4.png" class="" title="319-4"><ul><li><strong>注意:请保证模块的appearance与下图完全一致，否则有可能造成评测错误</strong>(查看模块appearance方法:在Logisim中打开相应模块后点击左上角</li></ul><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/319-6.png" class="" title="3196.png"><h2 id="5-个人解答-思路总结"><a href="#5-个人解答-思路总结" class="headerlink" title="5.个人解答-思路总结"></a>5.个人解答-思路总结</h2><h3 id="T1-CRC"><a href="#T1-CRC" class="headerlink" title="T1.CRC"></a>T1.CRC</h3><p>本题给了详细的思路引导，只要实现教程上说的就行，注意细节和仔细读题就行。搭建过程中有不少重复模块，也并非一道很简单的题。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>先设计四位模二除法器，如果$A$最高位为$0$，输出的商为$0$，余数为$A$本身；否则商为$1$，余数为$A\oplus B$。这里涉及到选择语句，我们需要把可能的情况均算出来接到$MUX$上，商和除数前各一个$MUX$，选择端为$A[3]$。</li><li>再设计顶层模块，将八位后面部三个$0$，进行类似于除法竖式的操作，每次余数三位再把后面一位取下来，一共需要进行$8$次，调用$8$次$4div4$模块。商对我们没有用处，只需将三位余数和被除数的下一位用分线器合在一起引入下一$4div4$层即可。</li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>1.记得补三个$0$！否则测评数据点会恰好错一个位。体现了读题的重要性。往往开始做题又会忘掉一些细节。</p><p>2.用好Tunnel，但不要过多。不要一眼望过去全是Tunnel，尽量“线比隧道多”。</p><h4 id="Logisim源文件与连线截图"><a href="#Logisim源文件与连线截图" class="headerlink" title="Logisim源文件与连线截图"></a>Logisim源文件与连线截图</h4><p><a href="https://github.com/pppphop/pppphop.github.io/blob/main/blog files/crc.circ">crc.circ</a></p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251012201301017.png" class="" title="image-20251012201301017"><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251012201317373.png" class="" title="image-20251012201317373"><h3 id="T2-GRF"><a href="#T2-GRF" class="headerlink" title="T2.GRF"></a>T2.GRF</h3><p>乍一看本题让人非常为难、难以下手：什么？要我摆32个寄存器？还要选择输入输出，还有使能信号？不禁让人皱起眉头。事实上，我们理清思路，或者“先做好一定要做的”，一步步来不要畏惧，会发现这是一道很简单的题。</p><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>摆上32个寄存器，因为元件多，所以我们一点要注重外观的整齐，不会到后面一团乱麻，建议$8\times4$排列。</li><li>然后我们处理输出，这个不存在使能，有$A1$，$A2$就有$RD1$，$RD2$输出。那么“指定输出低$i$个寄存器里的值”，即输出序号为$i$的寄存器里的值，要怎么实现？我们要将$32$个寄存器的输出端均接到一个$MUX$上，$A1$信号作为选择断即可。$A2$和$RD2$同理。只是连线确实多，需要一点耐心。</li><li>输入的使能和选择怎么办？我们用好寄存器的使能端。这应该是迄今为止第一次用上寄存器使能端。有很多种方法，比如在每个寄存器使能端前面放个比较器，结果和$WE$与起来连上去，是可行的，但是繁琐复杂凌乱。我们选择使用与$MUX$对应的$DEMUX$，把$WE$接输入$A3$接选择端就行。</li></ol><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>善用Tunnel，本题Tunnel不怕多，不可能把32条线全部引出来连在$MUX$上；</li><li>$0$号寄存器始终为$0$，也就是$WD$不接入$0$号寄存器的D端，而是接入<code>32&#39;b0</code>；</li><li>巧用Ctrl C+V，可以将寄存器设置好后，$1\rightarrow 2 \rightarrow 4 \rightarrow 8 \rightarrow 16 \rightarrow 32$，就能迅速搞定这32个寄存器。Tunnel也可以复制粘贴，每次改一下标签。</li></ol><h4 id="Logisim源文件与连线截图-1"><a href="#Logisim源文件与连线截图-1" class="headerlink" title="Logisim源文件与连线截图"></a>Logisim源文件与连线截图</h4><p><a href="https://github.com/pppphop/pppphop.github.io/blob/main/blog files/grf.circ">grf.circ</a></p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251013142829715.png" class="" title="image-20251013142829715"><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251013142901730.png" class="" title="image-20251013142901730"><h3 id="T3-Navigation"><a href="#T3-Navigation" class="headerlink" title="T3.Navigation"></a>T3.Navigation</h3><p>本题是最常规的一道题，就是普通的Moore型有限状态机，真值表生成状态转移电路。</p><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>真值表生成$status_{next}$和$hit$；</li><li>$3$位寄存器存$status_{now}$，初值为$0$故无需赋初值；</li><li>分线器将输入的$dir$和$status<em>{now}$传入状态转移模块，得到$status</em>{next}$和$hit$；</li><li>因为$hit$需要保持一拍，所以传入一个寄存器再输出。</li></ol><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>状态转移模块的$hit$应该是“如果走下一拍是不是在墙里面”，这样通过寄存器缓一拍是刚好的。</li><li>当前寄存器的值为$4$时输出$arrival=1$，其余时候保持$0$。</li><li>仔细读题，“到达B机房后计小组将会在下一周期回到原点，（下一周期的输入将被忽略掉）”所以我们这么做是没有问题的，相当于他在$B$还是停留了一拍，这一拍用来输出$arrival=1$，也体现了这是个Moore型有限状态机</li></ol><h4 id="Logisim源文件与连线截图-2"><a href="#Logisim源文件与连线截图-2" class="headerlink" title="Logisim源文件与连线截图"></a>Logisim源文件与连线截图</h4><p><a href="https://github.com/pppphop/pppphop.github.io/blob/main/blog files/navigation.circ">navigation.circ</a></p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251013145400358.png" class="" title="image-20251013145400358"><h3 id="T4-FSM"><a href="#T4-FSM" class="headerlink" title="T4.FSM"></a>T4.FSM</h3><p>这是很常见的Mealy型状态机，但是想要一次搭对并不简单，难点和易错点其实在同步复位。</p><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>真值表生成状态转移电路；</li><li>状态仅$0$，$1$，$2$，三种，当$status_{now}=2$且$in=0或2$时输出$Z=1$，这体现了本题是Mealy型状态机，与输入有关</li><li>接入同步复位，具体步骤见注意事项。</li></ol><h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>同步复位不能！直接将$clk$和$reset$与起来接到寄存器的$reset$端！不信可以自己试验一下。正确步骤是，将$reset$取反（默认高电平时复位），再进行符号扩展，与正常要输入到寄存器的内容与起来再连到D端；</li><li>$reset$取反后扩展的位数和寄存器位数保持一致</li><li>本题刚开始连的时候你会感到奇怪，怎么没有输入$clk$信号？那么就是我们从组件中直接拿出$Clock$就行了。</li></ol><h4 id="Logisim源文件与连线截图-3"><a href="#Logisim源文件与连线截图-3" class="headerlink" title="Logisim源文件与连线截图"></a>Logisim源文件与连线截图</h4><p><a href="https://github.com/pppphop/pppphop.github.io/blob/main/blog files/fsm.circ">fsm.circ</a></p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251013170526900.png" class="" title="image-20251013170526900"><h3 id="T5-ftoi"><a href="#T5-ftoi" class="headerlink" title="T5.ftoi"></a>T5.ftoi</h3><p>一道组合逻辑，难！不愧是附加题，对于我这种比较蠢的，相当于跳出了我的“舒适圈”，看到题就无处下手了。放在高中，这算是一道“新定义”题。个人觉得题目其实挺难读懂的，比如取整数是个什么取法。但我朋友都说还好。</p><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>一步步来，先将输入的$float$拆成三部分，$sign$，$exp$，$frac$；</li><li>我们判断他是$Normal$，$Denormal$，$Inf$，还是$NaN$。我这里用两个$MUX$来判断，选择端是比较器的结果，输入端是常数$0$，$1$，$2$，得到判断类型的$fl$；</li><li>Normalized要在$frac$开头拼接$1$，Denormalized则不需要。因为后续要接入$MUX$，所以两种都要写（后者其实没动，实际上不用写）；</li><li>把$E=exp-01111_2$算出，$E$的最高位代表$2$的幂次是正是负，设为$neg$；</li><li>如果$neg=1$，$E$在有符号意义下为负，则应该右移，否则左移，我们用移位器完成这两个板块，并接到一个$MUX$上，选择端是$neg$；</li><li>将这时候两种情况的都右移$10$位，实现取整的功能；</li><li>根据$sign$决定是否要取负数就行了。我这一步做的比较复杂，用的取反加一，其实可以直接使用Negator。</li></ol><h4 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>取整数不是取整，-0.0028取整数部分就是0，0.625取整数也是0，不要搞复杂了。</li><li>左移右移需将$frac$扩展至$32$位</li></ol><h4 id="Logisim源文件与连线截图-4"><a href="#Logisim源文件与连线截图-4" class="headerlink" title="Logisim源文件与连线截图"></a>Logisim源文件与连线截图</h4><p><a href="https://github.com/pppphop/pppphop.github.io/blob/main/blog files/ftoi.circ">ftoi.circ</a></p><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251013180659668.png" class="" title="image-20251013180659668"><img src="/posts/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251013180713158.png" class="" title="image-20251013180713158">]]></content>
    
    
    <categories>
      
      <category>CO课下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>CO课下</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
