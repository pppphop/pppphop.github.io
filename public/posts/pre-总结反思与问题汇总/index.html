<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Pre-总结反思与问题汇总 | pppphop的学习博客</title>
<meta name="keywords" content="">
<meta name="description" content="Pre-总结反思与问题汇总
T1.推箱子-Logisim
出现了严重的失误，花了两个多小时导致道心破碎，甚至一度想“大不了爆零吧”。主要需要反思以下几点：

平常“真值表生成状态机&quot;的轮椅题做的太多了，往往没有过多的输入输出设计，导致看到题目第一眼是懵的，甚至还在想怎么设计状态转移图和真值表，“难道要三十个状态吗”，对较新颖的题型不熟练导致没有做题的底气，对于$flag$保持一周的创新点也处理的略微慌张；
对早晚一拍概念不清晰，是拿$x$比较还是拿$xnext$比较，到考试结束前五分钟甚至都没有意识到这个问题；
看到$flag$要保持一拍，确实很快想到了要用寄存器，但心里不踏实的感觉，有点不敢实践，总想“先不管交一交看一看&quot;，后面用寄存器还是没过，我就以为自己想法错了，开始一阵瞎改，把状态机模块的$flag$直接废除不用了，丝毫没有意识到是$out$的问题；
不会自动化测试，手动点在考场紧张的环境下，有时候输出错了也没发现，精神高度紧张可能忽略掉一些东西，有空可以学一学有没有更好的测试方式；
值得夸奖的是我的状态转移模块一般就写对了，没有更多的更改，而且我做的很从容淡定有自信，可能是考试刚开始还很冷静。

本题的解题思路:
先设计状态转移模块$fsm$，用$tunnel$表示$x$,$x&#43;dx$,$y$,$y&#43;dy$，判断$x&#43;dx$是否$&gt;5$，$y&#43;dy$是否$&gt;5$，以及$x$，$y$是否同时等于那六个障碍物的$x$，$y$坐标，将这些或起来，便是我们想要的实时的下一拍的$flag$。当然，作为组合逻辑，我们本就只能输出实时的，&ldquo;保持一拍&quot;得在主电路里实现。注意：$dx$，$dy$要进行零扩展变成三位，比较器一定要选$Unsigned$。
然后设计主电路，首先两个$3$位寄存器分别存$x$，$y$当下的值，与$dx$，$dy$一同传入$fsm$模块，得到的$flag$在寄存器中缓一拍输出，既实现了将$fsm$模块中对$x&#43;dx$，$y&#43;dy$判断导致的“早一拍”问题，又实现了无$reset$信号时保持一拍，有$reset$立马清零的效果。至于$out$就更简单了，使用比较器判断当前$x$，$y$（可以从寄存器$Q$端引出隧道）是否都为0即可，组合逻辑。
[Pre-T1-电路文件](https://github.com/pppphop/pppphop.github.io/blob/main/blog files/T1.circ)
T2.Roll-Verilog
暴露了我Verilog已经几近与忘光了的事实。太久没写，没地方可以评测，没有什么有创新点的题目，对一些稍微进阶的语言技巧都记不太清不敢用。总结一下当中遇到的各种问题：

$for$循环怎么写都不会了？是在什么模块里面能写？晚些时候一定要查证一下，在我印象中是$tb$文件的$initial$用的多，要提交的文件应该是尽量不要用$initial$，不能综合还是什么？时序逻辑里不能$for$吗？组合逻辑可以？这次只有$assign$我用着放心，得亏是简单的组合逻辑；（查证：组合逻辑和时序逻辑都可使用可综合的$for$循环，用在$always$块里即可）
$wire$的拼接，用大括号，从高位到低位，考场上甚至不确定；
数组的定义方式！不是像$C$语言一样$a[8]$，应该是$a[7:0]$这种？晚点查证一下；（查证后回答：应是$a[0:7]$）
最初居然定义$reg$类型，明显这里都用$wire$就好，顶多循环变量用$reg$，说明基本概念还没有炉火纯青，虽然看到报错能立马意识到；
$testbench$中要不要用$initial$，感觉这还是我第一次直接$assign$，两行就写完了。看向巨的反应我应该写的不对。不确定是不是最好的写法。而且实例化的写法有点忘了，结合报错试探了好几下；（查证：实现一次测试完给的两个测试点，要用$initial$，还是用$initial$比较好，组合逻辑的$testbench$无需$clk$，但是也要延迟10s）
对于一部分报错信息看不懂，看到反倒懵了，还是得多练。

本题解题思路：
这题很简单，哪怕设$8&#43;8$个变量然后各种复制粘贴$assign$也是能过的。但是本题的目的是让你学如何使用$for$循环，以及&rdquo;-：&ldquo;的使用。那么首先这是一道组合逻辑，由输入和逻辑运算直接得到输出，具体操作都给你了，按操作翻译一遍就行，当然我们在写循环的过程中，难免遇到一些问题：
循环变量用什么？在always外面设integer

$for$放在哪？放在always @(*)里面
数组是怎么定义的？wire [3:0] a[0:7]
注意$i&#43;&#43;$会报错，Verilog没有这种语法，要用$i=i&#43;1$
如果直接arr[i]=a[(i &#43; 1) * 4 - 1-:i*4]，会收到报错：$i\ is\ not\ a\ constant$。其实并不是要求中括号内非得都是常数，只要冒号左右两边不全为变量就行。于是我们学会使用[i-:4]，意思是往低里取从$i$开始$4$个位。

最后将sum[i]用大括号拼接起来，assign给$out$就行了。代码及其$testbench$见下：
module roll(
    input [31:0] a,
    output [31:0] out
    );
reg [3:0] arr[0:7],sum[0:7],tmp;
integer i,j;
always @(*) begin
	for(i=0;i&lt;8;i=i&#43;1) begin
		arr[i]=a[(i &#43; 1) * 4 - 1-:4];
	end
	sum[0]=arr[0];
	for(i=0;i&lt;7;i=i&#43;1) begin
		sum[i&#43;1]=sum[i]&#43;arr[i&#43;1];
	end
end
assign out={sum[7],sum[6],sum[5],sum[4],sum[3],sum[2],sum[1],sum[0]};
endmodule
module tbroll(
    );
reg [31:0] a;
wire [31:0] out;
initial begin
	a=32&#39;h11111111;
	#10;
	a=32&#39;h87654321;
	#10;
end
roll r(a,out);
endmodule
T3.Submatrix-MIPS
整体写法和常用指令确实记得，但是很多地方也不熟练或遗忘了。总结问题如下：">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/pre-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E4%B8%8E%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a2a8fbfe66409783744e00a45f98f95fcd69ac556aa3eeabdfebaa8e8667fc1c.css" integrity="sha256-oqj7/mZAl4N0TgCkX5j5X81prFVqo&#43;6r3&#43;uqjoZn/Bw=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/pre-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E4%B8%8E%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      tags: 'ams'
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script" async></script>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="pppphop的学习博客 (Alt + H)">pppphop的学习博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Pre-总结反思与问题汇总
    </h1>
    <div class="post-meta"><span title='2025-10-20 14:35:01 +0800 CST'>October 20, 2025</span>

</div>
  </header> 
  <div class="post-content"><h1 id="pre-总结反思与问题汇总">Pre-总结反思与问题汇总<a hidden class="anchor" aria-hidden="true" href="#pre-总结反思与问题汇总">#</a></h1>
<h3 id="t1推箱子-logisim">T1.推箱子-Logisim<a hidden class="anchor" aria-hidden="true" href="#t1推箱子-logisim">#</a></h3>
<p>出现了严重的失误，花了两个多小时导致道心破碎，甚至一度想“大不了爆零吧”。主要需要反思以下几点：</p>
<ol>
<li>平常“真值表生成状态机&quot;的轮椅题做的太多了，往往没有过多的输入输出设计，导致看到题目第一眼是懵的，甚至还在想怎么设计状态转移图和真值表，“难道要三十个状态吗”，对较新颖的题型不熟练导致没有做题的底气，对于$flag$保持一周的创新点也处理的略微慌张；</li>
<li>对<strong>早晚一拍概念不清晰</strong>，是拿$x$比较还是拿$xnext$比较，到考试结束前五分钟甚至都没有意识到这个问题；</li>
<li>看到$flag$要保持一拍，确实很快想到了要用<strong>寄存器</strong>，但心里不踏实的感觉，有点不敢实践，总想“先不管交一交看一看&quot;，后面用寄存器还是没过，我就以为自己想法错了，开始一阵瞎改，把状态机模块的$flag$直接废除不用了，丝毫没有意识到是$out$的问题；</li>
<li>不会<strong>自动化测试</strong>，手动点在考场紧张的环境下，有时候输出错了也没发现，精神高度紧张可能忽略掉一些东西，有空可以学一学有没有更好的测试方式；</li>
<li>值得夸奖的是我的状态转移模块一般就写对了，没有更多的更改，而且我做的很从容淡定有自信，可能是考试刚开始还很冷静。</li>
</ol>
<p>本题的解题思路:</p>
<p>先设计状态转移模块$fsm$，用$tunnel$表示$x$,$x+dx$,$y$,$y+dy$，判断$x+dx$是否$&gt;5$，$y+dy$是否$&gt;5$，以及$x$，$y$是否同时等于那六个障碍物的$x$，$y$坐标，将这些或起来，便是我们想要的<strong>实时的下一拍的</strong>$flag$。当然，作为组合逻辑，我们本就只能输出实时的，&ldquo;保持一拍&quot;得在主电路里实现。注意：$dx$，$dy$要进行<strong>零扩展</strong>变成三位，比较器一定要选$Unsigned$。</p>
<p>然后设计主电路，首先两个$3$位寄存器分别存$x$，$y$当下的值，与$dx$，$dy$一同传入$fsm$模块，得到的$flag$在寄存器中<strong>缓一拍</strong>输出，既实现了将$fsm$模块中对$x+dx$，$y+dy$判断导致的“早一拍”问题，又实现了无$reset$信号时保持一拍，有$reset$立马清零的效果。至于$out$就更简单了，使用比较器判断当前$x$，$y$（可以从寄存器$Q$端引出隧道）是否都为0即可，组合逻辑。</p>
<p>[Pre-T1-电路文件](<a href="https://github.com/pppphop/pppphop.github.io/blob/main/blog">https://github.com/pppphop/pppphop.github.io/blob/main/blog</a> files/T1.circ)</p>
<h3 id="t2roll-verilog">T2.Roll-Verilog<a hidden class="anchor" aria-hidden="true" href="#t2roll-verilog">#</a></h3>
<p>暴露了我Verilog已经几近与忘光了的事实。太久没写，没地方可以评测，没有什么有创新点的题目，对一些稍微进阶的语言技巧都记不太清不敢用。总结一下当中遇到的各种问题：</p>
<ol>
<li>$for$循环怎么写都不会了？是在什么模块里面能写？晚些时候一定要查证一下，在我印象中是$tb$文件的$initial$用的多，要提交的文件应该是尽量不要用$initial$，不能综合还是什么？时序逻辑里不能$for$吗？组合逻辑可以？这次只有$assign$我用着放心，得亏是简单的组合逻辑；（查证：<strong>组合逻辑</strong>和<strong>时序逻辑</strong>都可使用可综合的$for$循环，用在$always$块里即可）</li>
<li>$wire$的拼接，用大括号，<strong>从高位到低位</strong>，考场上甚至不确定；</li>
<li><strong>数组的定义方式</strong>！不是像$C$语言一样$a[8]$，应该是$a[7:0]$这种？晚点查证一下；（查证后回答：应是$a[0:7]$）</li>
<li>最初居然定义$reg$类型，明显这里都用$wire$就好，顶多循环变量用$reg$，说明基本概念还没有炉火纯青，虽然看到报错能立马意识到；</li>
<li>$testbench$中要不要用$initial$，感觉这还是我第一次直接$assign$，两行就写完了。看向巨的反应我应该写的不对。不确定是不是最好的写法。而且实例化的写法有点忘了，结合报错试探了好几下；（查证：实现一次测试完给的两个测试点，要用$initial$，还是用$initial$比较好，组合逻辑的$testbench$<strong>无需$clk$</strong>，但是也要延迟10s）</li>
<li>对于一部分报错信息看不懂，看到反倒懵了，还是得多练。</li>
</ol>
<p>本题解题思路：</p>
<p>这题很简单，哪怕设$8+8$个变量然后各种复制粘贴$assign$也是能过的。但是本题的目的是让你学如何使用$for$循环，以及&rdquo;-：&ldquo;的使用。那么首先这是一道组合逻辑，由输入和逻辑运算直接得到输出，具体操作都给你了，按操作翻译一遍就行，当然我们在写循环的过程中，难免遇到一些问题：</p>
<p><strong>循环变量</strong>用什么？在<code>always</code>外面设<code>integer</code></p>
<ol>
<li>$for$放在哪？放在<code>always @(*)</code>里面</li>
<li>数组是怎么定义的？<code>wire [3:0] a[0:7]</code></li>
<li>注意$i++$会报错，Verilog没有这种语法，要用$i=i+1$</li>
<li>如果直接<code>arr[i]=a[(i + 1) * 4 - 1-:i*4]</code>，会收到报错：$i\ is\ not\ a\ constant$。其实并不是要求中括号内非得都是常数，<strong>只要冒号左右两边不全为变量就行</strong>。于是我们学会使用<code>[i-:4]</code>，意思是<strong>往低里取从$i$开始$4$个位</strong>。</li>
</ol>
<p>最后将<code>sum[i]</code>用<strong>大括号拼接</strong>起来，<code>assign</code>给$out$就行了。代码及其$testbench$见下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">module</span> roll(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">input</span> [<span style="color:#ae81ff">31</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">output</span> [<span style="color:#ae81ff">31</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] out
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">reg</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] arr[<span style="color:#ae81ff">0</span><span style="color:#f92672">:</span><span style="color:#ae81ff">7</span>],sum[<span style="color:#ae81ff">0</span><span style="color:#f92672">:</span><span style="color:#ae81ff">7</span>],tmp;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">integer</span> i,j;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always</span> @(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">8</span>;i<span style="color:#f92672">=</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>		arr[i]<span style="color:#f92672">=</span>a[(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">-:</span><span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>	sum[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span>arr[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">7</span>;i<span style="color:#f92672">=</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>		sum[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>sum[i]<span style="color:#f92672">+</span>arr[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assign</span> out<span style="color:#f92672">=</span>{sum[<span style="color:#ae81ff">7</span>],sum[<span style="color:#ae81ff">6</span>],sum[<span style="color:#ae81ff">5</span>],sum[<span style="color:#ae81ff">4</span>],sum[<span style="color:#ae81ff">3</span>],sum[<span style="color:#ae81ff">2</span>],sum[<span style="color:#ae81ff">1</span>],sum[<span style="color:#ae81ff">0</span>]};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">endmodule</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">module</span> tbroll(
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">reg</span> [<span style="color:#ae81ff">31</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">31</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] out;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">initial</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>	a<span style="color:#f92672">=</span><span style="color:#ae81ff">32&#39;h11111111</span>;
</span></span><span style="display:flex;"><span>	#<span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>	a<span style="color:#f92672">=</span><span style="color:#ae81ff">32&#39;h87654321</span>;
</span></span><span style="display:flex;"><span>	#<span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>roll r(a,out);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">endmodule</span>
</span></span></code></pre></div><h3 id="t3submatrix-mips">T3.Submatrix-MIPS<a hidden class="anchor" aria-hidden="true" href="#t3submatrix-mips">#</a></h3>
<p>整体写法和常用指令确实记得，但是很多地方也不熟练或遗忘了。总结问题如下：</p>
<ol>
<li>不记得宏定义怎么写了，那些找矩阵下标，输入输出，平常复制粘贴惯了，国庆好好记一下；</li>
<li>由于天天复制粘贴宏定义，导致输入输出也不熟练，甚至完全遗忘了字符串是怎么输出的，还好在$help$文档里翻到了一处$la$提醒了我；</li>
<li>助教问答环节回答的不是很理想，要注意记一下各个<strong>寄存器的作用</strong>；</li>
<li>中间错误的想要用乘法，发现不会用，对乘除的$HI$，$LO$<strong>怎么分配</strong>，要再看一看，记一下并实战应用一下；</li>
<li>这次有时间不够的原因，做的很匆忙思路都没成型，导致删删改改很多，之后要整体<strong>构思</strong>好；</li>
</ol>
<p>本题解题思路:</p>
<p>没有递归和函数调用，所以是一道比较简单的MIPS题，考验你基本的输入输出，宏定义，寻址，循环等内容。可以不用写出C语言代码直接写。首先我们要能熟练的写出那些常用的宏定义，平常的练习中经常直接复制粘贴，可上机考试的时候没有办法投机取巧，只能自己老老实实打，这个时候像我一样忘了怎么输出字符串就很致命了。我们需要给矩阵开至少$4\times 4\times 4$的空间，用<code>asciiz</code>定义空格，换行与<code>&quot;Out of bounds&quot;</code>。输入循环$16$次，用$beq$跳出。先用<code>bgt</code>判断$i+m$和$j+n$是否存在$&gt;4$的情况，有就跳转到<code>error</code>，直接输出报错的字符串就行。接着往后写二重循环，外层从$i$到$i+m-1$，内层由$j$到$j+m-1$，注意不要漏掉</p>
<ol>
<li>每个循环末尾$j$指令</li>
<li>$j$指令前将循环变量$+1$</li>
<li>外层循环每次回到开头进入新一轮循环，将内层循环变量<strong>复位</strong></li>
<li>内层循环每输出一个数输出一个空格</li>
<li>外层循环$j$前输出换行符</li>
</ol>
<p>至于寄存器的作用：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">寄存器编号</th>
          <th style="text-align: left">助记符</th>
          <th style="text-align: left">名称</th>
          <th style="text-align: left">用途</th>
          <th style="text-align: left">是否在调用中保持</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>零寄存器</strong></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">0</td>
          <td style="text-align: left"><code>$zero</code></td>
          <td style="text-align: left">常数零</td>
          <td style="text-align: left">其值恒为0，读取它总是返回0，写入它无效。</td>
          <td style="text-align: left">不适用</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>保留寄存器</strong></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">1</td>
          <td style="text-align: left"><code>$at</code></td>
          <td style="text-align: left">汇编临时寄存器</td>
          <td style="text-align: left">被汇编器保留，用于处理大的立即数或地址加载（如 <code>lui</code> 指令）。<strong>程序员不应直接使用。</strong></td>
          <td style="text-align: left">否</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>返回值寄存器</strong></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">2-3</td>
          <td style="text-align: left"><code>$v0</code> - <code>$v1</code></td>
          <td style="text-align: left">值寄存器</td>
          <td style="text-align: left">用于存放<strong>函数调用的返回值</strong>。如果返回值大小超过一个寄存器（如64位整数），则使用 <code>$v0</code> 和 <code>$v1</code> 共同存放。</td>
          <td style="text-align: left">否</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>参数寄存器</strong></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">4-7</td>
          <td style="text-align: left"><code>$a0</code> - <code>$a3</code></td>
          <td style="text-align: left">参数寄存器</td>
          <td style="text-align: left">用于向函数传递<strong>前四个参数</strong>。如果参数多于四个，超出的部分会通过栈来传递。</td>
          <td style="text-align: left">否</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>临时寄存器</strong></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">8-15</td>
          <td style="text-align: left"><code>$t0</code> - <code>$t7</code></td>
          <td style="text-align: left">临时寄存器</td>
          <td style="text-align: left">用于存放<strong>临时变量</strong>。在函数调用中，这些寄存器的值<strong>不保证</strong>被调用者保存。如果调用函数后还需要这些值，调用者必须自己保存。</td>
          <td style="text-align: left">否</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>保存寄存器</strong></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">16-23</td>
          <td style="text-align: left"><code>$s0</code> - <code>$s7</code></td>
          <td style="text-align: left">保存寄存器</td>
          <td style="text-align: left">用于存放<strong>需要跨函数调用保留的局部变量</strong>。如果一个函数使用了这些寄存器，它<strong>必须</strong>在函数开始时保存它们的原始值（通常在栈上），并在函数返回前恢复它们。</td>
          <td style="text-align: left">是</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>更多临时寄存器</strong></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">24-25</td>
          <td style="text-align: left"><code>$t8</code> - <code>$t9</code></td>
          <td style="text-align: left">临时寄存器</td>
          <td style="text-align: left">与 <code>$t0-$t7</code> 作用相同，是额外的临时寄存器。</td>
          <td style="text-align: left">否</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>内核寄存器</strong></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">26-27</td>
          <td style="text-align: left"><code>$k0</code> - <code>$k1</code></td>
          <td style="text-align: left">内核保留寄存器</td>
          <td style="text-align: left">专门为<strong>操作系统内核</strong>（如中断和异常处理程序）保留。应用程序<strong>不应使用</strong>这些寄存器。</td>
          <td style="text-align: left">否</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>全局指针寄存器</strong></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">28</td>
          <td style="text-align: left"><code>$gp</code></td>
          <td style="text-align: left">全局指针</td>
          <td style="text-align: left">指向静态数据区（存储全局变量和静态变量）的中间位置。通过 <code>$gp</code> 可以更方便地用单条指令访问64KB范围内的全局数据，而不需要每次都使用 <code>lui</code> 和 <code>ori</code> 两条指令。</td>
          <td style="text-align: left">是</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>栈指针寄存器</strong></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">29</td>
          <td style="text-align: left"><code>$sp</code></td>
          <td style="text-align: left">栈指针</td>
          <td style="text-align: left">指向运行时栈的顶部。栈用于存放函数返回地址、保存的寄存器、局部变量等。<code>$sp</code> 必须按字（4字节）对齐。</td>
          <td style="text-align: left">是</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>帧指针寄存器</strong></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">30</td>
          <td style="text-align: left"><code>$fp</code> 或 <code>$s8</code></td>
          <td style="text-align: left">帧指针</td>
          <td style="text-align: left">指向当前函数栈帧的底部。它提供了一个固定的参考点，方便访问栈上的参数和局部变量，尤其是在栈指针 <code>$sp</code> 动态变化时。虽然它被列为 <code>$s8</code>，但其作用更像一个专用的帧指针。</td>
          <td style="text-align: left">是</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>返回地址寄存器</strong></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">31</td>
          <td style="text-align: left"><code>$ra</code></td>
          <td style="text-align: left">返回地址</td>
          <td style="text-align: left">当使用 <code>jal</code>（跳转并链接）指令调用函数时，下一条指令的地址（返回地址）会自动存入 <code>$ra</code>。函数结束时通常通过 <code>jr $ra</code> 指令返回到调用点。</td>
          <td style="text-align: left">否</td>
      </tr>
  </tbody>
</table>
<p>完整代码见下，宏定义板子也可自取：</p>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">.macro end
	li $v0,10
	syscall
.end_macro 

.macro getInt(%des)
	li $v0,5
	syscall 
	move %des,$v0
.end_macro 
	
.macro printInt(%src)
	move $a0,%src
	li $v0,1
	syscall 
.end_macro 

.macro printStr(%src)
	la $a0,%src
	li $v0,4
	syscall 
.end_macro 

.macro push(%src)
	addi $sp,$sp,-4
	sw %src 0($sp)
.end_macro 

.macro getIndex(%src1,%src2,%des)
	sll %des,%src1,2
	add %des,%des,%src2
	sll %des,%des,2
.end_macro 

.data
	a: .space 100
	space: .asciiz &#34; &#34;
	nxtline: .asciiz &#34;\n&#34;
	err: .asciiz &#34;Out of bounds&#34;

.text
li $s0,16
li $t0,0
for_in:
	beq $t0,$s0,for_in_end
	getInt($t1)
	sll $t2,$t0,2
	sw $t1 a($t2)
	addi $t0,$t0,1
	j for_in

for_in_end:
getInt($s1)					#s1=m
getInt($s2)					#s2=n
getInt($s3)					#s3=i
getInt($s4)					#s4=j

add $t4,$s1,$s3
add $t5,$s2,$s4
bgt $t4,4,error
bgt $t5,4,error

move $t0,$s3
for_i:
	beq $t0,$t4,for_i_end
	move $t1,$s4
	for_j:
		beq $t1,$t5,for_j_end
		getIndex($t0,$t1,$t2)
		lw $t3,a($t2)
		printInt($t3)
		printStr(space)
		addi $t1,$t1,1
		j for_j
	for_j_end:
		addi $t0,$t0,1
		printStr(nxtline)
		j for_i
for_i_end:
	end

error:
	printStr(err)
end
														
</code></pre><p>下面附本次上机题目：</p>
<p>（注：本次上机全部做对才算通过）</p>
<h1 id="t1-推箱子">T1-推箱子<a hidden class="anchor" aria-hidden="true" href="#t1-推箱子">#</a></h1>
<p>独小星在玩一个简化版的推箱子游戏，请你设计一个状态机，根据输入来判断箱子是否被推到了目标点并输出。</p>
<h2 id="提交要求">提交要求<a hidden class="anchor" aria-hidden="true" href="#提交要求">#</a></h2>
<h3 id="任务要求">任务要求<a hidden class="anchor" aria-hidden="true" href="#任务要求">#</a></h3>
<p>游戏地图建立在一个二维平面直角坐标系中，箱子在游戏开始或每次$reset$后位于$(0,0)$坐标处。推箱子的目标点固定位于$(5,5)$坐标处。</p>
<p>游戏地图大小为：以$(0,0)$为左下角，以$(5,5)$为右上角，边长为$5$的正方形 (共$6\times6=36$个坐标点) 。 位于游戏地图内，当且仅当 。</p>
<p>游戏地图中的坐标点分为墙体和空地。墙体固定为：$(1,1)$ ，$(1,2)$，$(2,1)$，$(4,4)$，$(4,3)$，$(3,4)$ 这 个坐标点。墙体是不可到达区域。</p>
<p>每周期输入一对$(dx,dy)$，表示箱子的移动变化量。若箱子当前坐标为$(x,y)$，则箱子的预期落脚点为$(x+dx,y+dy)$ 。</p>
<p>如果箱子的预期落脚点是合法的 (合法定义见下文) ，则在下一周期更新箱子的坐标为该落脚点。如果箱子的预期落脚点不合法，则将$flag$置为$1$持续一周期，下一周期箱子坐标保持不动。</p>
<p>保证每周期输入的 只会是：$(0,0)$ ，$(1,0)$，$(0,1)$ 这$3$种中的一种。</p>
<p>箱子的预期落脚点是合法的，<strong>当且仅当该落脚点位于游戏地图内，并且该落脚点不是墙体</strong>。</p>
<p>当箱子坐标位于目标点时，输出$out$为$1$ ，否则为$0$。</p>
<p>游戏地图大致如下：</p>
<p><img alt="grid" loading="lazy" src="/images/posts/grid.png"></p>
<h3 id="输入输出">输入输出<a hidden class="anchor" aria-hidden="true" href="#输入输出">#</a></h3>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>功能</th>
          <th>位宽</th>
          <th>方向</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>clk</td>
          <td>时钟信号</td>
          <td>1</td>
          <td>I</td>
      </tr>
      <tr>
          <td>reset</td>
          <td><strong>异步</strong>复位信号</td>
          <td>1</td>
          <td>I</td>
      </tr>
      <tr>
          <td>dx</td>
          <td>坐标移动变化量</td>
          <td>1</td>
          <td>I</td>
      </tr>
      <tr>
          <td>dy</td>
          <td>坐标移动变化量</td>
          <td>1</td>
          <td>I</td>
      </tr>
      <tr>
          <td>out</td>
          <td>箱子是否位于目标点</td>
          <td>1</td>
          <td>O</td>
      </tr>
      <tr>
          <td>flag</td>
          <td>是否尝试移动到非法坐标</td>
          <td>1</td>
          <td>O</td>
      </tr>
  </tbody>
</table>
<ul>
<li><strong>输入</strong>：保证每周期输入的$(dx,dy)$只会是：$(0,0)$ ，$(1,0)$，$(0,1)$ 这$3$种中的一种。</li>
<li><strong>输出</strong>：$flag$默认为$0$，若当前周期箱子尝试移动到非法坐标，则下一周期$flag$置为$1$( 若有$reset$则立刻复位为$1$)。</li>
<li><strong>文件内模块名</strong>: <strong>Sokoban</strong></li>
<li><strong>测试电路图</strong>：</li>
</ul>
<p><img alt="testcirc" loading="lazy" src="/images/posts/testcirc.png"></p>
<ul>
<li><strong>注意：请保证模块的 appearance 与下图一致，否则有可能造成评测错误。注意输入的上下顺序。</strong></li>
</ul>
<p><img alt="fmt" loading="lazy" src="/images/posts/fmt.png"></p>
<h1 id="t2-翻涌数字">T2-翻涌数字<a hidden class="anchor" aria-hidden="true" href="#t2-翻涌数字">#</a></h1>
<h2 id="1简介">1、简介<a hidden class="anchor" aria-hidden="true" href="#1简介">#</a></h2>
<p>给出一个位宽为$32$的输入 ，代表$8$个位宽为$4$的数据，分别命名为$a_0$，$a_1$，…… ，$a_7$ 。</p>
<p>其中$a_i$= $a[(i+1)\times 4 -1:i\times 4]$</p>
<p>对每一个$a_i$进行操作，使得$a_i$= $\sum_{j=0}^{i}a_j$</p>
<p>对操作后得到的$a_i$按原顺序进行拼接，并输出拼接后的$a$。</p>
<p>特别的：若$a_i$相加时出现溢出，则保留对 <code>4'd16</code> 取余后的结果。</p>
<h2 id="2模块规格">2、模块规格<a hidden class="anchor" aria-hidden="true" href="#2模块规格">#</a></h2>
<p>模块名：roll</p>
<table>
  <thead>
      <tr>
          <th>信号名</th>
          <th>方向</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>a[31:0]</td>
          <td>I</td>
          <td>用于计算的数</td>
      </tr>
      <tr>
          <td>out[31:0]</td>
          <td>O</td>
          <td>计算结果</td>
      </tr>
  </tbody>
</table>
<h2 id="3输入输出样例">3、输入输出样例<a hidden class="anchor" aria-hidden="true" href="#3输入输出样例">#</a></h2>
<p><img alt="wave" loading="lazy" src="/images/posts/wave.png"></p>
<p>如图，当 为 <code>32'h11111111</code> 时， 为 <code>32'h87654321</code> 。</p>
<p>当 为 <code>32'h87654321</code> 时， 为 <code>32'h4c5fa631</code> 。</p>
<h2 id="4提交要求">4、提交要求<a hidden class="anchor" aria-hidden="true" href="#4提交要求">#</a></h2>
<ul>
<li>必须严格按照模块的端口名称和方向定义。</li>
<li>文件内模块名： roll</li>
<li>模块内不要包含任何 <code>$display</code> 语句，以防造成误判。</li>
</ul>
<h2 id="t3-mips_submatrix">T3-MIPS_Submatrix<a hidden class="anchor" aria-hidden="true" href="#t3-mips_submatrix">#</a></h2>
<h3 id="功能需求">功能需求<a hidden class="anchor" aria-hidden="true" href="#功能需求">#</a></h3>
<p>实现 MIPS 汇编程序：从 $4 × 4$ 的大矩阵 $A$ 中提取出指定位置指定大小的子矩阵。</p>
<h3 id="输入格式">输入格式<a hidden class="anchor" aria-hidden="true" href="#输入格式">#</a></h3>
<p>第 1 - 16 行依次输入大矩阵 $A$ 的元素 $t$（整数， $0 ≤ t ≤ 100$）：</p>
<ul>
<li>第一行： $A$ 第 0 行第 0 列的元素</li>
<li>第二行： $A$ 第 0 行第 1 列的元素</li>
<li>…… （依此类推）</li>
</ul>
<p>第 17 行输入一个整数 $m$ ，表示子矩阵的行数（$1 ≤ m ≤ 4$）。</p>
<p>第 18 行输入一个整数 $n$ ，表示子矩阵的列数（$1 ≤ n ≤ 4$）。</p>
<p>第 19 行输入一个整数 $i$ ，表示子矩阵的第 0 行第 0 列元素在大矩阵 $A$ 中的行数（$0 ≤ i ≤ 3$）。</p>
<p>第 20 行输入一个整数 $j$ ，表示子矩阵的第 0 行第 0 列元素在大矩阵 $A$ 中的列数（$0 ≤ j ≤ 3$）。</p>
<h3 id="输出格式">输出格式<a hidden class="anchor" aria-hidden="true" href="#输出格式">#</a></h3>
<ol>
<li>若子矩阵完全位于大矩阵内，未超出边界：输出$m*n$子矩阵，共 $m$ 行，每行 $n$ 个元素（空格分隔）。</li>
<li>若超出边界：输出字符串 <code>Out of bounds</code>。</li>
</ol>
<h3 id="约定">约定<a hidden class="anchor" aria-hidden="true" href="#约定">#</a></h3>
<ol>
<li>大矩阵 $A$ 的行索引和列索引从 0 开始编号。</li>
<li>请勿使用 <code>.globl main</code></li>
<li>请使用 <code>syscall</code> 结束程序：</li>
</ol>
<pre tabindex="0"><code class="language-mips" data-lang="mips">li $v0, 10
syscall
</code></pre><h3 id="输入样例-1">输入样例 1<a hidden class="anchor" aria-hidden="true" href="#输入样例-1">#</a></h3>
<pre tabindex="0"><code class="language-none" data-lang="none">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
2
2
1
1
</code></pre><h3 id="输出样例-1">输出样例 1<a hidden class="anchor" aria-hidden="true" href="#输出样例-1">#</a></h3>
<pre tabindex="0"><code class="language-none" data-lang="none">6 7
10 11
</code></pre><h3 id="输入样例-2">输入样例 2<a hidden class="anchor" aria-hidden="true" href="#输入样例-2">#</a></h3>
<pre tabindex="0"><code class="language-none" data-lang="none">4
3
2
1
8
7
6
5
12
11
10
9
13
14
15
16
3
2
2
2
</code></pre><h3 id="输出样例-2">输出样例 2<a hidden class="anchor" aria-hidden="true" href="#输出样例-2">#</a></h3>
<pre tabindex="0"><code class="language-none" data-lang="none">Out of bounds
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">pppphop的学习博客</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
