<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2025-2026计组期末试卷</title>
    <link href="/2026/01/16/2025-2026%E8%AE%A1%E7%BB%84%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7/"/>
    <url>/2026/01/16/2025-2026%E8%AE%A1%E7%BB%84%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="2025-2026-计算机组成原理-期末试卷"><a href="#2025-2026-计算机组成原理-期末试卷" class="headerlink" title="2025-2026 计算机组成原理 期末试卷"></a>2025-2026 计算机组成原理 期末试卷</h1><p>$Sorted ~by ~2406-zhp$</p><h2 id="一、单项选择题（每题-2-分，共-20-分）"><a href="#一、单项选择题（每题-2-分，共-20-分）" class="headerlink" title="一、单项选择题（每题 2 分，共 20 分）"></a>一、单项选择题（每题 2 分，共 20 分）</h2><ol><li><p><strong>若机器字长为 32 位，采用补码表示整数，则其能表示的最小值为：</strong><br>A. $0$<br>B. $-2^{31}$<br>C. $-2^{32}$<br>D. $-(2^{31}-1)$</p></li><li><p><strong>在设计时序逻辑电路时，若要存储电路的当前状态以便在下一时钟周期参与运算，最适合的硬件方案是：</strong><br>A. 仅使用组合逻辑电路<br>B. 使用一组 D 触发器<br>C. 使用只读存储器<br>D. 使用多路选择器</p></li><li><p><strong>某主存系统由 $16\text{K} \times 4$ 位的 DRAM 芯片组成，若要组成 $64\text{K} \times 16$ 位的存储器，则总共需要该 DRAM 芯片的数量是：</strong><br>A. 4 片<br>B. 8 片<br>C. 16 片<br>D. 32 片</p></li><li><p><strong>MIPS 指令 <code>lw $s1, 4($s0)</code> 的功能描述正确的是：</strong><br>A. 将内存地址 <code>$s0+4</code> 处的一个<strong>字</strong>加载到寄存器 <code>$s1</code> 中<br>B. 将内存地址 <code>$s1+4</code> 处的一个<strong>字</strong>加载到寄存器 <code>$s0</code> 中<br>C. 将内存地址 <code>$s0+4</code> 处的一个<strong>字节</strong>加载到寄存器 <code>$s1</code> 中<br>D. 将寄存器 <code>$s1</code> 的值存入内存地址 <code>$s0+4</code> 处</p></li><li><p><strong>分析下列 MIPS 代码片段，其功能是：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">la $a0,A<br>li $t0, 0          <br>li $t1, 0          <br>Loop:<br>    slti $t2, $t0, 10<br>    beq $t2, $zero, Exit<br>    sll $t3, $t0, 2<br>    add $t3, $t3, $a0<br>    lw  $t4, 0($t3)<br>    add $t1, $t1, $t4<br>    addi $t0, $t0, 1<br>    j Loop<br>Exit: ...<br></code></pre></td></tr></table></figure><p>A. 计算数组 A 中最小 10 个数的和<br>B. 计算数组 A 中前 10 个数的和<br>C. 计算数组 A 中最后 10 个数的和<br>D. 取出数组 A 的第 10 个数</p></li><li><p><strong>流水线 CPU（Pipelined）与单周期 CPU 相比，其主要优势在于：</strong><br>A. 缩短了单条指令的执行时间<br>B. 减少指令的执行周期<br>C. 避免了所有数据冒险<br>D. 增加指令的并行程度，提高了指令的吞吐率</p></li><li><p><strong>在 Cache 写操作中，若 CPU 写命中，同时修改 Cache 和主存中对应内容的策略称为：</strong><br>A. 回写法<br>B. 写分配<br>C. 写直通<br>D. 不写分配</p></li><li><p><strong>在虚实地址转换及访存过程中，关于 TLB 和 Cache 的访问次数，下列说法正确的是：</strong><br>A. TLB Hit, Cache Hit：访存 0 次<br>B. TLB Miss, Page Table Hit, Cache Hit：访存 1 次<br>C. TLB Miss, Page Table Hit, Cache Miss：访存 2 次<br>D. TLB Hit, Cache Miss：访存 2 次</p></li><li><p><strong>当发生 TLB 缺失（TLB Miss）但页表命中（Page Table Hit）时，系统的标准操作是：</strong><br>A. 抛出缺页异常（Page Fault），由操作系统从磁盘调页<br>B. 硬件或操作系统根据页表基址读取页表项，将物理页号填入 TLB，并重新执行指令<br>C. 抛出段错误（Segmentation Fault），终止程序运行<br>D. 直接绕过 TLB，仅使用 Cache 进行后续访问</p></li><li><p><strong>关于异常（Exception）和中断（Interrupt），下列说法正确的是：</strong><br>A. 缺页（Page Fault）属于一种异常（内中断），通常由程序执行触发<br>B. 算术溢出属于外部中断<br>C. I/O 设备请求属于异常<br>D. 系统调用（System Call）不属于异常处理机制</p></li></ol><hr><h2 id="二、逻辑与性能计算（共-15-分）"><a href="#二、逻辑与性能计算（共-15-分）" class="headerlink" title="二、逻辑与性能计算（共 15 分）"></a>二、逻辑与性能计算（共 15 分）</h2><ol><li><p><strong>逻辑化简（5分）</strong><br>已知逻辑函数 $F(A,B,C,D)$。<br>化简为最简与或表达式。<br><em>(提示：化简结果形式应类似于 $B + \overline{A}~\overline{C}$)</em></p></li><li><p><strong>组合逻辑设计（5分）</strong><br>请利用一个 <strong>4 选 1 多路选择器（MUX）</strong> 和一个连接了C的<strong>非门（NOT）</strong> 实现下列逻辑函数：</p><script type="math/tex; mode=display">F = \overline{A}~\overline{C} + BC + A\overline{B}</script><p>给出$D0-D3,\overline{EN}$的连线</p></li><li><p><strong>性能分析（5分）</strong></p><p>某计算机主频为 <strong>500 MHz</strong>，其指令集包含 A、B、C、D 四类指令。已知 A 类指令的 CPI 为 1，B、C、D 类指令的 CPI 均为 2。在某基准程序中，A 类指令占总指令数的 40%，B、C、D 类指令分别占总指令数的15%，35%，10%。<br>现对编译器进行优化，<strong>将程序中 A 类指令的数量减少了一半</strong>（其他指令数量不变）。</p><p><strong>请回答以下问题：</strong></p><p>（1）计算优化前和优化后的 CPI 以及 MIPS（MIPS保留一位小数）。</p><p>（2）优化后该程序的执行性能是否有提升？如果没有，请给出理由；若有，请计算加速比。</p></li></ol><hr><h2 id="三、有限状态机设计（10-分）"><a href="#三、有限状态机设计（10-分）" class="headerlink" title="三、有限状态机设计（10 分）"></a>三、有限状态机设计（10 分）</h2><p> 设计一个有限状态机实现1101的有重叠检测，当拍输入为“1”且当前序列为“110”时认为已检测到并立即输出。</p><ol><li>这是什么型状态机？</li><li>画出状态转换图。</li><li>列出状态转换表并写出次态的逻辑表达式。（S1S0为当前状态，A为输入，S1’S0’为下一状态，Q为输出）</li></ol><hr><h2 id="四、MIPS-汇编程序设计（10-分）"><a href="#四、MIPS-汇编程序设计（10-分）" class="headerlink" title="四、MIPS 汇编程序设计（10 分）"></a>四、MIPS 汇编程序设计（10 分）</h2><p><strong>题目：</strong> 给定一个整型数组 <code>A</code>，其首地址保存在寄存器 <code>$a0</code> 中，数组长度 $N$ 保存在 <code>$a1</code> 中。请补全下列 MIPS 代码，功能为：<strong>统计数组 A 中所有“小于 0”的元素的个数</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">li $s0, 0         <br>    li $t0, 0          <br><br>Loop:<br>    bge ____ , $a1, End <br>        <br>    add $t1 , ____ , $a0  <br>    lw  ____ , 0($t1)    <br>    <br>    slt $t3, $t2 , ____<br>    beq $t3, ____ , Next <br>    <br>   <br>    addi $s0, $s0, 1   <br>    <br>Next:<br>    addi ____ , ____ , ____   <br>    __ ____<br><br>End:<br></code></pre></td></tr></table></figure><hr><h2 id="五、存储系统扩展（10-分）"><a href="#五、存储系统扩展（10-分）" class="headerlink" title="五、存储系统扩展（10 分）"></a>五、存储系统扩展（10 分）</h2><p>某计算机主存地址空间大小为 64KB，按字节编址（数据总线 8 位）。系统程序区占低地址区，<code>0-0x3FFF</code>：占用 16KB 空间，由 ROM 芯片组成。剩余高地址区为用户数据区。</p><p>现有芯片规格如下：<strong>ROM 芯片</strong>：$4K \times 4$ 位，<strong>DRAM 芯片</strong>：$16K \times 8$ 位</p><ol><li>上述 DRAM 芯片行、列地址位数相等，求该 DRAM 芯片的行选择线和列选择线各为多少条？</li><li>DRAM 采用按行刷新，刷新地址计数器应设为多少位？</li><li>若 DRAM 采用分布式（异步）刷新方式，刷新间隔（最大刷新周期）为 4ms，求刷新周期。</li><li>设计主存时，哪几位用于生成片选信号？选用什么译码器最佳？若地址线 A14、A15 误接为恒定高电平，则系统中实际有几个 DRAM 芯片和几个 ROM 芯片可以正常被访问？</li></ol><hr><h2 id="六、Cache-性能分析（15-分）"><a href="#六、Cache-性能分析（15-分）" class="headerlink" title="六、Cache 性能分析（15 分）"></a>六、Cache 性能分析（15 分）</h2><p>某计算机主存地址空间大小为 1MB，Cache采用<strong>8路组相联</strong>映射方式，Cache大小32KB，数据块大小16B。每块包含一位有效位，一组含8位修改位。</p><p>请回答下列问题：</p><ol><li>求Cache包含的组数以及主存地址格式（名称+位数），指出Tag位数。</li><li>求出Cache的总存储容量。</li><li>假设CPU执行某段程序时，Cache命中时的访问时间为 $t_c = 10\text{ns}$，Cache缺失时处理包含访问主存的累计时间为 $t_m = 100\text{ns}$。若要求平均访问时间 $t_a$ 不超过 $19\text{ns}$，则Cache的命中率至少应为多少？</li><li>现有数组定义 <code>int A[64]</code>（假设 <code>int</code> 占4字节），程序顺序读取该数组。<ul><li>(1) 若数组 A 的起始地址为 <strong>84AB0H</strong>，Cache缺失次数是多少？</li><li>(2) 若数组 A 的起始地址为 <strong>84AB8H</strong>，Cache缺失次数是多少？</li></ul></li></ol><hr><h2 id="七、虚拟存储器（10-分）"><a href="#七、虚拟存储器（10-分）" class="headerlink" title="七、虚拟存储器（10 分）"></a>七、虚拟存储器（10 分）</h2><p>某计算机系统采用虚拟页式存储管理，物理空间$1$GB，虚拟空间4GB，页大小为 <strong>4KB</strong>。TLB（快表）采用 <strong>2路组相联</strong> 映射方式，大小32KB。每个表项包含1位有效位、1位脏位。</p><p>1.逻辑地址为多少位，一共有多少虚页？</p><p>2.虚地址中哪几位是虚页号，虚页号TLB中哪几位为标记位(Tag)，计算TLB总容量。</p><p>3.系统使用一个磁盘子系统，磁盘转速为6000 rpm，有8个盘，218个柱面，每个磁道12个扇区，其中有两个扇区保留不存储信息，扇区大小512B，平均寻道时间为5 ms，求磁盘平均访问时间和总存储容量。</p><p>4.假设系统中TLB和Cache的缺失率分别为1%和2%，且二者命中情况相互独立，CPU访问TLB和Cache命中时的用时为20ns，主存访问时间为90ns。若TLB不命中，系统需要访问一次主存查询页表；若Cache不命中，系统需要访问一次主存读取数据。请根据上述参数计算该存储系统的平均有效访问时间。</p><hr><h2 id="八、CPU-流水线冒险（10-分）"><a href="#八、CPU-流水线冒险（10-分）" class="headerlink" title="八、CPU 流水线冒险（10 分）"></a>八、CPU 流水线冒险（10 分）</h2><p><strong>题目：</strong> 考虑标准的 MIPS 五级流水线（IF, ID, EX, MEM, WB）。仅有W级到E级的转发通路，其他旁路与寄存器内部转发均无，现有如下指令序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">I1: add $s2, $s1, $s3<br>I2: lw $s1, 0($s2)<br>I3: sub $s4, $s2, $s1<br>I4: or $s7, $s2, $s4<br>I5: sw $s7, 0($s6)<br></code></pre></td></tr></table></figure><ol><li><p>指出所有读写与写读相关。表示为：表示为：<u>$s8，{I2，I3，I5}</u></p></li><li><p>指出所有存在的数据冲突。在不新增旁路的情况下，能否解决冲突？如果不能，请给出如何插入及累计需要插入几个nop。（推荐画时空图说明）</p></li></ol><blockquote><p>致谢：感谢我的同学zlx以及我的三位舍友在题面回忆上做出的帮助和贡献</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计组理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>计组理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P1课下-总结反思</title>
    <link href="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/"/>
    <url>/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<p>这次可能是最简单的一次课下了？只有附加题较难。当然这并不是好事，可能会导致上机难度陡然上升而我们在课下没有得到充分练习的情况。还是与往常一样，分为教程复现，题面，思路与题解三部分。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="Verilog-FSM-设计流程"><a href="#Verilog-FSM-设计流程" class="headerlink" title="Verilog FSM 设计流程"></a>Verilog FSM 设计流程</h3><h4 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h4><p>对于状态机的概念和用法在理论课和前面部分的学习中接触到了很多，所以在此不再过多叙述。</p><p>在 Verilog HDL 中可以用许多种方法来描述有限状态机，最常用的方法是用 <strong>always 语句</strong>和 <strong>case 语句</strong>。下面具体说明用 Verilog 设计有限状态机的一般步骤：</p><ol><li><p>逻辑抽象，得出状态转换图。</p></li><li><p>状态化简（该步骤可以省略），如果在状态转换图中出现两个一样的状态则需要将其合并为一个状态，以得到最简的状态转换图。</p></li><li><p>状态分配，也就是状态编码。通常有很多种编码方式，比如 Gray 编码、独热编码等。在实际电路中，需综合考虑电路复杂度与电路性能之间的折中。这里的设计没有用到特别复杂的电路逻辑，所以大家可以自行决定用哪种编码方式。（不过，对于需要在FPGA上运行的电路，推荐使用<strong>独热</strong>编码方式。因为 <a href="http://cscore.buaa.edu.cn/tutorial/fpga/intro/intro/">FPGA</a> 有丰富的寄存器资源，门逻辑相对缺乏，采用独热编码可以有效提高电路的速度和可靠性，也有利于提高器件资源的利用率。）</p><p>下面利用独热编码来介绍状态编码定义的两种方式：parameter 和 `define 语句。</p><ul><li>用 parameter 参数定义：用 n 个 parameter 常量表示 n 个状态，如下图所示：</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">parameter</span> State1 = <span class="hljs-number">4&#x27;b0001</span>,<br>       State2 = <span class="hljs-number">4&#x27;b0010</span>,<br>       State3 = <span class="hljs-number">4&#x27;b0100</span>,<br>       State4 = <span class="hljs-number">4&#x27;b1000</span>;<br>...............<br><br><span class="hljs-keyword">case</span> (State)<br>     State1:........;<br>     State2:........;<br>     ........<br></code></pre></td></tr></table></figure><ul><li>用`define 语句定义：用 n 个宏名表示 n 个状态，如下所示：</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">define</span> State1 4&#x27;b0001</span><br> <span class="hljs-comment">// 不要加分号</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> State2 4&#x27;b0010</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> State3 4&#x27;b0100</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> State4 4&#x27;b1000</span><br>...<br><br><span class="hljs-keyword">case</span> (State)<br>    `State1:...;<br>    `State2:...;<br>    ...<br><span class="hljs-keyword">endcase</span><br></code></pre></td></tr></table></figure></li><li><p>根据状态转移图得出次态逻辑和输出逻辑。</p></li><li><p>按照相应逻辑，用 Verilog HDL 来描述有限状态机状态转移的情况。</p></li></ol><ul><li>复位时回到起始状态（敏感信号为<strong>时钟</strong>和<strong>复位</strong>信号，注意同步复位和异步复位的区别）</li><li>用 case 或 if-else 语句描述出状态的转移（根据现态（和输入）产生次态，可以与复位时回到起始状态的语句放在同一个 always 块中，即敏感信号为时钟和复位信号）</li><li>输出信号描述。用 case 语句或 if-else 语句描述状态机的输出信号</li></ul><h4 id="设计建议"><a href="#设计建议" class="headerlink" title="设计建议"></a>设计建议</h4><p>下面给出设计的几点建议：</p><ul><li>一般用 <strong>case、casez 或 casex</strong> 语句进行状态判断，比用 if-else 语句更加清晰明了。</li><li>在 case 语句的最后，要加上 <strong>default</strong> 分支语句，以避免锁存器的产生。</li><li>状态机一般应设计为<strong>同步</strong>方式，并由一个时钟信号来触发。</li><li>实用的状态机都应设计为由唯一的<strong>时钟边沿</strong>触发的<strong>同步</strong>运行方式。</li></ul><h3 id="Verilog-状态机设计示例"><a href="#Verilog-状态机设计示例" class="headerlink" title="Verilog 状态机设计示例"></a>Verilog 状态机设计示例</h3><h4 id="MOORE-型状态机设计示例"><a href="#MOORE-型状态机设计示例" class="headerlink" title="MOORE 型状态机设计示例"></a>MOORE 型状态机设计示例</h4><p>在上一节中，我们复习了 Verilog 状态机的设计流程。这一节我们以一个简单的状态机为例，解析如何全面地设计一个 Moore 型状态机。下面是一道简单的题目：</p><h4 id="用于识别串-1010-的自动机"><a href="#用于识别串-1010-的自动机" class="headerlink" title="用于识别串 1010 的自动机"></a>用于识别串 1010 的自动机</h4><p>clk 上升沿时，读入一个字符 in ，这时若<code>1010</code>是已读入的字符串的后缀，则 out 输出<code>1</code>，否则输出<code>0</code>。</p><blockquote><p>例如：对于已有输入<code>101</code>，输出为<code>0</code>，对于<code>101010</code>，输出为<code>1</code>。</p></blockquote><p>设计状态机的第一步，我们需要先分析问题，确定状态的<strong>数量</strong>和<strong>定义</strong>。</p><p>这道题我们需要设计一个识别 1010 的状态机。要确定它的状态数量，我们可能直觉认为要设置5种状态，分别处理读入了 ∅,1,10,101,1010 五种情况。这种想法是可行的，我们先根据这个直观的理解画出部分状态转换图，其中 state=0,1,2,3,4 分别对应“读入了∅,1,10,101,1010”。</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.5.2.png" class="" title="p1.0.5.2"><p>显然，如果从零时刻开始，串行输入 1010 ，状态机会按照 state=0-&gt;1-&gt;2-&gt;3-&gt;4 的顺序转移，假如我们规定 out=1 当且仅当 state=4 ，那么状态机可以正确识别 1010 的串。问题是，当匹配到 101 时，如果读入了一个1，得到了 1011 ，我们该如何正确选择应该转移到哪个状态？为此，我们要用一种啰嗦的方式严格定义状态 statei 的意义。我们看到，所谓“读入了 ∅,1,10,101,1010”是一种很模糊的说法，它有歧义。例如字符流是 1010 ，我们该说“读入了10”，还是“读入了1010”呢？因此，原来的说法不是良好的定义，因为它不能单单根据字符流来确定究竟是哪个状态。</p><p><strong>定义</strong>：设目标字符串 1010 为 str；状态机处于 statei 当且仅当：i&gt;0, 设所有 1&lt;=j&lt;=4, str[1:j] 能匹配的输入字符流的后缀为 <strong>S</strong>，str[1:i] 匹配的输入字符流的后缀在 <strong>S</strong> 中最长; i=0, 当且仅当所有 1&lt;=j&lt;=4, str[1:j] 都不能匹配输入字符流的任何一个后缀。</p><p>str[1:i] 的意义是 str 第 1 个字符到第 i 个字符的部分，比如 str[1:4] 就是 <strong>1010</strong>。通过这个定义，我们就可以很好地直接根据字符流确定是哪个状态。例如读入了 1010 时，显然 str[1:2], str[1:4] 都可以匹配 1010 的后缀，前者对应 state2，后者对应 state4，然而后者匹配的后缀长度最长，因此我们确定这时应该是 state=state4。</p><p>这样的定义是有好处的，有了它，我们就可以根据字符流判断是哪个状态。当然，这种状态的正确性的维护有赖于状态转移函数的选择。如果状态转移函数胡乱规定，我们就无法确定状态的正确性。</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.5.2.png" class="" title="p1.0.5.2"><p>在这里，我们采用类似于动态规划的思路规划状态转移函数。思路是：每在状态之间加入一条或几条表示状态转移的边，都要保证这样的操作能维持一个<strong>性质</strong>——在外界输入保证变换只涉及当前已经加入的边的条件下，涉及到的状态不违背我们事先约定的定义。</p><p>现在我们有四条边，我们考虑在这四条边上进行状态转移的情况。初始状态为 state=0。显然要走到 4，只有一条路径 0-&gt;1-&gt;2-&gt;3-&gt;4，对应输入 1010。state=0 时，我们回顾<strong>定义</strong>，输入的字符流是 ∅，这时谁也匹配不了，我们保持了状态定义的正确性；state=1，输入的字符流是 1，str[1:i], i=1 能匹配最长的后缀，而别的 str[1:j] 都不能匹配，我们再次保持了状态定义的正确性……接下来你可以自己推导，我们初步的状态转移设置确实维护了<strong>定义的正确性</strong>。</p><p>接下来，我们要补全状态转换图。当前的状态转换图是不完整的，我们在维持定义正确性的前提下补全每个状态下 0,1 两种输入对应的状态转移后，就得到了完整的正确的状态转换图。</p><p>首先从 state=0 开始考虑，我们欠缺了输入为 0 的情况。我们尝试加入一条边，再验证它的正确性。</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.5.3.png" class="" title="p1.0.5.3"><p>首先，我们根据前面的分析，知道假如状态转移只走之前加过的边，状态的定义是被保持的。现在我们考虑经过新加边的情况。当 state=0，对任意 1&lt;=j&lt;=4，输入字符流的末尾没有一个符合 str[1:j]，新加边表示我们又读入了一个 0，显然还是没有 statej 来匹配输入字符流的后缀。因此新加边没有影响定义的正确性。</p><p>接着我们看 state=1。我们像上面一样，添加一个状态转移边并分析正确性。</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.5.4.png" class="" title="p1.0.5.4"><p>回顾定义，state=1 时，字符串”1”即 str[1:1] 匹配的输入字符流的后缀在所有状态中最长的。隐含的意思是，我们不需要考虑输入字符流的后缀有什么“101”的情况。这时我们读入了一个字符 1，那么输入字符流的一个后缀是 11，我们扫遍所有的 statej，发现还是 state1 匹配的后缀最长，因此要保持在 state=1。我们再次维护了上述的定义的正确性。</p><p>以此类推，我们容易得到正确的状态转移图：</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.5.5.png" class="" title="p1.0.5.5"><p>最后，把状态转换图改写成对应的 Verilog 程序，并注意根据 state 维护 out 的值，我们就成功实现了一个能正确识别1010串的 Moore 型有限状态机。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> fsm_1010(<br>     <span class="hljs-keyword">input</span> clk,<br>     <span class="hljs-keyword">input</span> in,<br>     <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out = <span class="hljs-number">0</span><br>    );<br><br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;<br>     <span class="hljs-comment">/* state 被期望能够正确表示当前累计读入的 1010 前缀的长度。</span><br><span class="hljs-comment">     比如未读入时 state=0; 读入到 10 时我们期望有 state&lt;=2。*/</span><br><br>     <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">case</span> (state)<br>        <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">begin</span><br>                state &lt;= in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>                out &lt;= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">begin</span><br>                state &lt;= in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;<br>                out &lt;= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">begin</span><br>                state &lt;= in == <span class="hljs-number">1</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">0</span>;<br>                out &lt;= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">begin</span><br>                state &lt;= in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">4</span>;<br>                out &lt;= (in == <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">begin</span><br>                state &lt;= in == <span class="hljs-number">1</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">0</span>;<br>                out &lt;= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">endcase</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="状态机编码风格"><a href="#状态机编码风格" class="headerlink" title="状态机编码风格"></a>状态机编码风格</h4><p>前面我们已经知道了如何使用 Verilog 语言来描述状态机。这里介绍一下状态机的典型状态编码风格，仍然使用前面的例子进行分析。状态机的编码风格有一段式（也称高速状态机）、两段式、三段式等。</p><h5 id="一段式状态机"><a href="#一段式状态机" class="headerlink" title="一段式状态机"></a>一段式状态机</h5><p>一段式状态机将整个状态机编写在<strong>一个</strong> always 模块里，该模块采用同步时序逻辑，全部使用非阻塞赋值。该模块既描述状态转移，又描述状态的输入和输出。上面的例程就是典型的一段式状态机。</p><p>采用一段式状态机在思路上比较容易，书写的用时少，且运行速度快，在上机的时候可以节省编码的用时。但缺点是维护代码和调试比较困难。采用两段式和三段式状态机可以避免以上问题。</p><h5 id="两段式状态机"><a href="#两段式状态机" class="headerlink" title="两段式状态机"></a>两段式状态机</h5><p>两段式状态机使用<strong>两个</strong> always 模块，第一个 always 模块采用同步时序逻辑描述状态转移；第二个 always 模块使用组合逻辑判断状态转移的条件，描述状态转移的规律。</p><p>和一段式状态机相比，采用两段式状态机实现了同步时序列逻辑和组合逻辑的分离，便于阅读、理解和维护，有利于综合工具优化代码，方便用户添加时序约束条件。但缺点是编码环节多，代码量稍大，较为繁琐，因为要将其拆分成两个不同的模块。</p><p>示例代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> fsm_1010 (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out<br>);<br><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] next_state;<br><br><span class="hljs-comment">// 描述状态转移的时序逻辑</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    state &lt;= next_state; <span class="hljs-comment">// 这里还可以视情况添加复位功能</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">// 判断状态转移条件以及产生输出组合逻辑</span><br><span class="hljs-keyword">always</span> @(state, in) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span> (state)<br>        <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>                out = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;<br>                out = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">0</span>;<br>                out = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">4</span>;<br>                out = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">0</span>;<br>                out = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = <span class="hljs-number">0</span>;<br>                out = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">end</span> <span class="hljs-keyword">module</span><br></code></pre></td></tr></table></figure><h5 id="三段式状态机"><a href="#三段式状态机" class="headerlink" title="三段式状态机"></a>三段式状态机</h5><p>三段式状态机使用<strong>三个</strong> always 模块，第一个 always 模块采用同步时序逻辑描述状态转移；第二个 always 模块采用组合逻辑判断状态转移条件，描述状态转移规律；第三个 always 模块采用组合逻辑或者时序逻辑述每个状态的输出。</p><p>和两段式状态机相比，这样可以减少毛刺的产生（想想这是为什么）。其缺点和两段式状态机相同，编码复杂，消耗的资源也比较多，因为需要初态和次态状态寄存器等。</p><blockquote><p>这是因为三段式状态机将输出分离成独立的组合逻辑，减小了关键路径和时延，所以可以减少毛刺现象。</p></blockquote><p>示例代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> fsm_1010 (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out<br>);<br><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] next_state;<br><br><span class="hljs-comment">// 描述状态转移的时序逻辑</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    state &lt;= next_state;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">// 判断状态转移条件的组合逻辑</span><br><span class="hljs-keyword">always</span> @(state, in) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span> (state)<br>        <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">4</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = in == <span class="hljs-number">1</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">begin</span><br>                next_state = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">// 产生输出的组合逻辑</span><br><span class="hljs-keyword">always</span> @(state) <span class="hljs-keyword">begin</span><br>    out = (state == <span class="hljs-number">4</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>上面的例子是针对 Moore 状态机的，在 Mealy 状态机上也可以尝试使用这三种风格进行状态机的书写，代码框架是相同的。</p><p>同学们可以根据自身情况选用这三种不同风格的状态机，但一定要明白它们的内在区别和其中的设计原理，帮助自己在课下和上机的时候顺利完成各种状态机的书写。</p><div class="table-container"><table><thead><tr><th>思考题</th></tr></thead><tbody><tr><td>Verilog 语言和 Logisim 软件都可以用来对数字电路进行建模，你认为它们各有什么优缺点？</td></tr><tr><td>在使用 Verilog 编写电路时，一般很少使用到循环语句，如<code>for</code>语句等，Verilog 语言中也不包含<code>break</code>、<code>continue</code>这样的关键字。思考这是为什么？</td></tr><tr><td>Verilog 中的<code>generate</code>块在教程正文中并未提及，但有时这种语法可以给我们编写模块带来许多方便之处。请查阅相关资料，了解其作用与相关用法。</td></tr></tbody></table></div><h3 id="Verilog-模块代码样例"><a href="#Verilog-模块代码样例" class="headerlink" title="Verilog 模块代码样例"></a>Verilog 模块代码样例</h3><h4 id="小型通用模板"><a href="#小型通用模板" class="headerlink" title="小型通用模板"></a>小型通用模板</h4><p>这一节主要给出笔者个人对于不同需求的代码样例，供大家参考。</p><ul><li><p>MUX</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> result = (Aluop == <span class="hljs-number">4&#x27;d0</span>) ? (srca + srcb) :<br>                   (Aluop == <span class="hljs-number">4&#x27;d1</span>) ? (srca - srcb) :<br>                   (Aluop == <span class="hljs-number">4&#x27;d2</span>) ? (srca &amp; srcb) :<br>                   (Aluop == <span class="hljs-number">4&#x27;d3</span>) ? (srca | srcb) :<br>                   (Aluop == <span class="hljs-number">4&#x27;d4</span>) ? (srca ^ srcb) :<br>                   (Aluop == <span class="hljs-number">4&#x27;d5</span>) ? (srca &gt; srcb) :<br>                   <span class="hljs-number">32&#x27;d0</span>;<br></code></pre></td></tr></table></figure></li><li><p>如果涉及有符号数的运算，不推荐使用三目运算符，推荐使用 always@(<em>) 的方式，一般来说 always@(</em>) 配合 case 写出的类似 MUX 语句在仿真中的行为类似纯组合逻辑，但是 result 在写代码时应写为 reg 型。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">case</span>(Aluop)<br>        <span class="hljs-number">4&#x27;d0</span>:<span class="hljs-keyword">begin</span><br>            result = srca + srcb;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4&#x27;d1</span>:<span class="hljs-keyword">begin</span><br>            result = srca - srcb;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4&#x27;d2</span>:<span class="hljs-keyword">begin</span><br>            result = srca &amp; srcb;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4&#x27;d3</span>:<span class="hljs-keyword">begin</span><br>            result = srca | srcb;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4&#x27;d4</span>:<span class="hljs-keyword">begin</span><br>            result = srca ^ srcb;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-number">4&#x27;d5</span>:<span class="hljs-keyword">begin</span><br>            result = srca &gt; srcb;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p>流水线寄存器（P5）</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> pipeline_sample(<br>   <span class="hljs-keyword">input</span> clk,<br>   <span class="hljs-keyword">input</span> reset,<br>   <span class="hljs-keyword">input</span> stall,<br>   <span class="hljs-keyword">input</span> flush,<br>   <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] aluResultAtExe,<br>   <span class="hljs-comment">// 可能还有其他来自前一级的输入</span><br>   <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] aluResultAtMemory<br>   <span class="hljs-comment">// 可能还有要输出到后一级的</span><br>   <span class="hljs-comment">// 输入输出应配对</span><br>   );<br>   <span class="hljs-comment">// 根据端口定义，可能还要开其他的临时寄存器</span><br>   <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] aluResult;<br>   <span class="hljs-comment">// 根据临时寄存器的值，可能还要连其他的线</span><br>   <span class="hljs-keyword">assign</span> aluResultAtMemory = aluResult;<br><br>   <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)<br>   <span class="hljs-comment">// 可能还要处理其他的临时寄存器</span><br>   <span class="hljs-keyword">begin</span><br>       <span class="hljs-comment">// 复位 或者 清除流水线寄存器（阻塞，异常中断处理会用到）</span><br>       <span class="hljs-keyword">if</span>(reset | flush)<br>       <span class="hljs-keyword">begin</span><br>           aluResult &lt;= <span class="hljs-number">32&#x27;d0</span>;<br>       <span class="hljs-keyword">end</span><br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>           <span class="hljs-comment">// 判定是否应阻塞该级，不阻塞时才更新为前一级的值</span><br>           <span class="hljs-keyword">if</span>(!stall)<br>           <span class="hljs-keyword">begin</span><br>               aluResult &lt;= aluResultAtExe;<br>           <span class="hljs-keyword">end</span><br>       <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="Verilog-代码规范"><a href="#Verilog-代码规范" class="headerlink" title="Verilog 代码规范"></a>Verilog 代码规范</h3><p>本文档是推荐的 Verilog 编程规范，遵守本规范可以减少你代码中出现的问题，避免在“莫名其妙”的问题上浪费时间。</p><h4 id="VC-001-信号名称采用-snake-case"><a href="#VC-001-信号名称采用-snake-case" class="headerlink" title="VC-001 信号名称采用 snake_case"></a>VC-001 信号名称采用 <code>snake_case</code></h4><p>信号名称通常采用 <code>snake_case</code>，即变量名全小写，单词之间用下划线分隔。</p><h4 id="VC-002-信号极性为低有效用-n-后缀表示"><a href="#VC-002-信号极性为低有效用-n-后缀表示" class="headerlink" title="VC-002 信号极性为低有效用 _n 后缀表示"></a>VC-002 信号极性为低有效用 <code>_n</code> 后缀表示</h4><p>对于复位和使能信号，例如 <code>rst</code> 和 <code>we</code>，如果添加了 <code>_n</code> 后缀，表示值为零时生效（低有效，Active Low），值为一时不生效；如果没有添加 <code>_n</code> 后缀，表示值为一时生效（高有效，Active High），值为零时不生效。详细解释见下面的表格：</p><div class="table-container"><table><thead><tr><th style="text-align:left">信号名称</th><th style="text-align:left">极性</th><th style="text-align:left">1’b1</th><th style="text-align:left">1’b0</th></tr></thead><tbody><tr><td style="text-align:left">rst</td><td style="text-align:left">高有效</td><td style="text-align:left">复位</td><td style="text-align:left">不复位</td></tr><tr><td style="text-align:left">rst_n</td><td style="text-align:left">低有效</td><td style="text-align:left">不复位</td><td style="text-align:left">复位</td></tr><tr><td style="text-align:left">we</td><td style="text-align:left">高有效</td><td style="text-align:left">写入</td><td style="text-align:left">不写入</td></tr><tr><td style="text-align:left">we_n</td><td style="text-align:left">低有效</td><td style="text-align:left">不写入</td><td style="text-align:left">写入</td></tr></tbody></table></div><p>当代码中需要混合使用 <code>rst</code> 和 <code>rst_n</code> 的时候，采用以下的方式来转换：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> test(<br>  <span class="hljs-keyword">input</span> rst_n<br>);<br>  <span class="hljs-keyword">wire</span> rst;<br><br>  <span class="hljs-comment">// GOOD</span><br>  <span class="hljs-keyword">assign</span> rst = ~rst_n;<br><br>  <span class="hljs-comment">// GOOD</span><br>  <span class="hljs-comment">// Verilog</span><br>  <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>    rst = ~rst_n;<br>  <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="VC-003-信号仅在一个-always-块中赋值"><a href="#VC-003-信号仅在一个-always-块中赋值" class="headerlink" title="VC-003 信号仅在一个 always 块中赋值"></a>VC-003 信号仅在一个 <code>always</code> 块中赋值</h4><p>通常情况下，一个信号只会在一个 <code>always</code> 块中赋值。</p><h4 id="VC-004-组合逻辑采用-always-块或者-assign-编写"><a href="#VC-004-组合逻辑采用-always-块或者-assign-编写" class="headerlink" title="VC-004 组合逻辑采用 always @(*) 块或者 assign 编写"></a>VC-004 组合逻辑采用 <code>always @(*)</code> 块或者 <code>assign</code> 编写</h4><p>组合逻辑的 <code>always</code> 块，使用以下的写法：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Verilog</span><br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>  c = a + b;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">// GOOD</span><br><span class="hljs-keyword">assign</span> c = a + b;<br></code></pre></td></tr></table></figure><h4 id="VC-005-组合逻辑-always-块中仅使用阻塞赋值"><a href="#VC-005-组合逻辑-always-块中仅使用阻塞赋值" class="headerlink" title="VC-005 组合逻辑 always 块中仅使用阻塞赋值"></a>VC-005 组合逻辑 <code>always</code> 块中仅使用阻塞赋值</h4><p>表示组合逻辑的 <code>always</code> 块中所有的赋值请使用阻塞赋值（<code>=</code>）。</p><h4 id="VC-006-组合逻辑-always-块中保证每个分支都进行赋值"><a href="#VC-006-组合逻辑-always-块中保证每个分支都进行赋值" class="headerlink" title="VC-006 组合逻辑 always 块中保证每个分支都进行赋值"></a>VC-006 组合逻辑 <code>always</code> 块中保证每个分支都进行赋值</h4><p>如果使用了条件语句 <code>if</code>，需要保证信号在每个可能的分支途径下都进行了赋值。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// GOOD</span><br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span> (reset_n) <span class="hljs-keyword">begin</span><br>    c = a + b;<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>    c = <span class="hljs-number">1&#x27;b0</span>;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">// BAD</span><br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span> (reset_n) <span class="hljs-keyword">begin</span><br>    c = a + b;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>请不要列举敏感信号：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// BAD</span><br><span class="hljs-keyword">always</span> @ (b, c) <span class="hljs-keyword">begin</span><br>  a = b + c;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="VC-007-时序逻辑在-always-posedge-clock-中实现"><a href="#VC-007-时序逻辑在-always-posedge-clock-中实现" class="headerlink" title="VC-007 时序逻辑在 always @(posedge clock) 中实现"></a>VC-007 时序逻辑在 <code>always @(posedge clock)</code> 中实现</h4><p>当需要表示时序逻辑时，使用以下的写法：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Verilog</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clock) <span class="hljs-keyword">begin</span><br>  c &lt;= a + b;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="VC-008-时序逻辑-always-块中仅使用非阻塞赋值"><a href="#VC-008-时序逻辑-always-块中仅使用非阻塞赋值" class="headerlink" title="VC-008 时序逻辑 always 块中仅使用非阻塞赋值"></a>VC-008 时序逻辑 <code>always</code> 块中仅使用非阻塞赋值</h4><p>时序逻辑 <code>always</code> 块中，所有的赋值请使用非阻塞赋值（<code>&lt;=</code>）。</p><h4 id="VC-009-不要使用下降沿触发，特殊协议除外"><a href="#VC-009-不要使用下降沿触发，特殊协议除外" class="headerlink" title="VC-009 不要使用下降沿触发，特殊协议除外"></a>VC-009 不要使用下降沿触发，特殊协议除外</h4><p>通常情况下，请不要使用下降沿触发：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// BAD: do not use negedge</span><br><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">negedge</span> clock) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="VC-010-不要使用非时钟-复位信号的边沿触发"><a href="#VC-010-不要使用非时钟-复位信号的边沿触发" class="headerlink" title="VC-010 不要使用非时钟 / 复位信号的边沿触发"></a>VC-010 不要使用非时钟 / 复位信号的边沿触发</h4><p>通常情况下，不要使用除了时钟和复位以外的信号做边沿触发。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// BAD: do not use non-clock/reset signals</span><br><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> signal) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="VC-011-时序逻辑中不要使用时钟信号"><a href="#VC-011-时序逻辑中不要使用时钟信号" class="headerlink" title="VC-011 时序逻辑中不要使用时钟信号"></a>VC-011 时序逻辑中不要使用时钟信号</h4><p>在时序逻辑中，请不要在敏感列表以外的地方使用时钟信号：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// BAD</span><br><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clock) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span> (clock) <span class="hljs-keyword">begin</span><br>    a &lt;= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="VC-012-使用同步复位，而不是异步复位"><a href="#VC-012-使用同步复位，而不是异步复位" class="headerlink" title="VC-012 使用同步复位，而不是异步复位"></a>VC-012 使用同步复位，而不是异步复位</h4><p>对于 FPGA，请使用同步复位：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Verilog</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clock) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>    c &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>    c &lt;= a + b;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="VC-013-不要在内部模块中使用-inout"><a href="#VC-013-不要在内部模块中使用-inout" class="headerlink" title="VC-013 不要在内部模块中使用 inout"></a>VC-013 不要在内部模块中使用 <code>inout</code></h4><p>FPGA 内部的模块之间请不要使用 <code>inout</code>，仿真环境除外。</p><h4 id="VC-014-用-localparam-命名状态机的各个状态"><a href="#VC-014-用-localparam-命名状态机的各个状态" class="headerlink" title="VC-014 用 localparam 命名状态机的各个状态"></a>VC-014 用 localparam 命名状态机的各个状态</h4><p>编写状态机的时候，用 <code>localparam</code> 命名各个状态：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// GOOD</span><br><span class="hljs-keyword">localparam</span> sInit = <span class="hljs-number">2&#x27;d0</span>;<br><span class="hljs-keyword">localparam</span> sIdle = <span class="hljs-number">2&#x27;d1</span>;<br><span class="hljs-keyword">localparam</span> sWork = <span class="hljs-number">2&#x27;d2</span>;<br><span class="hljs-keyword">localparam</span> sDone = <span class="hljs-number">2&#x27;d3</span>;<br><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] state;<br></code></pre></td></tr></table></figure><p>如果仿真工具不支持在波形中显示为对应的状态名称，可以采用以下的方法：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">ifndef</span> SYNTHESIS</span><br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">39</span>:<span class="hljs-number">0</span>] state_string; <span class="hljs-comment">// 40 bits = 5 byte</span><br><br>  <span class="hljs-keyword">always</span> @ (*) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(state)<br>      sInit: state_string = <span class="hljs-string">&quot;sInit&quot;</span>;<br>      sIdle: state_string = <span class="hljs-string">&quot;sIdle&quot;</span>;<br>      sWork: state_string = <span class="hljs-string">&quot;sWork&quot;</span>;<br>      sDone: state_string = <span class="hljs-string">&quot;sDone&quot;</span>;<br>      <span class="hljs-keyword">default</span>: state_string = <span class="hljs-string">&quot;?????&quot;</span>;<br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>此时在仿真波形中，<code>state_string</code> 信号就可以看到状态的名称了。</p><h3 id="其他可参考的-Verilog-编程规范"><a href="#其他可参考的-Verilog-编程规范" class="headerlink" title="其他可参考的 Verilog 编程规范"></a>其他可参考的 Verilog 编程规范</h3><ul><li>本规范修改自 <a href="https://github.com/thu-cs-lab/verilog-coding-standard">thu-cs-lab/verilog-coding-standard</a></li><li><a href="http://fpgacpu.ca/fpga/verilog.html">Verilog Coding Standard</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md">lowRISC Verilog Coding Style</a></li></ul><h2 id="P1课下题面"><a href="#P1课下题面" class="headerlink" title="P1课下题面"></a>P1课下题面</h2><h3 id="P1-L0-splitter-Verilog部件设计-P1-Q1"><a href="#P1-L0-splitter-Verilog部件设计-P1-Q1" class="headerlink" title="P1_L0_splitter-Verilog部件设计(P1.Q1)"></a>P1_L0_splitter-Verilog部件设计(P1.Q1)</h3><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在这个部分中，我们的目标是完成Splitter、ALU和EXT的搭建。相信经过之前的学习，大家对这三个组合逻辑部件已经有了一定的了解。在组合逻辑电路中，这是相当简单的例子。我们也希望大家能够从这些简单的例子中，复习使用 Verilog 进行电路设计的一般流程，并且学会如何测试自己所搭建电路的正确性。在本门课程中，Debug 和测试将会是非常重要的技能，希望大家能在课下努力锻炼这种能力。</p><h3 id="1、Verilog-实现-Splitter"><a href="#1、Verilog-实现-Splitter" class="headerlink" title="1、Verilog 实现 Splitter"></a>1、Verilog 实现 Splitter</h3><p>使用 Verilog 搭建一个32位 Splitter , 给定一个32位的二进制数作为输入，将其划分为四个8位的二进制数作为输出。</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.1.1.png" class="" title="p1.0.1.1.png"><h3 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h3><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名: splitter</li></ul><h3 id="P1-L0-ALU-Verilog部件设计-P1-Q2"><a href="#P1-L0-ALU-Verilog部件设计-P1-Q2" class="headerlink" title="P1_L0_ALU-Verilog部件设计(P1.Q2)"></a>P1_L0_ALU-Verilog部件设计(P1.Q2)</h3><h3 id="2、Verilog-实现-ALU"><a href="#2、Verilog-实现-ALU" class="headerlink" title="2、Verilog 实现 ALU"></a>2、Verilog 实现 ALU</h3><p>使用 Verilog 搭建一个 32 位六运算 ALU 并提交。具体模块端口定义如下：</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.2.1.png" class="" title="p1.0.2.1.png"><p>模块功能定义如下：</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.2.2.png" class="" title="p1.0.2.2.png"><h3 id="知识复习："><a href="#知识复习：" class="headerlink" title="知识复习："></a>知识复习：</h3><p>在这里我们需要复习逻辑右移和算术右移的区别：</p><p>逻辑右移不考虑符号位，右移一位，左边补零即可。</p><p>算术右移需要考虑符号位，右移一位，若符号位为 1 ，在左边补 1 ；否则，补 0 。</p><p>例如，8 位二进制数 10111101 分别右移2位。</p><ul><li>逻辑右移结果为<strong>00</strong>101111</li><li>算术右移结果为<strong>11</strong>101111</li></ul><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><p>在进行有符号数的相关操作时，应注意 <strong>$signed()</strong> 的使用。若有必要，请参照Verilog教程的语法部分中的相关介绍进行复习。</p><h3 id="要求：-1"><a href="#要求：-1" class="headerlink" title="要求："></a>要求：</h3><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名: alu</li></ul><h3 id="P1-L0-EXT-Verilog部件设计-P1-Q3"><a href="#P1-L0-EXT-Verilog部件设计-P1-Q3" class="headerlink" title="P1_L0_EXT-Verilog部件设计(P1.Q3)"></a>P1_L0_EXT-Verilog部件设计(P1.Q3)</h3><h3 id="3、Verilog-实现-EXT"><a href="#3、Verilog-实现-EXT" class="headerlink" title="3、Verilog 实现 EXT"></a>3、Verilog 实现 EXT</h3><p>EXT为扩展单元，其主要功能是完成将输入到其中的16位数据进行符号扩展、零扩展以及将输入的16位数加载到高位等操作。具体模块端口定义如下：</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.3.1.png" class="" title="p1.0.3.1.png"><p>模块功能定义如下：</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.3.2.png" class="" title="p1.0.3.2.png"><h3 id="要求：-2"><a href="#要求：-2" class="headerlink" title="要求："></a>要求：</h3><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名: ext</li></ul><h3 id="P1-L0-gray-Verilog时序逻辑-P1-Q4"><a href="#P1-L0-gray-Verilog时序逻辑-P1-Q4" class="headerlink" title="P1_L0_gray-Verilog时序逻辑(P1.Q4)"></a>P1_L0_gray-Verilog时序逻辑(P1.Q4)</h3><h3 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h3><h3 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h3><p>在完成了 Verilog 组合逻辑部件设计的三道编程题之后，相信大家对于使用 Verilog 进行设计的一般流程和方法已经再次熟悉。现在，我们将进行下一步的挑战——设计包含<strong>时序逻辑</strong>的 Verilog 部件，这也将是我们从组合逻辑部件到之后的<strong>有限状态机</strong>的重要过渡。 在 Verilog 的教程部分，我们曾设计了一个简易的计数器。而我们现在的任务就是设计一个加强版的计数器——格雷码计数器。 如果你对格雷码的定义和优点等知识有所遗忘，这个链接可以帮到你： <a href="https://en.wikipedia.org/wiki/Gray_code">格雷码-wikipedia</a></p><h3 id="2、模块规格"><a href="#2、模块规格" class="headerlink" title="2、模块规格"></a>2、模块规格</h3><p>我们的格雷码计数器端口定义如下：</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.4.1.png" class="" title="p1.0.4.1.png"><p>我们要实现的功能如下：</p><h4 id="1、-在任意一个时钟上升沿到来的时候，如果复位信号有效，则将计数器清零；"><a href="#1、-在任意一个时钟上升沿到来的时候，如果复位信号有效，则将计数器清零；" class="headerlink" title="1、 在任意一个时钟上升沿到来的时候，如果复位信号有效，则将计数器清零；"></a>1、 在任意一个时钟上升沿到来的时候，如果复位信号有效，则将计数器清零；</h4><h4 id="2、-每个时钟上升沿到来的时候，如果使能信号有效，计数器的值-1；"><a href="#2、-每个时钟上升沿到来的时候，如果使能信号有效，计数器的值-1；" class="headerlink" title="2、 每个时钟上升沿到来的时候，如果使能信号有效，计数器的值+1；"></a>2、 每个时钟上升沿到来的时候，如果使能信号有效，计数器的值+1；</h4><h4 id="3、-在满足1时，即使2的条件满足，也不必执行2；"><a href="#3、-在满足1时，即使2的条件满足，也不必执行2；" class="headerlink" title="3、 在满足1时，即使2的条件满足，也不必执行2；"></a>3、 在满足1时，即使2的条件满足，也不必执行2；</h4><h4 id="4、-计数器初值为0；"><a href="#4、-计数器初值为0；" class="headerlink" title="4、 计数器初值为0；"></a>4、 计数器初值为0；</h4><h4 id="5、-当计数器的值在-1后出现溢出的情况时，将会回到零，同时从发生溢出的这个时钟上升沿开始，溢出标志位将会持续输出1，直到计数器被清零为止（其余情况下溢出标志位必须为0）。"><a href="#5、-当计数器的值在-1后出现溢出的情况时，将会回到零，同时从发生溢出的这个时钟上升沿开始，溢出标志位将会持续输出1，直到计数器被清零为止（其余情况下溢出标志位必须为0）。" class="headerlink" title="5、 当计数器的值在+1后出现溢出的情况时，将会回到零，同时从发生溢出的这个时钟上升沿开始，溢出标志位将会持续输出1，直到计数器被清零为止（其余情况下溢出标志位必须为0）。"></a>5、 当计数器的值在+1后出现溢出的情况时，将会回到零，同时从发生溢出的这个时钟上升沿开始，溢出标志位将会持续输出1，直到计数器被清零为止（其余情况下溢出标志位必须为0）。</h4><p>示范波形：</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.4.2.png" class="" title="p1.0.4.2.png"><p>为了方便大家设计，这里附上3位格雷码的计数方式：</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.4.3.png" class="" title="p1.0.4.3.png"><h3 id="3、要求"><a href="#3、要求" class="headerlink" title="3、要求"></a>3、要求</h3><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名: gray</li></ul><h3 id="P1L0表达式状态机-Verilog表达式状态机-P1-Q5"><a href="#P1L0表达式状态机-Verilog表达式状态机-P1-Q5" class="headerlink" title="P1L0表达式状态机-Verilog表达式状态机(P1.Q5)"></a>P1<em>L0</em>表达式状态机-Verilog表达式状态机(P1.Q5)</h3><h3 id="提交要求-1"><a href="#提交要求-1" class="headerlink" title="提交要求"></a>提交要求</h3><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>计算机经常用于处理关于表达式的问题。现在有这样一类表达式F的字符串需要你来验证它们的合法性：</p><p>1、表达式F中只含有数字0-9，加号+，乘号*。</p><p>2、表达式F可以按如下的规则产生：</p><p>a. 单个数字[0-9]是F； b. 如果<strong>X</strong>是F，<strong>Y</strong>是F，<strong>X+Y</strong>也是F； c. 如果<strong>X</strong>是F，<strong>Y</strong>是F，<strong>X*Y</strong>也是F。</p><p>排除显而易见的所用符号不合法，所有的非法情况总结如下：</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.6.1.png" class="" title="p1.0.6.1.png"><p>现在，我们需要你用Verilog HDL语言设计一个有限状态机来识别这样的表达式。</p><h3 id="2、模块规格-1"><a href="#2、模块规格-1" class="headerlink" title="2、模块规格"></a>2、模块规格</h3><p>模块名：<strong>expr</strong></p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.5.1.png" class="" title="p1.0.5.1.png"><h3 id="3、功能要求"><a href="#3、功能要求" class="headerlink" title="3、功能要求"></a>3、功能要求</h3><p>每个时钟上升沿，状态机从 in 中读入一个ASCII编码的字符。假设读入的第i个字符为ci，则第n个时钟上升沿时，可以拼出一个字符串:</p><p>s=c1c2….cn</p><p>我们需要你此时判断 s 是否符合表达式F的定义。假如s符合F的定义，那么 out 应输出1，否则输出0。</p><p>另外，每个 clr 上升沿时，请清零状态；如果 clk 的上升沿时 clr 为 1，也需要清零状态。清零后，上面定义的字符串s也应从空串开始计算。如果s当前是空串，out也应输出0。注意，我们不需要你分析表达式的语法和语义，只要判断形式上合法性就可以正确求解。</p><h3 id="4、输入输出样例"><a href="#4、输入输出样例" class="headerlink" title="4、输入输出样例"></a>4、输入输出样例</h3><p>时序规范：总是保证in信号稳定时clk才产生上升沿。</p><p>输入：s = <strong>1+2+3+4</strong> 输出：out = 1</p><p>输入：s = <strong>1+2+3+</strong> 输出：out = 0</p><p>示范波形（输入：s=<strong>1+2*3</strong>, 清零一周期, s’=<strong>1+2*3</strong>。时钟周期10ns）：</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/p1.0.4.3__1_.png" class="" title="p1.0.4.3 1.png"><h3 id="5、提交要求"><a href="#5、提交要求" class="headerlink" title="5、提交要求"></a>5、提交要求</h3><ul><li>必须严格按照模块的端口定义。</li><li>文件内模块名: <strong>expr</strong></li><li>注意由于 <code>string</code> 是 SystemVerilog 的保留字，本题模块名改为 <strong>expr</strong>。</li></ul><h3 id="P1-L1-BlockChecker-语句块检查模拟-附加题"><a href="#P1-L1-BlockChecker-语句块检查模拟-附加题" class="headerlink" title="P1_L1_BlockChecker-语句块检查模拟(附加题)"></a>P1_L1_BlockChecker-语句块检查模拟(附加题)</h3><p>本题为附加题，通过与否不计入P1课下通过条件。</p><p>现在需要你用Verilog语言编写一个模拟语句块检查的工具。</p><p>为了简化要求，<strong>输入由ASCII字母和空格组成</strong>。一个或多个连续出现的字母构成一个单词，单词<strong>不区分大小写</strong>，单词之间由一个或多个空格分隔开。检查工具检查<strong>自复位之后的输入中</strong>，begin和end是否能够匹配。</p><p>匹配规则类似括号匹配：一个begin只能匹配一个end，但是一个匹配的begin必须出现在对应的end之前；允许出现嵌套；最后若出现不能按上述规则匹配的begin或end，则匹配失败。</p><p>输入的读取在<strong>时钟上升沿</strong>进行。</p><p>匹配示例：Hello world，begin comPuTer orGANization End。</p><p>不匹配示例：eND，beGin study。</p><p><strong>建议大家认真查看示例波形。</strong></p><p>模块端口定义如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">信号名</th><th style="text-align:left">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">clk</td><td style="text-align:left">I</td><td style="text-align:left">时钟信号</td></tr><tr><td style="text-align:left">reset</td><td style="text-align:left">I</td><td style="text-align:left">异步复位信号（高电平有效，复位时将输入记录清空）</td></tr><tr><td style="text-align:left">in[7:0]</td><td style="text-align:left">I</td><td style="text-align:left">当前输入字符的ASCII码</td></tr><tr><td style="text-align:left">result</td><td style="text-align:left">O</td><td style="text-align:left">当前输入是否能够完成begin和end的匹配</td></tr></tbody></table></div><h3 id="提交要求-2"><a href="#提交要求-2" class="headerlink" title="提交要求"></a>提交要求</h3><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名：BlockChecker</li><li><strong>模块内不要包含任何$display语句</strong> ，以防造成误判</li><li>我们保证在使用模块前进行复位</li><li><strong>保证输入的单词数和单词长度均小于2^32</strong></li></ul><h3 id="示例波形"><a href="#示例波形" class="headerlink" title="示例波形"></a>示例波形</h3><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/example_blockchecker.png" class="" title="example_blockchecker.png"><h2 id="思路与题解"><a href="#思路与题解" class="headerlink" title="思路与题解"></a>思路与题解</h2><p>好了那么进入正题，我们依次看每道题目。可以说前三题都是白送，只需要你会一点Verilog的语法即可。时序逻辑两道题稍有新意，BlockChecker相当有难度。</p><h3 id="T1-splitter"><a href="#T1-splitter" class="headerlink" title="T1-splitter"></a>T1-splitter</h3><p>四行代码搞定，依次<code>assign</code>为输入中对应的八位即可，不多解释。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> splitter(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] A,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] O1,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] O2,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] O3,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] O4<br>    );<br><span class="hljs-keyword">assign</span> O1=A[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>];<br><span class="hljs-keyword">assign</span> O2=A[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>];<br><span class="hljs-keyword">assign</span> O3=A[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>];<br><span class="hljs-keyword">assign</span> O4=A[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>如果你是初学者<del>（虽然不应该，pre都学过语法了）</del>，注意一下是从大往小写<code>[7:0]</code>而非<code>[0:7]</code>就行。</p><h3 id="T2-ALU"><a href="#T2-ALU" class="headerlink" title="T2-ALU"></a>T2-ALU</h3><p>没错，这个模块将会在将来的P4中遇到，还是很重要的。只要学会使用<code>switch-case</code>语句就行了（当然你就<code>if-else if</code>也不是不行），仍然是组合逻辑，可以选择<code>assign</code>和三目运算符直接解决，或者<code>always @(*)</code>里面使用条件语句。因为情况较多，而且后者好加语句和后续维护，我倾向于使用后者。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">case</span> (ALUOp)<br><span class="hljs-number">3&#x27;b000</span>:<br>C=A+B;<br><span class="hljs-number">3&#x27;b001</span>:<br>C=A-B;<br><span class="hljs-number">3&#x27;b010</span>:<br>C=A&amp;B;<br><span class="hljs-number">3&#x27;b011</span>:<br>C=A|B;<br><span class="hljs-number">3&#x27;b100</span>:<br>C=A&gt;&gt;B;<br><span class="hljs-number">3&#x27;b101</span>:<br>C=<span class="hljs-built_in">$signed</span>(A)&gt;&gt;&gt;(&#123;<span class="hljs-number">1&#x27;b0</span>,B[<span class="hljs-number">30</span>:<span class="hljs-number">0</span>]&#125;);<br><span class="hljs-keyword">default</span> C=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>1.这里算数右移需要考虑符号，使用<code>$signed(A)</code>将其转换为有符号形式。其实这里比较意义不明，因为字节是$32$位的，两个右移最多$5$位有效，否则相当于在循环移。在搭建单周期$CPU$时这里会有改动。</p><p>2.建议所有条件语句都加上<code>default</code>或者<code>else</code>，以免产生锁存器，增强鲁棒性。</p><h3 id="T3-EXT"><a href="#T3-EXT" class="headerlink" title="T3-EXT"></a>T3-EXT</h3><p>这题很简单，就是一个条件语句+信号位拼接的题，但我甚至卡在了编译那块，不知道为什么报语法错误。实际上还是我对拼接的语法理解模糊，少套了一层大括号。变量信号<code>x[y:z]</code>是不用加一层大括号的，但是若干个常数和信号就要了，比如<code>&#123;16&#123;1&#39;b0&#125;&#125;</code>，会显得大括号很多。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> ext(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] imm,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] EOp,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ext<br>    );<br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">case</span> (EOp)<br><span class="hljs-number">2&#x27;b00</span>:<br>ext=&#123;&#123;<span class="hljs-number">16</span>&#123;imm[<span class="hljs-number">15</span>]&#125;&#125;,imm&#125;;<br><span class="hljs-number">2&#x27;b01</span>:<br>ext=&#123;&#123;<span class="hljs-number">16</span>&#123;<span class="hljs-number">1&#x27;b0</span>&#125;&#125;,imm&#125;;<br><span class="hljs-number">2&#x27;b10</span>:<br>ext=&#123;imm,&#123;<span class="hljs-number">16</span>&#123;<span class="hljs-number">1&#x27;b0</span>&#125;&#125;&#125;;<br><span class="hljs-number">2&#x27;b11</span>:<br>ext=&#123;&#123;<span class="hljs-number">14</span>&#123;imm[<span class="hljs-number">15</span>]&#125;&#125;,imm,<span class="hljs-number">2&#x27;b00</span>&#125;;<br><span class="hljs-keyword">default</span>: ext=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="T4-gray"><a href="#T4-gray" class="headerlink" title="T4-gray"></a>T4-gray</h3><p>其实只是计时器，把数字$0-7$重新”编码“了一下而已。最开始写着写着忘了这事。后来我在想怎么把格雷码和$cnt$一一对应上呢？我便去百度了一下，查到：</p><script type="math/tex; mode=display">G_i=B_i ~\oplus ~ B_{i+1}~~ (0\leq i\leq n-1)</script><p>$G_i$为格雷码的每一位，$B_i$是二进制码的每一位，约定$B_n=0$。这样我们很快就能做出来。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> gray(<br>    <span class="hljs-keyword">input</span> Clk,<br>    <span class="hljs-keyword">input</span> Reset,<br>    <span class="hljs-keyword">input</span> En,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] Output,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> Overflow<br>    );<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] cnt;<br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> Clk) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(Reset) <span class="hljs-keyword">begin</span><br>Overflow&lt;=<span class="hljs-number">0</span>;<br>cnt&lt;=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">3&#x27;b111</span> &amp;&amp; En==<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>cnt&lt;=<span class="hljs-number">0</span>;<br>Overflow&lt;=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>cnt&lt;=cnt+En;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">assign</span> Output=&#123;cnt[<span class="hljs-number">2</span>],&#123;cnt[<span class="hljs-number">2</span>]^cnt[<span class="hljs-number">1</span>]&#125;,&#123;cnt[<span class="hljs-number">0</span>]^cnt[<span class="hljs-number">1</span>]&#125;&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="T5-expr"><a href="#T5-expr" class="headerlink" title="T5- expr"></a>T5- expr</h3><p>一个状态转移图略显奇怪的有限状态机，实际上只需要三个状态就行了。初始$S_0$，符号结尾$S_1$，数字结尾（合法序列）$S_2$，已经非法了的状态$S_3$。</p><img src="/2025/10/01/P1%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/FSM.jpg" class="" title="FSM"><p>或者从另一种角度来看，$S_1$是暂时非法的状态，$S_2$是暂时合法，$S_3$是永久非法，除非$reset$否则无法跳出。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> expr(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> clr,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> out<br>    );<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] status;<br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> clr) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(clr) <span class="hljs-keyword">begin</span><br>status&lt;=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">case</span> (status)<br><span class="hljs-number">0</span>:<br><span class="hljs-keyword">if</span>(in==<span class="hljs-number">8&#x27;d42</span> || in==<span class="hljs-number">8&#x27;d43</span>) status&lt;=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span> status&lt;=<span class="hljs-number">2</span>;<br><span class="hljs-number">1</span>:<br><span class="hljs-keyword">if</span>(in==<span class="hljs-number">8&#x27;d42</span> || in==<span class="hljs-number">8&#x27;d43</span>) status&lt;=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span> status&lt;=<span class="hljs-number">2</span>;<br><span class="hljs-number">2</span>:<br><span class="hljs-keyword">if</span>(in==<span class="hljs-number">8&#x27;d42</span> || in==<span class="hljs-number">8&#x27;d43</span>) status&lt;=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> status&lt;=<span class="hljs-number">3</span>;<br><span class="hljs-number">3</span>:<br>status&lt;=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">default</span>: status&lt;=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">assign</span> out=(status==<span class="hljs-number">2</span>)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>字符可以用双引号引起来使用，免得像我这里一样查<code>ascii</code>表。</li><li>可以看出其实是$Moore$型有限状态机，虽然题目没有明说，做的时候我也没有考虑这些。</li></ol>]]></content>
    
    
    <categories>
      
      <category>CO课下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>CO课下</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P0课下-总结反思文档</title>
    <link href="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/"/>
    <url>/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P0课下-总结反思文档"><a href="#P0课下-总结反思文档" class="headerlink" title="P0课下-总结反思文档"></a>P0课下-总结反思文档</h1><p>本次课的实验教程相当完善，按部就班走就没有大问题，会有一些细节理解上的偏差和纠结。我们先把教程上知识点及引导部分放上来。</p><h2 id="1-如何设计电路模块"><a href="#1-如何设计电路模块" class="headerlink" title="1.如何设计电路模块"></a>1.如何设计电路模块</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>相信通过之前数个教程的学习，你已经对我们将要使用的工具——Logisim 与 ISE 已经比较熟悉。从这个 Project 开始，我们将要使用这两个工具来进行数字电路元件的设计。在我们这个 Project 中我们将主要关注 Logisim 组合电路和时序电路的设计。</p><h3 id="电路设计的目标"><a href="#电路设计的目标" class="headerlink" title="电路设计的目标"></a>电路设计的目标</h3><p>电路设计需要有一个“需求”——电路的功能与特性，这是我们电路设计的目标。如果我们从某个电路的用户角度看，我们实际上也是把电路本身作为一个“<strong>黑箱</strong>”，不关心其中的实现。因此我们自己在设计电路时，比起具体的实现，我们最先需要关心的就是电路的功能与特性。所谓磨刀不误砍柴功，通过对电路功能的深度理解和详细设计，我们往往能够在设计中节省很多精力，下面就给大家介绍一种规范需求的方法——端口定义表。</p><p><img src="P0-1-1.png" alt="P0-1-1"></p><p>上图是一个 8 位加法器最为简单的定义表，定义了它有 5 个信号，8 位信号 A、B、SUM，1 位信号 C0 和 Overflow。方向中用 I 代表 Input 输入，用 O 代表 Output 输出。描述一栏用汉语对加法器进行了简单的描述。信号的语法遵循了类似 Verilog HDL 中的写法，如此，通过这个简单的端口定义表，我们就能够知晓我们这个 8 位加法器应该做什么。</p><p>对于更复杂的电路，我们会使用两张表。</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-1-2.png" class="" title="P0-1-2"><p>一张模块接口定义表与一张功能定义表，原因是对于这些复杂电路来说，简单的端口定义已经无法识别其功能，或者该模块在不同的情况与输入下有不同的功能，这种时候我们需要使用功能定义表来对模块的功能进行约定。</p><p>在对我们设计的电路有了如此合理，无歧义的设计目标后，我们才能去动手实现真正的电路。我们需要把设计与实现这两项工作分开来保证我们在工程中较高的完成率。<strong>因此，建议，或者说要求，大家在之后我们的电路设计作业中，先要对模块的端口和功能进行书面化的定义，可以不拘泥于具体形式，但是一定要是可供他人阅读，立马明白模块功能的，</strong>再去进行实际的设计，我们不希望看到最终你设计的电路出问题是从功能定义上就出了毛病。我们之后的练习题部分也将会给出定义表供大家参照。</p><h3 id="分析目标并划分层次"><a href="#分析目标并划分层次" class="headerlink" title="分析目标并划分层次"></a>分析目标并划分层次</h3><p>在定义清楚设计的目标之后，我们需要对我们的实现目标进行分析——这是一个时序电路？还是一个无状态的纯组合电路？它需要同时有多个功能吗？需要分层化设计吗？需要模块化设计么？——解决这些问题的过程，其实就是完成实现的过程。而这些问题往往也与实际的模块要求有关系，之后我们将用具体的实例来进行说明。</p><p>模块设计相信大家在理论课以及前面的指导中已经有所耳闻，在这里需要提的一点是<strong>分层</strong>的设计思想，在计算机科学中领域中有一句名言，<strong>“在计算机科学中的任何问题都可以通过增加一个间接层来解决”（Any problem in computer science can be solved with another layer of indirection. ）。</strong>这句话即使是在电路设计这个偏硬的领域下也是有效的，以 32 位加法器为例，初拿到手，可能会觉得无所适从，输入是两个 32 位数，输出是一个 32 位数，关系虽然抽象上简单，但是并不能简单地用门电路概括。但是如果我们添加一个“一位加法器”的间接层。使用 1 位加法器拼出一个 32 位加法器比较简单，单独拼出一个 1 位加法器也很简单。如此，问题就解决了！可见分层的威力，希望大家在设计时也要重视这种思想，当然，<strong>分层</strong>的思想在后续课程中可能会和大家一次又一次的见面，记得和熟人打个招呼！</p><h3 id="电路搭建与注意事项"><a href="#电路搭建与注意事项" class="headerlink" title="电路搭建与注意事项"></a>电路搭建与注意事项</h3><p>在完成设计阶段后，具体的实现比起来可能只是一些小 case，通过我们关于工具的知识，可以把我们的设计变为具体的元件组合，这一点我们将在之后的示例里看的更加清楚。具体到工具上，在 Logisim 中，需要注意布线、器件设置等，在 Verilog 中，需要注意位宽一致、命名正确等。这里就是要考察大家的基本功啦！</p><p>在搭建功能较为复杂，重复性部件较多的电路（如通用寄存器堆）时，如果全部使用手工搭建会消耗较多时间，过程中也容易产生接线错误等问题。我们可以尝试采用代码生成 XML 文本等<a href="https://d.buaa.edu.cn/http/77726476706e69737468656265737421f3e44293353526526b0988e29d51367b9787/tutorial/logisim/logisim-6/logisim-6-4/">自动化方法</a>来辅助进行模块搭建。无论是手工搭建还是自动生成，建议同学们在完成 Logisim 电路后仔细检查模块外观、布线与接线、功能等是否正常，避免产生不必要的麻烦。</p><p>当然，我们也在此给出一些具体实现中常常遇到的一些问题，便于大家早点发现问题进行排除：</p><h4 id="多驱动"><a href="#多驱动" class="headerlink" title="多驱动"></a>多驱动</h4><p>这是指一个变量有两个以上的赋值源。这一般是由于对于某一输出源，存在多个路径向其提供输出值，对于这种情况，Logisim 也会识别并将相关线路标红。</p><p>具体而言，这可能是<strong>一个输入源经过不同的运算对其输出不同的值引起的：</strong></p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-1-3.png" class="" title="P0-1-3"><p>上述例子中，同一输入存在两条不同的路径到达输出，导致了多驱动。</p><p>也可能是由于<strong>多个输入源对其输出不同值引起的：</strong></p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-1-4.png" class="" title="P0-1-4"><p>上述例子中，多个输入源同时驱动输出，导致了多驱动</p><p>在 Verilog 中，也同样存在着这样的情况：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> signal_1 = a ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span><br><span class="hljs-keyword">assign</span> signal_1 = b ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span><br></code></pre></td></tr></table></figure><h4 id="组合逻辑环路"><a href="#组合逻辑环路" class="headerlink" title="组合逻辑环路"></a>组合逻辑环路</h4><p>这是指不经过任何时序逻辑（寄存器等），而直接将组合逻辑电路的输出信号反馈到其输入节点而形成的环路。这一般是由于<strong>电路中存在输出直接作为该输出的输入而导致的：</strong></p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-1-5.png" class="" title="P0-1-5"><p>上述例子中，输出又直接作为了输入的一部分（MUX 选择条件）接入到了输入中，导致电路发生震荡。Logisim 识别并将相关线路标注为蓝色。</p><p>同样，在 Verilog 中，也同样存在着这样的情况：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">assign <span class="hljs-keyword">BHR_Violent </span>= (Delay_BHR_Hash_Write_PC == <span class="hljs-keyword">BHR_Hash_Read_PC);</span><br><span class="hljs-keyword"></span>assign <span class="hljs-keyword">BHR_Hash_Read_PC </span>= <span class="hljs-keyword">BHR_Violent </span>? hash_10(Now_PC) + <span class="hljs-number">1</span> : hash_10(Now_PC);<br></code></pre></td></tr></table></figure><p>上述例子中，BHR_Violent 的计算需要 BHR_Hash_Read_PC 的值，但是 BHR_Hash_Read_PC 的计算同样需要 BHR_Violent 的值，这样导致了一个组合逻辑上的回路。</p><p><strong>当然，Logisim 线路颜色表达的含义不局限于以上的几种情况，希望大家在电路搭建时不要盲目依赖 Logisim 或者 ISE 给出的线路颜色或者错误信息，而应该在参考的基础上仔细思考搭建时产生的问题。</strong></p><h3 id="电路搭建与测试"><a href="#电路搭建与测试" class="headerlink" title="电路搭建与测试"></a>电路搭建与测试</h3><p>在完成了搭建后，测试是个必不可少的环节，尽管这次我们搭建了自动测试平台，所有的文件可以自动测试，但是在实际环境中，测试这项工作更多也需要设计者来进行一定的自我测试，来避免一些显而易见的错误。而测试的基本原则就是根据我们的端口定义和功能定义表，对各种可能的输入情况进行排查，观察是否有与定义违背的情况，或者在输入未定义信号的时候会不会产生一些非常危险的行为。</p><h4 id="测试样例设计"><a href="#测试样例设计" class="headerlink" title="测试样例设计"></a>测试样例设计</h4><p>有限的输入可能性可以穷举，但是需要消耗大量时间；无限的输入可能性无法穷举；无论是什么情况，我们都不可能枚举所有输入以求测试的覆盖性，因此最好的方法是使用有代表性的，有“价值”的测试数据进行测试，而测试数据的价值可以体现在很多方面，不同情境下我们对“价值”的定义不同。在这里我们给出几种样例生成的参考方向，以供大家在实践中使用，但是如何设计更多潜在有价值的测试数据，还需要同学们靠不断的练习来摸索并积累经验！</p><ul><li>覆盖所有测试功能正常进行的样例</li><li>极端情况的样例</li><li>异常情况的样例</li></ul><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><p>为了提高测试效率，我们可以使用 Pre 提到的 <a href="https://d.buaa.edu.cn/http/77726476706e69737468656265737421f3e44293353526526b0988e29d51367b9787/tutorial/logisim/logisim-6/logisim-6-5/">自动化测试</a> 方法！</p><p>大家看完上面的设计和测试方法可能还一头雾水，不过不用担心，下面我们将通过 CRC 校验码的例子来带大家深入体会整个流程！</p><blockquote><p>笔者的话：其实，我个人并不认为“具体的实现比起来可能只是一些小 case”，往往问题就出现在搭建过程中，感觉这需要一定的积累。自动化方法我至今都不会，我不知道学起来会不会太费时，毕竟只有P0，P3需要用Logisim。本篇中端口定义表是极其重要的，它将贯穿整个CO。</p></blockquote><h2 id="2-CRC-校验码计算电路的设计与测试"><a href="#2-CRC-校验码计算电路的设计与测试" class="headerlink" title="2.CRC 校验码计算电路的设计与测试"></a>2.CRC 校验码计算电路的设计与测试</h2><p>在这个部分中，你将从需求开始一步一步搭建我们所要求的 ８ 位 CRC 校验码计算电路。我们希望在这个简单的例子中，你能体会到方法性的东西，并应用到之后的设计中去。这对之后的学习和<strong>课上测试</strong>都是很有帮助的，请各位谨记。</p><h3 id="CRC-校验码简介"><a href="#CRC-校验码简介" class="headerlink" title="CRC 校验码简介"></a>CRC 校验码简介</h3><p>CRC 校验是数据通信领域中最常用的一种查错校验方式，它对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。（“帧” 在本章指的是数据的二进制码）</p><p>在了解这种校验码怎么计算之前，我们需要先了解一种特殊的除法:“模二除法”。它与算术除法类似，但在做减法时既不向上借位，也不比较除数和被除数相同位数值的大小；它的运算法则为 <code>1-1=0</code>，<code>0-1=1</code>，<code>1-0=1</code>，<code>0-0=0</code>，例如 <code>1100-1001=0101</code>。对于模二除法，我们以被除数为 1011，除数为 10 为例，运算过程如下：</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-3-1.png" class="" title="P0-3-1"><p>如果细心的话，你会发现，模二除法中的减法和异或的效果是相同的，所以模二除法可以用异或来完成。</p><p>知道了模二除法的计算过程，CRC 校验码的计算就很简单了。我们只需要将原帧补上（除数位数 - 1）个 0 作为被除数，然后进行模二除法即可。举个例子，我们要发送的帧 A 为 10011，发送端和接收端共同选定的除数 B 为 1110。因为 B 是 4 位二进制数，我们需要在 A 的后面补上 3 个 0，从而得到 A’=10011000。我们将 A’ 作被除数，B 作除数，进行“模二除法”。如下图：</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-3-2.png" class="" title="P0-3-2"><p>最后得到的余数是一个三位数（注意如果不是三位，也要在前面补零来凑齐三位），这就是要求的校验码。我们将得到的校验码 110 拼接在原数据帧的后面，就得到了要发送的新帧 A’’=10011110。这样就完成了 CRC 校验码的生成。</p><h3 id="CRC-校验码计算电路的定义"><a href="#CRC-校验码计算电路的定义" class="headerlink" title="CRC 校验码计算电路的定义"></a>CRC 校验码计算电路的定义</h3><p>在普通的设计流程中，一般都是用汉语描述电路的功能，需要我们自己来进行形式化的定义，不过由于我们这个例子相对简单，因此直接给出我们 ８ 位 CRC 校验码计算电路的端口定义。</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-3-3.png" class="" title="P0-3-3"><h3 id="分析目标并层次化"><a href="#分析目标并层次化" class="headerlink" title="分析目标并层次化"></a>分析目标并层次化</h3><p>初拿到如上表的需求，可以发现这是一个没有状态的部件，自身内部不存储信息，单纯的输入就决定了输出，因此有一种相当暴力的思路就是直接画出真值表，输入总共 11 位 2 进制码（考虑到除数的最高位一定为 1），输出 11 位二进制码，我们需要动 2048 下手指才可以把真值表画出来——似乎繁琐了点？我们需要更加简单的方法。但是希望大家明白真值表法永不过时，在输入输出比较小时是非常实用的方法，并且可以使用相关工具自动生成电路。</p><p>我们仔细分析一下，其实类似除法的计算方法，我们可以把这个计算过程分解为多次进行被除数为 4 位的除法计算。因此我们引入“4 位模二除法器”这个间接层，这样问题就变成了两个部分:</p><ul><li>设计四位模二除法器</li><li>使用四位模二除法器搭建 8 位 CRC 校验码计算电路</li></ul><p>为了方便理解，我们的给出了一种四位模二除法器的端口定义（这只是为了讲解时参考，你在设计时不一定要遵循这个定义）</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-3-4.png" class="" title="P0-3-4"><p>我们知道，模二除法和异或运算是等价的，所以对于一个四位除四位的模二除法器，如果被除数的最高位是 1，则商 1，余数使用异或门来将四位被除数和四位除数异或即可。当然，如果被除数的最高位是 0，则商为 0，余数直接等于被除数了。</p><p>这个电路搭建很简单，我们只需要判断下被除数的最高位，然后分情况输出即可。</p><p>搭建完四位的除法器，我们再来看看怎么使用这个简单的电路来搭建我们所需要的复杂电路。类似于普通除法的过程，我们计算模二除法时也是每次从被除数中取出一定的位数（对于该问题来说是四位）来和除数相除，除得的余数再补上一位被除数后继续与除数相除。如此，计算过程就相当于进行多次四位的模二除法了。我们要做的就是将上一个四位模二除法器的余数输出，拼接一位被除数作为下一个四位模二除法器的被除数输入(除数始终是同一个数),如此反复直到被除数所有的位都被使用。</p><h3 id="具体搭建（-LOGISIM-）"><a href="#具体搭建（-LOGISIM-）" class="headerlink" title="具体搭建（ LOGISIM ）"></a>具体搭建（ LOGISIM ）</h3><p>在 Logisim 搭建上述电路时还需注意：</p><ul><li>可以使用 <a href="https://d.buaa.edu.cn/http/77726476706e69737468656265737421f3e44293353526526b0988e29d51367b9787/tutorial/logisim/logisim-2/logisim-2-3/">Tunnel</a> 来表示中间变量简化布线</li><li>可以改变门电路输入数简化电路</li><li>这个电路并不是最简的，可以使用逻辑方法优化</li></ul><p>综上，我们可以在完成了设计工作的基础上使用 Logisim 进行电路搭建啦！</p><h3 id="测试与验证"><a href="#测试与验证" class="headerlink" title="测试与验证"></a>测试与验证</h3><h4 id="测试样例设计-1"><a href="#测试样例设计-1" class="headerlink" title="测试样例设计"></a>测试样例设计</h4><p>正如前文所述，开发者的自我测试在开发过程中是十分重要，这里我们就以刚搭建的 8 位 CRC 校验码计算电路为例来说明如何进行测试样例的设计。对于我们这里的组合电路，测试样例要覆盖所有的输入。因此最简单直接的想法就是将所有的二进制输入依次尝试一遍。在我们的电路中，共需尝试 2048 组输入。这种方法的好处就是保证彻底的覆盖性，缺点也很明显，需要过多的操作。在面对更复杂电路时，我们需要更加合理的样例。一种比较合理的方法是根据功能来设计相关的样例：</p><ul><li>覆盖所有测试功能正常进行的样例（如 A:11001010 B:1011, A:01001110 B:1100）</li><li>极端情况的样例（如：A:00000000 B:1000）</li><li>异常情况的样例（如：A:110X010X B:XXXX，这个 X 的输入在 Logisim 也是支持的）</li></ul><p>在设计出相应的测试样例后，需进行相关的输入观测现象，为了使测试电路更加简洁，我们将使用已经设计好的子电路进行测试，下面介绍子电路。</p><h4 id="子电路"><a href="#子电路" class="headerlink" title="子电路"></a>子电路</h4><p>我们在 Pre 中学习了子电路的使用，不知道同学是否有尝试过。在 P0 中，随着电路<strong>逐渐复杂化</strong>，我们需要子电路的帮助来完成整体电路。</p><p>其实子电路和<strong>子函数</strong>有一定的相似性。我们可以把合作完成同一功能的电路封装为一个子电路，再像 main 中调用子函数那样多处进行引用，减少重复且不必要的电路搭建，一定程度上减少我们的工作量。同时，由于 Logisim 是在画布上完成我们的任务，利用子电路也可以让我们整个画布更加<strong>简洁清楚</strong>。</p><p>同时，也可以把一部分相互依赖性高且线路连接复杂的电路封装成一个子电路，虽然可能不会有其他地方也利用这个子电路，但是由于 Logisim 没有很好的 debug 的方式，利用这个方式可以通过测试<strong>保证每个子电路的正确性</strong>，进而确定我们提交电路的正确性。</p><h5 id="如何使用子电路"><a href="#如何使用子电路" class="headerlink" title="如何使用子电路"></a>如何使用子电路</h5><p>为了提高使用子电路的效率，我们可以通过外观编辑界面以更改电路外观的形状及端口位置；通过更改 layout 为子电路及其相应端口设置 Label ，进而区分相同子电路的不同引用，并对子电路的输入输出进行命名（在引用时鼠标悬停即可查看其自定义名称），在引用子电路的同时可以更清楚其信息。</p><p>同时，在进行电路测试的时候，应该也测试每个子电路的功能，之后再对整个电路进行测试。如此可以减轻工作量，更快地完成测试工作。</p><p>在之后的题目中，虽然不用子电路也可以完成任务，但希望同学们可以尝试着使用子电路。</p><p>这里给出测试电路示例：(“CRC” 为你需要搭建的电路)</p><p>我们将设计好的 CRC 电路进行封装，并命名为 “CRC”，在测试电路中，A、B 为输入观测值，C 为输出观测值，“CRC” 以子电路的形式出现。</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-3-5.png" class="" title="P0-3-5"><h2 id="3-Logisim-中的有限状态机"><a href="#3-Logisim-中的有限状态机" class="headerlink" title="3.Logisim 中的有限状态机"></a>3.Logisim 中的有限状态机</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>经过理论课程和之前 Logisim 教程部分的学习，相信大家对有限状态机的基本知识已经有了充分的了解，也已经掌握了使用 Logisim 设计简单状态机的方法技巧。现在，我们帮助大家简单的回顾一下使用 Logisim 设计有限状态机的基本步骤，以帮助大家更快的适应 P0。</p><h3 id="使用-Logisim-设计有限状态机的基本步骤"><a href="#使用-Logisim-设计有限状态机的基本步骤" class="headerlink" title="使用 Logisim 设计有限状态机的基本步骤"></a>使用 Logisim 设计有限状态机的基本步骤</h3><p>使用 Logisim 设计有限状态机的过程基本上可以分为三个步骤： - 设计实现状态存储模块 - 设计实现状态转移模块 - 设计实现输出模块</p><p>以上三个模块是对有限状态机进行抽象后的三个主要方面。其中，状态转移模块和输出模块内是纯组合逻辑，不涉及时序逻辑。而状态存储模块则需要存储每个周期有限状态机的具体状态。它们之间的关系是，状态转移模块根据当前有限状态机的状态(即状态存储模块所存储的值)和当前的输入计算出有限状态机的下一状态值，当时钟上升沿到来时，这个新的状态值被存入状态存储模块中。输出模块的逻辑分为两种，根据输出逻辑的不同，有限状态机又被分为 Moore 型状态机和 Mealy 型状态机。它们之间具体的差别是，Moore 型状态机的输出逻辑仅与有限状态机当前状态值有关；而 Mealy 型状态机的输出逻辑则与有限状态机的当前状态和当前输入有关。</p><p>Moore 型状态机示例图</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-9-1.svg" class="" title="P0-9-1"><p>Mealy 型状态机示例图</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/P0-9-2.svg" class="" title="P0-9-2"><p>（注：上图模块从左至右分别是：状态转移，状态存储，输出）</p><h3 id="设计建议"><a href="#设计建议" class="headerlink" title="设计建议"></a>设计建议</h3><ol><li>分析具体问题，画出状态转移图</li><li>对状态进行合适的编码</li><li>画出状态转移和输出逻辑的真值表</li><li>在 Logisim 中实现状态转移和输出逻辑，并采用合适的存储器存储具体状态值</li></ol><hr><p>同学们可以重新回顾一下 pre 部分中 Logisim 的部分内容，我们可以通过通过 analyze circuit 的功能来完成状态机状态转移部分的内容。（在 project-analyze circuit 可以选择此功能）</p><p>这个功能让我们可以通过打表的方式表示 input 和 output 的关系。当然同学们可以选择自己搭建电路，或者通过更好地设计状态机来简化其状态转移的过程。</p><h3 id="有限状态机测试"><a href="#有限状态机测试" class="headerlink" title="有限状态机测试"></a>有限状态机测试</h3><p>在完成了对有限状态机的设计之后，我们还需要进行有限状态机的<strong>测试</strong>，正如我们在教程中学到的，测试一直是电路设计中一个非常重要的环节。但是由于 FSM 相比之前简单的组合电路更加复杂，因此其测试也会包含更多内容，可以概括为两个主要的部分——<strong>输出电路</strong>测试与<strong>状态转移</strong>电路测试。</p><p>如果我们仍采用在组合电路中采用的<strong>黑箱测试</strong>办法，直接将输入与输出联系起来 ，那么我们将会需要非常大数量的样例序列来进行测试，这种做法既不经济也不实用，因此我们不予采用。我们需要做的是，将<strong>输出电路</strong>测试与<strong>状态转移</strong>电路测试分开进行，记录状态信息。</p><p>如果我们将这两者分开，那么对于这两者来说，它们都是普通的组合电路，只需要使用我们之前的方法就可以完成相关测试，测试上的问题也就迎刃而解了。</p><div class="table-container"><table><thead><tr><th>思考题</th></tr></thead><tbody><tr><td>状态存储器的复位方式包括<strong>异步复位</strong>和<strong>同步复位</strong>，二者的定义分别是什么？两种复位方式在 Verilog 中可以通过什么语句句式实现？在 Logisim 中又可以通过什么样的电路框架实现？</td></tr><tr><td>在 Verilog 中我们可以通过<code>initial</code>块对状态存储器的初值进行定义，在 Logisim 中我们可以通过哪些电路框架实现赋初值的功能？</td></tr><tr><td>一个大型的 Logisim 电路设计可能会具有非常复杂的电路结构，你有哪些可以降低这种复杂性的设计方法？</td></tr></tbody></table></div><p>那么，教程部分结束，下面是题面及我的解答。</p><h2 id="4-P0题面"><a href="#4-P0题面" class="headerlink" title="4.P0题面"></a>4.P0题面</h2><h3 id="1-P0-L0-CRC-CRC校验-P0-Q1"><a href="#1-P0-L0-CRC-CRC校验-P0-Q1" class="headerlink" title="1.P0_L0_CRC:CRC校验(P0.Q1)"></a>1.P0_L0_CRC:CRC校验(P0.Q1)</h3><h4 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h4><p>使用Logisim搭建一个除数为四位，原数据帧为8位的CRC校验码计算电路。具体模块端口定义如下：</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/499-1.png" class="" title="499-1"><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名: <strong>CRC</strong></li><li>我们规定除数的最高位一定为1,不需要考虑最高位非1的情况</li><li><strong>注意:由于信号原帧位数为8位，进行除法运算时被除数应为8+3=11位</strong></li><li>测试电路：(CRC为你需要搭建的电路)</li></ul><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/499-2.png" class="" title="499-2"><ul><li><strong>注意:请保证模块的appearance与下图完全一致，否则有可能造成评测错误</strong>(查看模块appearance方法:在Logisim中打开相应模块后点击左上角</li></ul><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/499-4.png" class="" title="499-4"><h3 id="2-P0-L0-GRF-实现GRF-P0-Q2"><a href="#2-P0-L0-GRF-实现GRF-P0-Q2" class="headerlink" title="2.P0_L0_GRF:实现GRF(P0.Q2)"></a>2.P0_L0_GRF:实现GRF(P0.Q2)</h3><h4 id="提交要求-1"><a href="#提交要求-1" class="headerlink" title="提交要求"></a>提交要求</h4><p>使用Logisim搭建一个GRF。</p><p>GRF中包含32个32位寄存器，分别对应0~31号寄存器，其中0号寄存器读取的结果恒为0。具体模块端口定义如下：</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/269-1.png" class="" title="269-1"><p>模块功能定义如下：</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/269-2.png" class="" title="269-2"><ul><li>必须严格按照模块的端口定义</li><li><strong>0号寄存器读出的数据在任何时刻都为0</strong></li><li><strong>请使用寄存器部件来实现GRF中的32个寄存器</strong></li><li>文件内模块名: grf</li><li>测试电路：(grf为你需要搭建的电路)</li></ul><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/269-3.png" class="" title="269-3"><ul><li><strong>注意:请保证模块的appearance与下图完全一致，否则有可能造成评测错误</strong>(查看模块appearance方法:在Logisim中打开相应模块后点击左上角</li></ul><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/269-5.png" class="" title="269-5"><h3 id="3-P0-L1-navigation-2020：Logisim导航-P0-Q3"><a href="#3-P0-L1-navigation-2020：Logisim导航-P0-Q3" class="headerlink" title="3.P0_L1_navigation_2020：Logisim导航(P0.Q3)"></a>3.P0_L1_navigation_2020：Logisim导航(P0.Q3)</h3><h4 id="提交要求-2"><a href="#提交要求-2" class="headerlink" title="提交要求"></a>提交要求</h4><p>计小组要去机房上机考试，需要去B机房，但是目前他在A机房。他现在的时间很充裕，就决定生成一串随机序列，告诉他下一步行走的方向，直到走到B机房。他希望用Logisim搭建一个可以导航的Moore型有限状态机，来通过序列告诉他是否到达B机房。</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/393-1.png" class="" title="393-1"><p>题目要求：</p><p>计小组只能往东南西北四个方向行走，且若能行走，则每次<strong>只能行走一格</strong>。若下一步不存在机房让计小组行走，那么计小组会撞到墙壁并且<strong>hit置高一周期</strong>，此时计小组仍<strong>保持原地</strong>不会移动，等待下一周期再进行运动。（如果下一步依旧撞墙， 则hit仍然置高；若下一步不会撞墙，则计小组将会继续行进，hit在此周期置0）</p><p>计小组走到B机房后，<strong>“到达”信号需要置位</strong>，<strong>并保持一周期</strong>。到达B机房后计小组将会在下一周期回到原点，（下一周期的输入将被忽略掉）等待下下周期的输入，继续测试他的序列。</p><p>计小组遵循上北下南左西右东的方向完成操作。</p><p>计小组在时钟上升沿的时候就已经知道自己下一步的方向并且瞬移过去，并且立即做出判断。</p><p>端口定义：</p><div class="table-container"><table><thead><tr><th style="text-align:left">信号名</th><th style="text-align:left">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">dir[1:0]</td><td style="text-align:left">I</td><td style="text-align:left">表示行走的方向：00：向北走 01：向东走 10：向南走 11：向西走</td></tr><tr><td style="text-align:left">clk</td><td style="text-align:left">I</td><td style="text-align:left">时钟信号</td></tr><tr><td style="text-align:left">reset</td><td style="text-align:left">I</td><td style="text-align:left">异步复位信号</td></tr><tr><td style="text-align:left">arrive</td><td style="text-align:left">O</td><td style="text-align:left">是否到达</td></tr><tr><td style="text-align:left">hit</td><td style="text-align:left">O</td><td style="text-align:left">是否撞上墙壁</td></tr></tbody></table></div><p><strong>模块名</strong>：navigation</p><p><strong>必须严格按照模块的端口定义</strong></p><p><strong>测试电路</strong>：</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/393-3.png" class="" title="393-3"><p><strong>注意:请保证模块的appearance与下图完全一致，否则有可能造成评测错误</strong>(查看模块appearance方法:在Logisim中打开相应模块后点击左上角</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/393-2.png" class="" title="3932.png"><h3 id="P0-L0-FSM：Logisim中的FSM-P0-Q4"><a href="#P0-L0-FSM：Logisim中的FSM-P0-Q4" class="headerlink" title="P0_L0_FSM：Logisim中的FSM(P0.Q4)"></a>P0_L0_FSM：Logisim中的FSM(P0.Q4)</h3><h4 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h4><p>正则表达式是对字符串操作的一种逻辑公式，它通常被用来检索、替换符合某个模式的文本。它的规则比较复杂，我们现在只讲解其中比较简单的几种规则。</p><ul><li>[…]是指要匹配中括号中的字符(注意是字符不是字符串),比如[xyz]就是要匹配x y z这三个字符中的任意一个。</li><li>{…}是指要求匹配”{“前的那个字符几次，比如a{2}是指要匹配a两次，a{2,4}是指要匹配a 2至4次,a{,4}指要匹配a 0至4次，a{2,}指要匹配a 2至无穷次。所以[cd]{1,2}就是要求匹配(c或d)一次或两次,即cc、dd、cd、dc、c、d都是能匹配的。</li><li>(…)是指将()内的字符串视为一个整体，比如(ab){1,2}对应的就是ab或abab。</li><li>我们也可以将多条表达式组合起来，如a{2}b{2}就是指匹配a两次后再匹配b两次,即匹配aabb。</li></ul><h4 id="提交要求-3"><a href="#提交要求-3" class="headerlink" title="提交要求"></a>提交要求</h4><p>使用Logisim搭建一个Mealy型有限状态机 检测串行输入字符串中的能匹配正则表达式b{1,2}[ac]{2}的子串并输出。具体模块端口定义如下：</p><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>In[1:0]</td><td>I</td><td>串行方式输入字符串。 为简化电路，我们规定 00 表示 ‘a’，01 表示 ‘b’，10 表示 ‘c’，11 表示其他字符。</td></tr><tr><td>CLR</td><td>I</td><td>清除置位信号</td></tr><tr><td>Z</td><td>O</td><td>输出是否检测到了与表达式匹配的子串 1：检测到了 0：未检测到</td></tr></tbody></table></div><p>模块功能定义如下：</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/9-2.png" class="" title="9-2"><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名: fsm</li><li><strong>注意: 每当匹配到一个子串时，需要输出一次1。例如对字符串bacbacac,模块应当在第1个c输入和第2个c输入时输出1,而在其他时刻保持输出为0。</strong></li><li><strong>注意：有限状态机的设计是Mealy型有限状态机。</strong></li><li>测试电路如下：(code部分是你需要搭建的电路)</li></ul><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/9-3.png" class="" title="9-3"><ul><li><strong>注意:请保证模块的appearance与下图完全一致，否则有可能造成评测错误</strong>(查看模块appearance方法:在Logisim中打开相应模块后点击左上角</li></ul><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/9-5.png" class="" title="95.png"><h3 id="P0-L1-ftoi：ftoi-附加题"><a href="#P0-L1-ftoi：ftoi-附加题" class="headerlink" title="P0_L1_ftoi：ftoi(附加题)"></a>P0_L1_ftoi：ftoi(附加题)</h3><p>本题为附加题，通过与否不计入P0课下通过条件。</p><h4 id="提交要求-4"><a href="#提交要求-4" class="headerlink" title="提交要求"></a>提交要求</h4><p>使用Logisim进行组合逻辑设计，要求输入一个16位的单精度浮点数（符合IEEE-754标准），输出该浮点数的整数部分(包含符号)，用32位二进制符号数表示。具体说明如下：</p><p>IEEE-754 标准中一个半精度16位浮点数的表示方法:</p><script type="math/tex; mode=display">V_{float}=(-1)^S \times M \times 2^E</script><p>利用这种浮点数表示方法进行编码后的值可以分为4类，如下图所示</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/319-1.png" class="" title="319-1"><ul><li><p>S代表最高位符号位，由sign[15]位编码，规定$S=sign$；</p></li><li><p>E代表指数，由图中exponent[14:10]域编码，规定<strong>补码</strong>$E=exponent-01111_2$</p></li><li><p>M代表小数点后的二进制小数位，由图中frac[9:0]域编码，Normalized的情况$M$永远有一位前导1，因此不占位，相当于$1 + frac$；而Denormalized的情况$frac$前面是$0$，$M$默认就是$frac$，即规定</p><script type="math/tex; mode=display">M = \begin{cases}1+frac, & exponent \neq 0 \\frac, & exponent = 0\end{cases}</script></li></ul><p>Normalized例子：</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/319-2.png" class="" title="319-2"><p>Denormalized例子：</p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/319-3.png" class="" title="319-3"><p>模块端口定义如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">float[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位半精度浮点数（IEEE-754标准）</td></tr><tr><td style="text-align:center">int[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">该浮点数的整数部分（带符号），用32位符号数的补码来表示，超出表示范围则取低32位。 <strong>第3类Infinity和第4类NaN为了简化直接输出0即可</strong></td></tr></tbody></table></div><ul><li>必须严格按照模块的端口定义</li><li>文件内模块名: <strong>ftoi</strong></li><li>测试电路：</li></ul><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/319-4.png" class="" title="319-4"><ul><li><strong>注意:请保证模块的appearance与下图完全一致，否则有可能造成评测错误</strong>(查看模块appearance方法:在Logisim中打开相应模块后点击左上角</li></ul><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/319-6.png" class="" title="3196.png"><h2 id="5-个人解答-思路总结"><a href="#5-个人解答-思路总结" class="headerlink" title="5.个人解答-思路总结"></a>5.个人解答-思路总结</h2><h3 id="T1-CRC"><a href="#T1-CRC" class="headerlink" title="T1.CRC"></a>T1.CRC</h3><p>本题给了详细的思路引导，只要实现教程上说的就行，注意细节和仔细读题就行。搭建过程中有不少重复模块，也并非一道很简单的题。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>先设计四位模二除法器，如果$A$最高位为$0$，输出的商为$0$，余数为$A$本身；否则商为$1$，余数为$A\oplus B$。这里涉及到选择语句，我们需要把可能的情况均算出来接到$MUX$上，商和除数前各一个$MUX$，选择端为$A[3]$。</li><li>再设计顶层模块，将八位后面部三个$0$，进行类似于除法竖式的操作，每次余数三位再把后面一位取下来，一共需要进行$8$次，调用$8$次$4div4$模块。商对我们没有用处，只需将三位余数和被除数的下一位用分线器合在一起引入下一$4div4$层即可。</li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>1.记得补三个$0$！否则测评数据点会恰好错一个位。体现了读题的重要性。往往开始做题又会忘掉一些细节。</p><p>2.用好Tunnel，但不要过多。不要一眼望过去全是Tunnel，尽量“线比隧道多”。</p><h4 id="Logisim源文件与连线截图"><a href="#Logisim源文件与连线截图" class="headerlink" title="Logisim源文件与连线截图"></a>Logisim源文件与连线截图</h4><p><a href="https://github.com/pppphop/pppphop.github.io/blob/main/blog files/crc.circ">crc.circ</a></p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251012201301017.png" class="" title="image-20251012201301017"><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251012201317373.png" class="" title="image-20251012201317373"><h3 id="T2-GRF"><a href="#T2-GRF" class="headerlink" title="T2.GRF"></a>T2.GRF</h3><p>乍一看本题让人非常为难、难以下手：什么？要我摆32个寄存器？还要选择输入输出，还有使能信号？不禁让人皱起眉头。事实上，我们理清思路，或者“先做好一定要做的”，一步步来不要畏惧，会发现这是一道很简单的题。</p><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>摆上32个寄存器，因为元件多，所以我们一点要注重外观的整齐，不会到后面一团乱麻，建议$8\times4$排列。</li><li>然后我们处理输出，这个不存在使能，有$A1$，$A2$就有$RD1$，$RD2$输出。那么“指定输出低$i$个寄存器里的值”，即输出序号为$i$的寄存器里的值，要怎么实现？我们要将$32$个寄存器的输出端均接到一个$MUX$上，$A1$信号作为选择断即可。$A2$和$RD2$同理。只是连线确实多，需要一点耐心。</li><li>输入的使能和选择怎么办？我们用好寄存器的使能端。这应该是迄今为止第一次用上寄存器使能端。有很多种方法，比如在每个寄存器使能端前面放个比较器，结果和$WE$与起来连上去，是可行的，但是繁琐复杂凌乱。我们选择使用与$MUX$对应的$DEMUX$，把$WE$接输入$A3$接选择端就行。</li></ol><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>善用Tunnel，本题Tunnel不怕多，不可能把32条线全部引出来连在$MUX$上；</li><li>$0$号寄存器始终为$0$，也就是$WD$不接入$0$号寄存器的D端，而是接入<code>32&#39;b0</code>；</li><li>巧用Ctrl C+V，可以将寄存器设置好后，$1\rightarrow 2 \rightarrow 4 \rightarrow 8 \rightarrow 16 \rightarrow 32$，就能迅速搞定这32个寄存器。Tunnel也可以复制粘贴，每次改一下标签。</li></ol><h4 id="Logisim源文件与连线截图-1"><a href="#Logisim源文件与连线截图-1" class="headerlink" title="Logisim源文件与连线截图"></a>Logisim源文件与连线截图</h4><p><a href="https://github.com/pppphop/pppphop.github.io/blob/main/blog files/grf.circ">grf.circ</a></p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251013142829715.png" class="" title="image-20251013142829715"><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251013142901730.png" class="" title="image-20251013142901730"><h3 id="T3-Navigation"><a href="#T3-Navigation" class="headerlink" title="T3.Navigation"></a>T3.Navigation</h3><p>本题是最常规的一道题，就是普通的Moore型有限状态机，真值表生成状态转移电路。</p><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>真值表生成$status_{next}$和$hit$；</li><li>$3$位寄存器存$status_{now}$，初值为$0$故无需赋初值；</li><li>分线器将输入的$dir$和$status<em>{now}$传入状态转移模块，得到$status</em>{next}$和$hit$；</li><li>因为$hit$需要保持一拍，所以传入一个寄存器再输出。</li></ol><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>状态转移模块的$hit$应该是“如果走下一拍是不是在墙里面”，这样通过寄存器缓一拍是刚好的。</li><li>当前寄存器的值为$4$时输出$arrival=1$，其余时候保持$0$。</li><li>仔细读题，“到达B机房后计小组将会在下一周期回到原点，（下一周期的输入将被忽略掉）”所以我们这么做是没有问题的，相当于他在$B$还是停留了一拍，这一拍用来输出$arrival=1$，也体现了这是个Moore型有限状态机</li></ol><h4 id="Logisim源文件与连线截图-2"><a href="#Logisim源文件与连线截图-2" class="headerlink" title="Logisim源文件与连线截图"></a>Logisim源文件与连线截图</h4><p><a href="https://github.com/pppphop/pppphop.github.io/blob/main/blog files/navigation.circ">navigation.circ</a></p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251013145400358.png" class="" title="image-20251013145400358"><h3 id="T4-FSM"><a href="#T4-FSM" class="headerlink" title="T4.FSM"></a>T4.FSM</h3><p>这是很常见的Mealy型状态机，但是想要一次搭对并不简单，难点和易错点其实在同步复位。</p><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>真值表生成状态转移电路；</li><li>状态仅$0$，$1$，$2$，三种，当$status_{now}=2$且$in=0或2$时输出$Z=1$，这体现了本题是Mealy型状态机，与输入有关</li><li>接入同步复位，具体步骤见注意事项。</li></ol><h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>同步复位不能！直接将$clk$和$reset$与起来接到寄存器的$reset$端！不信可以自己试验一下。正确步骤是，将$reset$取反（默认高电平时复位），再进行符号扩展，与正常要输入到寄存器的内容与起来再连到D端；</li><li>$reset$取反后扩展的位数和寄存器位数保持一致</li><li>本题刚开始连的时候你会感到奇怪，怎么没有输入$clk$信号？那么就是我们从组件中直接拿出$Clock$就行了。</li></ol><h4 id="Logisim源文件与连线截图-3"><a href="#Logisim源文件与连线截图-3" class="headerlink" title="Logisim源文件与连线截图"></a>Logisim源文件与连线截图</h4><p><a href="https://github.com/pppphop/pppphop.github.io/blob/main/blog files/fsm.circ">fsm.circ</a></p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251013170526900.png" class="" title="image-20251013170526900"><h3 id="T5-ftoi"><a href="#T5-ftoi" class="headerlink" title="T5.ftoi"></a>T5.ftoi</h3><p>一道组合逻辑，难！不愧是附加题，对于我这种比较蠢的，相当于跳出了我的“舒适圈”，看到题就无处下手了。放在高中，这算是一道“新定义”题。个人觉得题目其实挺难读懂的，比如取整数是个什么取法。但我朋友都说还好。</p><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>一步步来，先将输入的$float$拆成三部分，$sign$，$exp$，$frac$；</li><li>我们判断他是$Normal$，$Denormal$，$Inf$，还是$NaN$。我这里用两个$MUX$来判断，选择端是比较器的结果，输入端是常数$0$，$1$，$2$，得到判断类型的$fl$；</li><li>Normalized要在$frac$开头拼接$1$，Denormalized则不需要。因为后续要接入$MUX$，所以两种都要写（后者其实没动，实际上不用写）；</li><li>把$E=exp-01111_2$算出，$E$的最高位代表$2$的幂次是正是负，设为$neg$；</li><li>如果$neg=1$，$E$在有符号意义下为负，则应该右移，否则左移，我们用移位器完成这两个板块，并接到一个$MUX$上，选择端是$neg$；</li><li>将这时候两种情况的都右移$10$位，实现取整的功能；</li><li>根据$sign$决定是否要取负数就行了。我这一步做的比较复杂，用的取反加一，其实可以直接使用Negator。</li></ol><h4 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>取整数不是取整，-0.0028取整数部分就是0，0.625取整数也是0，不要搞复杂了。</li><li>左移右移需将$frac$扩展至$32$位</li></ol><h4 id="Logisim源文件与连线截图-4"><a href="#Logisim源文件与连线截图-4" class="headerlink" title="Logisim源文件与连线截图"></a>Logisim源文件与连线截图</h4><p><a href="https://github.com/pppphop/pppphop.github.io/blob/main/blog files/ftoi.circ">ftoi.circ</a></p><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251013180659668.png" class="" title="image-20251013180659668"><img src="/2025/09/26/P0%E8%AF%BE%E4%B8%8B-%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D%E6%96%87%E6%A1%A3/image-20251013180713158.png" class="" title="image-20251013180713158">]]></content>
    
    
    <categories>
      
      <category>CO课下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>CO课下</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
