---
title: P1课下-总结反思
date: '2025-10-25T7:58:22+08:00'
math: true
categories: 
- 北航计算机组成原理
tags: ["CO", "总结"]
---

这次可能是最简单的一次课下了？只有附加题较难。当然这并不是好事，可能会导致上机难度陡然上升而我们在课下没有得到充分练习的情况。还是与往常一样，分为教程复现，题面，思路与题解三部分。

## 教程

### Verilog FSM 设计流程

#### 设计流程

对于状态机的概念和用法在理论课和前面部分的学习中接触到了很多，所以在此不再过多叙述。

在 Verilog HDL 中可以用许多种方法来描述有限状态机，最常用的方法是用 **always 语句**和 **case 语句**。下面具体说明用 Verilog 设计有限状态机的一般步骤：

1. 逻辑抽象，得出状态转换图。

2. 状态化简（该步骤可以省略），如果在状态转换图中出现两个一样的状态则需要将其合并为一个状态，以得到最简的状态转换图。

3. 状态分配，也就是状态编码。通常有很多种编码方式，比如 Gray 编码、独热编码等。在实际电路中，需综合考虑电路复杂度与电路性能之间的折中。这里的设计没有用到特别复杂的电路逻辑，所以大家可以自行决定用哪种编码方式。（不过，对于需要在FPGA上运行的电路，推荐使用**独热**编码方式。因为 [FPGA](http://cscore.buaa.edu.cn/tutorial/fpga/intro/intro/) 有丰富的寄存器资源，门逻辑相对缺乏，采用独热编码可以有效提高电路的速度和可靠性，也有利于提高器件资源的利用率。）

   下面利用独热编码来介绍状态编码定义的两种方式：parameter 和 `define 语句。

   - 用 parameter 参数定义：用 n 个 parameter 常量表示 n 个状态，如下图所示：

   ```verilog
   parameter State1 = 4'b0001,
          State2 = 4'b0010,
          State3 = 4'b0100,
          State4 = 4'b1000;
   ...............
   
   case (State)
        State1:........;
        State2:........;
        ........
   ```

   - 用`define 语句定义：用 n 个宏名表示 n 个状态，如下所示：

   ```verilog
   `define State1 4'b0001
    // 不要加分号
   `define State2 4'b0010
   `define State3 4'b0100
   `define State4 4'b1000
   ...
   
   case (State)
       `State1:...;
       `State2:...;
       ...
   endcase
   ```

4. 根据状态转移图得出次态逻辑和输出逻辑。

5. 按照相应逻辑，用 Verilog HDL 来描述有限状态机状态转移的情况。

- 复位时回到起始状态（敏感信号为**时钟**和**复位**信号，注意同步复位和异步复位的区别）
- 用 case 或 if-else 语句描述出状态的转移（根据现态（和输入）产生次态，可以与复位时回到起始状态的语句放在同一个 always 块中，即敏感信号为时钟和复位信号）
- 输出信号描述。用 case 语句或 if-else 语句描述状态机的输出信号

#### 设计建议

下面给出设计的几点建议：

- 一般用 **case、casez 或 casex** 语句进行状态判断，比用 if-else 语句更加清晰明了。
- 在 case 语句的最后，要加上 **default** 分支语句，以避免锁存器的产生。
- 状态机一般应设计为**同步**方式，并由一个时钟信号来触发。
- 实用的状态机都应设计为由唯一的**时钟边沿**触发的**同步**运行方式。

### Verilog 状态机设计示例

#### MOORE 型状态机设计示例

在上一节中，我们复习了 Verilog 状态机的设计流程。这一节我们以一个简单的状态机为例，解析如何全面地设计一个 Moore 型状态机。下面是一道简单的题目：

#### 用于识别串 1010 的自动机

clk 上升沿时，读入一个字符 in ，这时若`1010`是已读入的字符串的后缀，则 out 输出`1`，否则输出`0`。

> 例如：对于已有输入`101`，输出为`0`，对于`101010`，输出为`1`。

设计状态机的第一步，我们需要先分析问题，确定状态的**数量**和**定义**。

这道题我们需要设计一个识别 1010 的状态机。要确定它的状态数量，我们可能直觉认为要设置5种状态，分别处理读入了 ∅,1,10,101,1010 五种情况。这种想法是可行的，我们先根据这个直观的理解画出部分状态转换图，其中 state=0,1,2,3,4 分别对应“读入了∅,1,10,101,1010”。

![p1.0.5.2](/images/posts/p1.0.5.2.png)

显然，如果从零时刻开始，串行输入 1010 ，状态机会按照 state=0->1->2->3->4 的顺序转移，假如我们规定 out=1 当且仅当 state=4 ，那么状态机可以正确识别 1010 的串。问题是，当匹配到 101 时，如果读入了一个1，得到了 1011 ，我们该如何正确选择应该转移到哪个状态？为此，我们要用一种啰嗦的方式严格定义状态 statei 的意义。我们看到，所谓“读入了 ∅,1,10,101,1010”是一种很模糊的说法，它有歧义。例如字符流是 1010 ，我们该说“读入了10”，还是“读入了1010”呢？因此，原来的说法不是良好的定义，因为它不能单单根据字符流来确定究竟是哪个状态。

**定义**：设目标字符串 1010 为 str；状态机处于 statei 当且仅当：i>0, 设所有 1<=j<=4, str[1:j] 能匹配的输入字符流的后缀为 **S**，str[1:i] 匹配的输入字符流的后缀在 **S** 中最长; i=0, 当且仅当所有 1<=j<=4, str[1:j] 都不能匹配输入字符流的任何一个后缀。

str[1:i] 的意义是 str 第 1 个字符到第 i 个字符的部分，比如 str[1:4] 就是 **1010**。通过这个定义，我们就可以很好地直接根据字符流确定是哪个状态。例如读入了 1010 时，显然 str[1:2], str[1:4] 都可以匹配 1010 的后缀，前者对应 state2，后者对应 state4，然而后者匹配的后缀长度最长，因此我们确定这时应该是 state=state4。

这样的定义是有好处的，有了它，我们就可以根据字符流判断是哪个状态。当然，这种状态的正确性的维护有赖于状态转移函数的选择。如果状态转移函数胡乱规定，我们就无法确定状态的正确性。

![p1.0.5.2](/images/posts/p1.0.5.2.png)

在这里，我们采用类似于动态规划的思路规划状态转移函数。思路是：每在状态之间加入一条或几条表示状态转移的边，都要保证这样的操作能维持一个**性质**——在外界输入保证变换只涉及当前已经加入的边的条件下，涉及到的状态不违背我们事先约定的定义。

现在我们有四条边，我们考虑在这四条边上进行状态转移的情况。初始状态为 state=0。显然要走到 4，只有一条路径 0->1->2->3->4，对应输入 1010。state=0 时，我们回顾**定义**，输入的字符流是 ∅，这时谁也匹配不了，我们保持了状态定义的正确性；state=1，输入的字符流是 1，str[1:i], i=1 能匹配最长的后缀，而别的 str[1:j] 都不能匹配，我们再次保持了状态定义的正确性……接下来你可以自己推导，我们初步的状态转移设置确实维护了**定义的正确性**。

接下来，我们要补全状态转换图。当前的状态转换图是不完整的，我们在维持定义正确性的前提下补全每个状态下 0,1 两种输入对应的状态转移后，就得到了完整的正确的状态转换图。

首先从 state=0 开始考虑，我们欠缺了输入为 0 的情况。我们尝试加入一条边，再验证它的正确性。

![p1.0.5.3](/images/posts/p1.0.5.3.png)

首先，我们根据前面的分析，知道假如状态转移只走之前加过的边，状态的定义是被保持的。现在我们考虑经过新加边的情况。当 state=0，对任意 1<=j<=4，输入字符流的末尾没有一个符合 str[1:j]，新加边表示我们又读入了一个 0，显然还是没有 statej 来匹配输入字符流的后缀。因此新加边没有影响定义的正确性。

接着我们看 state=1。我们像上面一样，添加一个状态转移边并分析正确性。

![p1.0.5.4](/images/posts/p1.0.5.4.png)

回顾定义，state=1 时，字符串"1"即 str[1:1] 匹配的输入字符流的后缀在所有状态中最长的。隐含的意思是，我们不需要考虑输入字符流的后缀有什么“101”的情况。这时我们读入了一个字符 1，那么输入字符流的一个后缀是 11，我们扫遍所有的 statej，发现还是 state1 匹配的后缀最长，因此要保持在 state=1。我们再次维护了上述的定义的正确性。

以此类推，我们容易得到正确的状态转移图：

![p1.0.5.5](/images/posts/p1.0.5.5.png)

最后，把状态转换图改写成对应的 Verilog 程序，并注意根据 state 维护 out 的值，我们就成功实现了一个能正确识别1010串的 Moore 型有限状态机。

```verilog
module fsm_1010(
     input clk,
     input in,
     output reg out = 0
    );

    reg [2:0] state = 0;
     /* state 被期望能够正确表示当前累计读入的 1010 前缀的长度。
     比如未读入时 state=0; 读入到 10 时我们期望有 state<=2。*/

     always @(posedge clk) begin
        case (state)
        0:
            begin
                state <= in == 1 ? 1 : 0;
                out <= 0;
            end
        1:
            begin
                state <= in == 1 ? 1 : 2;
                out <= 0;
            end
        2:
            begin
                state <= in == 1 ? 3 : 0;
                out <= 0;
            end
        3:
            begin
                state <= in == 1 ? 1 : 4;
                out <= (in == 0);
            end
        4:
            begin
                state <= in == 1 ? 3 : 0;
                out <= 0;
            end
        endcase
    end
endmodule
```

#### 状态机编码风格

前面我们已经知道了如何使用 Verilog 语言来描述状态机。这里介绍一下状态机的典型状态编码风格，仍然使用前面的例子进行分析。状态机的编码风格有一段式（也称高速状态机）、两段式、三段式等。

##### 一段式状态机

一段式状态机将整个状态机编写在**一个** always 模块里，该模块采用同步时序逻辑，全部使用非阻塞赋值。该模块既描述状态转移，又描述状态的输入和输出。上面的例程就是典型的一段式状态机。

采用一段式状态机在思路上比较容易，书写的用时少，且运行速度快，在上机的时候可以节省编码的用时。但缺点是维护代码和调试比较困难。采用两段式和三段式状态机可以避免以上问题。

##### 两段式状态机

两段式状态机使用**两个** always 模块，第一个 always 模块采用同步时序逻辑描述状态转移；第二个 always 模块使用组合逻辑判断状态转移的条件，描述状态转移的规律。

和一段式状态机相比，采用两段式状态机实现了同步时序列逻辑和组合逻辑的分离，便于阅读、理解和维护，有利于综合工具优化代码，方便用户添加时序约束条件。但缺点是编码环节多，代码量稍大，较为繁琐，因为要将其拆分成两个不同的模块。

示例代码

```verilog
module fsm_1010 (
    input clk,
    input in,
    output reg out
);

reg [2:0] state = 0;
reg [2:0] next_state;

// 描述状态转移的时序逻辑
always @(posedge clk) begin
    state <= next_state; // 这里还可以视情况添加复位功能
end

// 判断状态转移条件以及产生输出组合逻辑
always @(state, in) begin
    case (state)
        0:
            begin
                next_state = in == 1 ? 1 : 0;
                out = 0;
            end
        1:
            begin
                next_state = in == 1 ? 1 : 2;
                out = 0;
            end
        2:
            begin
                next_state = in == 1 ? 3 : 0;
                out = 0;
            end
        3:
            begin
                next_state = in == 1 ? 1 : 4;
                out = 0;
            end
        4:
            begin
                next_state = in == 1 ? 3 : 0;
                out = 1;
            end
        default:
            begin
                next_state = 0;
                out = 0;
            end
    endcase
end

end module
```

##### 三段式状态机

三段式状态机使用**三个** always 模块，第一个 always 模块采用同步时序逻辑描述状态转移；第二个 always 模块采用组合逻辑判断状态转移条件，描述状态转移规律；第三个 always 模块采用组合逻辑或者时序逻辑述每个状态的输出。

和两段式状态机相比，这样可以减少毛刺的产生（想想这是为什么）。其缺点和两段式状态机相同，编码复杂，消耗的资源也比较多，因为需要初态和次态状态寄存器等。

> 这是因为三段式状态机将输出分离成独立的组合逻辑，减小了关键路径和时延，所以可以减少毛刺现象。

示例代码

```verilog
module fsm_1010 (
    input clk,
    input in,
    output reg out
);

reg [2:0] state = 0;
reg [2:0] next_state;

// 描述状态转移的时序逻辑
always @(posedge clk) begin
    state <= next_state;
end

// 判断状态转移条件的组合逻辑
always @(state, in) begin
    case (state)
        0:
            begin
                next_state = in == 1 ? 1 : 0;
            end
        1:
            begin
                next_state = in == 1 ? 1 : 2;
            end
        2:
            begin
                next_state = in == 1 ? 3 : 0;
            end
        3:
            begin
                next_state = in == 1 ? 1 : 4;
            end
        4:
            begin
                next_state = in == 1 ? 3 : 0;
            end
        default:
            begin
                next_state = 0;
            end
    endcase
end

// 产生输出的组合逻辑
always @(state) begin
    out = (state == 4) ? 1 : 0;
end

endmodule
```

##### 小结

上面的例子是针对 Moore 状态机的，在 Mealy 状态机上也可以尝试使用这三种风格进行状态机的书写，代码框架是相同的。

同学们可以根据自身情况选用这三种不同风格的状态机，但一定要明白它们的内在区别和其中的设计原理，帮助自己在课下和上机的时候顺利完成各种状态机的书写。

| 思考题                                                       |
| ------------------------------------------------------------ |
| Verilog 语言和 Logisim 软件都可以用来对数字电路进行建模，你认为它们各有什么优缺点？ |
| 在使用 Verilog 编写电路时，一般很少使用到循环语句，如`for`语句等，Verilog 语言中也不包含`break`、`continue`这样的关键字。思考这是为什么？ |
| Verilog 中的`generate`块在教程正文中并未提及，但有时这种语法可以给我们编写模块带来许多方便之处。请查阅相关资料，了解其作用与相关用法。 |

### Verilog 模块代码样例

#### 小型通用模板

这一节主要给出笔者个人对于不同需求的代码样例，供大家参考。

- MUX

  ```verilog
  assign result = (Aluop == 4'd0) ? (srca + srcb) :
                     (Aluop == 4'd1) ? (srca - srcb) :
                     (Aluop == 4'd2) ? (srca & srcb) :
                     (Aluop == 4'd3) ? (srca | srcb) :
                     (Aluop == 4'd4) ? (srca ^ srcb) :
                     (Aluop == 4'd5) ? (srca > srcb) :
                     32'd0;
  ```

- 如果涉及有符号数的运算，不推荐使用三目运算符，推荐使用 always@(*) 的方式，一般来说 always@(*) 配合 case 写出的类似 MUX 语句在仿真中的行为类似纯组合逻辑，但是 result 在写代码时应写为 reg 型。

  ```verilog
  always @(*) begin
        case(Aluop)
          4'd0:begin
              result = srca + srcb;
          end
          4'd1:begin
              result = srca - srcb;
          end
          4'd2:begin
              result = srca & srcb;
          end
          4'd3:begin
              result = srca | srcb;
          end
          4'd4:begin
              result = srca ^ srcb;
          end
          4'd5:begin
              result = srca > srcb;
          end
      endcase
    end
  ```

- 流水线寄存器（P5）

  ```verilog
  module pipeline_sample(
     input clk,
     input reset,
     input stall,
     input flush,
     input [31:0] aluResultAtExe,
     // 可能还有其他来自前一级的输入
     output [31:0] aluResultAtMemory
     // 可能还有要输出到后一级的
     // 输入输出应配对
     );
     // 根据端口定义，可能还要开其他的临时寄存器
     reg [31:0] aluResult;
     // 根据临时寄存器的值，可能还要连其他的线
     assign aluResultAtMemory = aluResult;
  
     always @(posedge clk)
     // 可能还要处理其他的临时寄存器
     begin
         // 复位 或者 清除流水线寄存器（阻塞，异常中断处理会用到）
         if(reset | flush)
         begin
             aluResult <= 32'd0;
         end
         else begin
             // 判定是否应阻塞该级，不阻塞时才更新为前一级的值
             if(!stall)
             begin
                 aluResult <= aluResultAtExe;
             end
         end
     end
  
  endmodule
  ```

### Verilog 代码规范

本文档是推荐的 Verilog 编程规范，遵守本规范可以减少你代码中出现的问题，避免在“莫名其妙”的问题上浪费时间。

#### VC-001 信号名称采用 `snake_case`

信号名称通常采用 `snake_case`，即变量名全小写，单词之间用下划线分隔。

#### VC-002 信号极性为低有效用 `_n` 后缀表示

对于复位和使能信号，例如 `rst` 和 `we`，如果添加了 `_n` 后缀，表示值为零时生效（低有效，Active Low），值为一时不生效；如果没有添加 `_n` 后缀，表示值为一时生效（高有效，Active High），值为零时不生效。详细解释见下面的表格：

| 信号名称 | 极性   | 1'b1   | 1'b0   |
| :------- | :----- | :----- | :----- |
| rst      | 高有效 | 复位   | 不复位 |
| rst_n    | 低有效 | 不复位 | 复位   |
| we       | 高有效 | 写入   | 不写入 |
| we_n     | 低有效 | 不写入 | 写入   |

当代码中需要混合使用 `rst` 和 `rst_n` 的时候，采用以下的方式来转换：

```verilog
module test(
  input rst_n
);
  wire rst;

  // GOOD
  assign rst = ~rst_n;

  // GOOD
  // Verilog
  always @(*) begin
    rst = ~rst_n;
  end

endmodule
```

#### VC-003 信号仅在一个 `always` 块中赋值

通常情况下，一个信号只会在一个 `always` 块中赋值。

#### VC-004 组合逻辑采用 `always @(*)` 块或者 `assign` 编写

组合逻辑的 `always` 块，使用以下的写法：

```verilog
// Verilog
always @(*) begin
  c = a + b;
end

// GOOD
assign c = a + b;
```

#### VC-005 组合逻辑 `always` 块中仅使用阻塞赋值

表示组合逻辑的 `always` 块中所有的赋值请使用阻塞赋值（`=`）。

#### VC-006 组合逻辑 `always` 块中保证每个分支都进行赋值

如果使用了条件语句 `if`，需要保证信号在每个可能的分支途径下都进行了赋值。

```verilog
// GOOD
always @(*) begin
  if (reset_n) begin
    c = a + b;
  end else begin
    c = 1'b0;
  end
end

// BAD
always @(*) begin
  if (reset_n) begin
    c = a + b;
  end
end
```

请不要列举敏感信号：

```verilog
// BAD
always @ (b, c) begin
  a = b + c;
end
```

#### VC-007 时序逻辑在 `always @(posedge clock)` 中实现

当需要表示时序逻辑时，使用以下的写法：

```verilog
// Verilog
always @(posedge clock) begin
  c <= a + b;
end
```

#### VC-008 时序逻辑 `always` 块中仅使用非阻塞赋值

时序逻辑 `always` 块中，所有的赋值请使用非阻塞赋值（`<=`）。

#### VC-009 不要使用下降沿触发，特殊协议除外

通常情况下，请不要使用下降沿触发：

```verilog
// BAD: do not use negedge
always @ (negedge clock) begin
end
```

#### VC-010 不要使用非时钟 / 复位信号的边沿触发

通常情况下，不要使用除了时钟和复位以外的信号做边沿触发。

```verilog
// BAD: do not use non-clock/reset signals
always @ (posedge signal) begin
end
```

#### VC-011 时序逻辑中不要使用时钟信号

在时序逻辑中，请不要在敏感列表以外的地方使用时钟信号：

```verilog
// BAD
always @ (posedge clock) begin
  if (clock) begin
    a <= 1;
  end
end
```

#### VC-012 使用同步复位，而不是异步复位

对于 FPGA，请使用同步复位：

```verilog
// Verilog
always @(posedge clock) begin
  if (reset) begin
    c <= 1'b0;
  end else begin
    c <= a + b;
  end
end
```

#### VC-013 不要在内部模块中使用 `inout`

FPGA 内部的模块之间请不要使用 `inout`，仿真环境除外。

#### VC-014 用 localparam 命名状态机的各个状态

编写状态机的时候，用 `localparam` 命名各个状态：

```verilog
// GOOD
localparam sInit = 2'd0;
localparam sIdle = 2'd1;
localparam sWork = 2'd2;
localparam sDone = 2'd3;

reg [1:0] state;
```

如果仿真工具不支持在波形中显示为对应的状态名称，可以采用以下的方法：

```verilog
`ifndef SYNTHESIS
  reg [39:0] state_string; // 40 bits = 5 byte

  always @ (*) begin
    case(state)
      sInit: state_string = "sInit";
      sIdle: state_string = "sIdle";
      sWork: state_string = "sWork";
      sDone: state_string = "sDone";
      default: state_string = "?????";
    endcase
  end
`endif
```

此时在仿真波形中，`state_string` 信号就可以看到状态的名称了。

### 其他可参考的 Verilog 编程规范

- 本规范修改自 [thu-cs-lab/verilog-coding-standard](https://github.com/thu-cs-lab/verilog-coding-standard)
- [Verilog Coding Standard](http://fpgacpu.ca/fpga/verilog.html)
- [lowRISC Verilog Coding Style](https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md)

## P1课下题面

### P1_L0_splitter-Verilog部件设计(P1.Q1)

### 前言

在这个部分中，我们的目标是完成Splitter、ALU和EXT的搭建。相信经过之前的学习，大家对这三个组合逻辑部件已经有了一定的了解。在组合逻辑电路中，这是相当简单的例子。我们也希望大家能够从这些简单的例子中，复习使用 Verilog 进行电路设计的一般流程，并且学会如何测试自己所搭建电路的正确性。在本门课程中，Debug 和测试将会是非常重要的技能，希望大家能在课下努力锻炼这种能力。

### 1、Verilog 实现 Splitter

使用 Verilog 搭建一个32位 Splitter , 给定一个32位的二进制数作为输入，将其划分为四个8位的二进制数作为输出。

![p1.0.1.1.png](/images/posts/p1.0.1.1.png)

### 要求：

- 必须严格按照模块的端口定义
- 文件内模块名: splitter

### P1_L0_ALU-Verilog部件设计(P1.Q2)

### 2、Verilog 实现 ALU

使用 Verilog 搭建一个 32 位六运算 ALU 并提交。具体模块端口定义如下：

![p1.0.2.1.png](/images/posts/p1.0.2.1.png)

模块功能定义如下：

![p1.0.2.2.png](/images/posts/p1.0.2.2.png)

### 知识复习：

在这里我们需要复习逻辑右移和算术右移的区别：

逻辑右移不考虑符号位，右移一位，左边补零即可。

算术右移需要考虑符号位，右移一位，若符号位为 1 ，在左边补 1 ；否则，补 0 。

例如，8 位二进制数 10111101 分别右移2位。

- 逻辑右移结果为**00**101111
- 算术右移结果为**11**101111

### 提示：

在进行有符号数的相关操作时，应注意 **$signed()** 的使用。若有必要，请参照Verilog教程的语法部分中的相关介绍进行复习。

### 要求：

- 必须严格按照模块的端口定义
- 文件内模块名: alu

### P1_L0_EXT-Verilog部件设计(P1.Q3)

### 3、Verilog 实现 EXT

EXT为扩展单元，其主要功能是完成将输入到其中的16位数据进行符号扩展、零扩展以及将输入的16位数加载到高位等操作。具体模块端口定义如下：

![p1.0.3.1.png](/images/posts/p1.0.3.1.png)

模块功能定义如下：

![p1.0.3.2.png](/images/posts/p1.0.3.2.png)

### 要求：

- 必须严格按照模块的端口定义
- 文件内模块名: ext

### P1_L0_gray-Verilog时序逻辑(P1.Q4)

### 提交要求

### 1、前言

在完成了 Verilog 组合逻辑部件设计的三道编程题之后，相信大家对于使用 Verilog 进行设计的一般流程和方法已经再次熟悉。现在，我们将进行下一步的挑战——设计包含**时序逻辑**的 Verilog 部件，这也将是我们从组合逻辑部件到之后的**有限状态机**的重要过渡。 在 Verilog 的教程部分，我们曾设计了一个简易的计数器。而我们现在的任务就是设计一个加强版的计数器——格雷码计数器。 如果你对格雷码的定义和优点等知识有所遗忘，这个链接可以帮到你： [格雷码-wikipedia](https://en.wikipedia.org/wiki/Gray_code)

### 2、模块规格

我们的格雷码计数器端口定义如下：

![p1.0.4.1.png](/images/posts/p1.0.4.1.png)

我们要实现的功能如下：

#### 1、 在任意一个时钟上升沿到来的时候，如果复位信号有效，则将计数器清零；

#### 2、 每个时钟上升沿到来的时候，如果使能信号有效，计数器的值+1；

#### 3、 在满足1时，即使2的条件满足，也不必执行2；

#### 4、 计数器初值为0；

#### 5、 当计数器的值在+1后出现溢出的情况时，将会回到零，同时从发生溢出的这个时钟上升沿开始，溢出标志位将会持续输出1，直到计数器被清零为止（其余情况下溢出标志位必须为0）。

示范波形：

![p1.0.4.2.png](/images/posts/p1.0.4.2.png)

为了方便大家设计，这里附上3位格雷码的计数方式：

![p1.0.4.3.png](/images/posts/p1.0.4.3.png)

### 3、要求

- 必须严格按照模块的端口定义
- 文件内模块名: gray

### P1_L0_表达式状态机-Verilog表达式状态机(P1.Q5)

### 提交要求

### 1、简介

计算机经常用于处理关于表达式的问题。现在有这样一类表达式F的字符串需要你来验证它们的合法性：

1、表达式F中只含有数字0-9，加号+，乘号*。

2、表达式F可以按如下的规则产生：

a. 单个数字[0-9]是F； b. 如果**X**是F，**Y**是F，**X+Y**也是F； c. 如果**X**是F，**Y**是F，**X\*Y**也是F。

排除显而易见的所用符号不合法，所有的非法情况总结如下：

![p1.0.6.1.png](/images/posts/p1.0.6.1.png)

现在，我们需要你用Verilog HDL语言设计一个有限状态机来识别这样的表达式。

### 2、模块规格

模块名：**expr**

![p1.0.5.1.png](/images/posts/p1.0.5.1.png)

### 3、功能要求

每个时钟上升沿，状态机从 in 中读入一个ASCII编码的字符。假设读入的第i个字符为ci，则第n个时钟上升沿时，可以拼出一个字符串:

s=c1c2....cn

我们需要你此时判断 s 是否符合表达式F的定义。假如s符合F的定义，那么 out 应输出1，否则输出0。

另外，每个 clr 上升沿时，请清零状态；如果 clk 的上升沿时 clr 为 1，也需要清零状态。清零后，上面定义的字符串s也应从空串开始计算。如果s当前是空串，out也应输出0。注意，我们不需要你分析表达式的语法和语义，只要判断形式上合法性就可以正确求解。

### 4、输入输出样例

时序规范：总是保证in信号稳定时clk才产生上升沿。

输入：s = **1+2+3+4** 输出：out = 1

输入：s = **1+2+3+** 输出：out = 0

示范波形（输入：s=**1+2\*3**, 清零一周期, s'=**1+2\*3**。时钟周期10ns）：

![p1.0.4.3 1.png](/images/posts/p1.0.4.3__1_.png)

### 5、提交要求

- 必须严格按照模块的端口定义。
- 文件内模块名: **expr**
- 注意由于 `string` 是 SystemVerilog 的保留字，本题模块名改为 **expr**。

### P1_L1_BlockChecker-语句块检查模拟(附加题)

本题为附加题，通过与否不计入P1课下通过条件。

现在需要你用Verilog语言编写一个模拟语句块检查的工具。

为了简化要求，**输入由ASCII字母和空格组成**。一个或多个连续出现的字母构成一个单词，单词**不区分大小写**，单词之间由一个或多个空格分隔开。检查工具检查**自复位之后的输入中**，begin和end是否能够匹配。

匹配规则类似括号匹配：一个begin只能匹配一个end，但是一个匹配的begin必须出现在对应的end之前；允许出现嵌套；最后若出现不能按上述规则匹配的begin或end，则匹配失败。

输入的读取在**时钟上升沿**进行。

匹配示例：Hello world，begin comPuTer orGANization End。

不匹配示例：eND，beGin study。

**建议大家认真查看示例波形。**

模块端口定义如下：

| 信号名  | 方向 | 描述                                             |
| :------ | :--- | :----------------------------------------------- |
| clk     | I    | 时钟信号                                         |
| reset   | I    | 异步复位信号（高电平有效，复位时将输入记录清空） |
| in[7:0] | I    | 当前输入字符的ASCII码                            |
| result  | O    | 当前输入是否能够完成begin和end的匹配             |

### 提交要求

- 必须严格按照模块的端口定义
- 文件内模块名：BlockChecker
- **模块内不要包含任何$display语句** ，以防造成误判
- 我们保证在使用模块前进行复位
- **保证输入的单词数和单词长度均小于2^32**

### 示例波形

![example_blockchecker.png](/images/posts/example_blockchecker.png)

## 思路与题解

好了那么进入正题，我们依次看每道题目。可以说前三题都是白送，只需要你会一点Verilog的语法即可。时序逻辑两道题稍有新意，BlockChecker相当有难度。

### T1-splitter

四行代码搞定，依次`assign`为输入中对应的八位即可，不多解释。

```verilog
module splitter(
    input [31:0] A,
    output [8:0] O1,
    output [8:0] O2,
    output [8:0] O3,
    output [8:0] O4
    );
assign O1=A[31:24];
assign O2=A[23:16];
assign O3=A[15:8];
assign O4=A[7:0];
endmodule
```

如果你是初学者~~（虽然不应该，pre都学过语法了）~~，注意一下是从大往小写`[7:0]`而非`[0:7]`就行。

### T2-ALU

没错，这个模块将会在将来的P4中遇到，还是很重要的。只要学会使用`switch-case`语句就行了（当然你就`if-else if`也不是不行），仍然是组合逻辑，可以选择`assign`和三目运算符直接解决，或者`always @(*)`里面使用条件语句。因为情况较多，而且后者好加语句和后续维护，我倾向于使用后者。

```verilog
always @(*) begin
	case (ALUOp)
		3'b000:
			C=A+B;
		3'b001:
			C=A-B;
		3'b010:
			C=A&B;
		3'b011:
			C=A|B;
		3'b100:
			C=A>>B;
		3'b101:
			C=$signed(A)>>>({1'b0,B[30:0]});
		default C=0;
	endcase
end

endmodule
```

#### 注意事项

1.这里算数右移需要考虑符号，使用`$signed(A)`将其转换为有符号形式。其实这里比较意义不明，因为字节是$32$位的，两个右移最多$5$位有效，否则相当于在循环移。在搭建单周期$CPU$时这里会有改动。

2.建议所有条件语句都加上`default`或者`else`，以免产生锁存器，增强鲁棒性。

### T3-EXT

这题很简单，就是一个条件语句+信号位拼接的题，但我甚至卡在了编译那块，不知道为什么报语法错误。实际上还是我对拼接的语法理解模糊，少套了一层大括号。变量信号`x[y:z]`是不用加一层大括号的，但是若干个常数和信号就要了，比如`{16{1'b0}}`，会显得大括号很多。

```verilog
module ext(
    input [15:0] imm,
    input [1:0] EOp,
    output reg [31:0] ext
    );
always @(*) begin
	case (EOp)
		2'b00:
			ext={{16{imm[15]}},imm};
		2'b01:
			ext={{16{1'b0}},imm};
		2'b10:
			ext={imm,{16{1'b0}}};
		2'b11:
			ext={{14{imm[15]}},imm,2'b00};
		default: ext=0;
	endcase
end

endmodule
```

### T4-gray

其实只是计时器，把数字$0-7$重新”编码“了一下而已。最开始写着写着忘了这事。后来我在想怎么把格雷码和$cnt$一一对应上呢？我便去百度了一下，查到：
$$
G_i=B_i ~\oplus ~ B_{i+1}~~ (0\leq i\leq n-1)
$$
$G_i$为格雷码的每一位，$B_i$是二进制码的每一位，约定$B_n=0$。这样我们很快就能做出来。

```verilog
module gray(
    input Clk,
    input Reset,
    input En,
    output [2:0] Output,
    output reg Overflow
    );
reg [2:0] cnt;
always @(posedge Clk) begin
	if(Reset) begin
		Overflow<=0;
		cnt<=0;
	end
	else begin
		if(cnt==3'b111 && En==1) begin
			cnt<=0;
			Overflow<=1;
		end
		else begin
			cnt<=cnt+En;
		end
	end
end
assign Output={cnt[2],{cnt[2]^cnt[1]},{cnt[0]^cnt[1]}};
endmodule
```

### T5- expr

一个状态转移图略显奇怪的有限状态机，实际上只需要三个状态就行了。初始$S_0$，符号结尾$S_1$，数字结尾（合法序列）$S_2$，已经非法了的状态$S_3$。

![FSM](/images/posts/FSM.jpg)

或者从另一种角度来看，$S_1$是暂时非法的状态，$S_2$是暂时合法，$S_3$是永久非法，除非$reset$否则无法跳出。

```verilog
module expr(
    input clk,
    input clr,
    input [7:0] in,
    output out
    );
reg [2:0] status;
always @(posedge clk or posedge clr) begin
	if(clr) begin
		status<=0;
	end
	else begin
		case (status)
		0:
			if(in==8'd42 || in==8'd43) status<=3;
			else status<=2;
		1:
			if(in==8'd42 || in==8'd43) status<=3;
			else status<=2;
		2:
			if(in==8'd42 || in==8'd43) status<=1;
			else status<=3;
		3:
			status<=3;
		default: status<=0;
		endcase
	end
end
assign out=(status==2)?1:0;
endmodule
```

#### 注意事项

1. 字符可以用双引号引起来使用，免得像我这里一样查`ascii`表。
2. 可以看出其实是$Moore$型有限状态机，虽然题目没有明说，做的时候我也没有考虑这些。